<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html><head>
<link rel="STYLESHEET" href="openpnlref.css" charset="ISO-8859-1" type="text/css">
</head><body>

<center><table cellspacing=0 cellpadding=2 width="90%" bgcolor="#6a9bed" nosave >
<tr nosave>
<td nosave>
<center><i><font color="#000000"><font size=+4>
PNL: Reference Manual
</font></font></i></center>
</td>
</tr>
</table></center>


<hr><h2><a name="decl_pnlGraph">Graph</a></h2>


<hr><h3><a name="decl_pnlClassCGraph">Class CGraph</a></h3>

<IMG SRC="fig/PNLMarch.book-88.gif">

<p>
Class <EM CLASS="CodeReg">CGraph</EM> represents the graph structure of the model and carries out some basic
graph algorithms.
</p>

<hr><h4><a name="declCGraph_Create">Create</a></h4>
<p class="Blurb">Creates object of class.</p><pre>

static CGraph* CGraph::Create( int <EM CLASS="CodeItalic">numOfNds</EM>,  const int *<EM CLASS="CodeItalic">numOfNbrs</EM>, const int *const *<EM CLASS="CodeItalic">nbrsList</EM>, const EneighborType *const *<EM CLASS="CodeItalic">nbrsTypes </EM>);
static CGraph* CGraph::Create( int <EM CLASS="CodeItalic">numOfNds</EM>, const int *const *<EM CLASS="CodeItalic">adjMat </EM>);
static CGraph* CGraph::Create( const intVecVector&amp; <EM CLASS="CodeItalic">nbrsList</EM>,const neighborTypeVecVector&amp; <EM CLASS="CodeItalic">nbrsTypesList</EM> );
static CGraph* CGraph::Create(const CMatrix&lt;int&gt;* <EM CLASS="CodeItalic">pAdjMat</EM>);
</pre><p><dl>
 Arguments
<dt>numOfNds  <dd>Number of nodes of the graph.
<dt>numOfNbrs<dd>  Array of integer, each ith integer is the number of neighbors of the ith nodes.
<dt>nbrsList<dd>  List of neighbors for a node.
<dt>nbrsTypes<dd>  2D list of neighbor types. Each element shows the type of the corresponding neighbor from <EM CLASS="CodeItalic">
nbrsList</EM>.
<dt>nbrsTypesList <dd>2D list of neighbor types.
<dt>adjMat<dd>  2D array of integers, represents an adjacent matrix.
<dt>pAdjMat<dd>  2D integer matrix, represents an adjacent matrix.
</dl></p><p>
Call of this function creates an instance of class <EM CLASS="CodeReg">CGraph.</EM>
 Call of the class destructor deletes the instance. A node may have a neighbor of the following type: <EM CLASS="CodeItalic">
ntParent</EM>, <EM CLASS="CodeItalic">ntChild</EM>, <EM CLASS="CodeItalic">ntNeighbor</EM>.
</p>


<hr><h4><a name="declCGraph_Copy">Copy</a></h4>
<p class="Blurb">Creates class object by copying.</p><pre>

static CGraph* CGraph::Copy( const CGraph *<EM CLASS="CodeItalic">pGraph </EM>);
</pre><p><dl>
 Arguments
<dt>pGraph<dd>  Pointer to a <EM CLASS="CodeReg">
CGraph</EM>
 object to be copied.
</dl></p><p>
Call of this function creates a new object of class <EM CLASS="CodeReg">
CGraph </EM>
by copying the input object and returns a pointer to it<EM CLASS="CodeReg">.</EM> Call of the class destructor deletes the instance.
</p>


<hr><h4><a name="decl_pnlGetTopologicalOrder">GetTopologicalOrder</a></h4>
<p class="Blurb">Returns numbers of nodes according to their topological order. </p><pre>

void CGraph:: GetTopologicalOrder( intVector *<EM CLASS="CodeItalic">order</EM> ) const;
</pre><p><dl>
 Arguments
<dt>order <dd>Returned parameter. Numbers of nodes according to their topological order.
</dl></p><p>
This function returns numbers of nodes according to the order of their topological sorting.The function assumes that the graph is a DAG object.
</p>


<hr><h4><a name="declCGraph_MoralizeGraph">MoralizeGraph</a></h4>
<p class="Blurb">Creates class object by moralizing.</p><pre>

static CGraph* CGraph::MoralizeGraph( const CGraph *<EM CLASS="CodeItalic">pGraph </EM>);
</pre><p><dl>
 Arguments
<dt>pGraph<dd>  Pointer to a <EM CLASS="CodeReg">
CGraph</EM>
 object to be moralized.
</dl></p><p>
Call of this function creates a new object of class <EM CLASS="CodeReg">
CGraph </EM>
by moralizing the input object and returns a pointer to it<EM CLASS="CodeReg">.</EM>
 Call of the class destructor deletes the instance.
</p>


<hr><h4><a name="declCGraph_AddEdge">AddEdge</a></h4>
<p class="Blurb">Adds edge to existing graph.</p><pre>

void CGraph::AddEdge( int <EM CLASS="CodeItalic">startNode</EM>, int <EM CLASS="CodeItalic">endNode</EM>, int <EM CLASS="CodeItalic">directed</EM> );
</pre><p><dl>
 Arguments
<dt>startNode<dd>  Starting node of the edge.
<dt>endNode<dd>  Ending node of the edge.
<dt>bDirected<dd>  Edge orientation. The argument shows if the edge is directed. Equals to 1 (true), if the edge is directed, and equals to 0 (false) otherwise.
</dl></p>


<hr><h4><a name="declCGraph_ChangeEdgeDirection">ChangeEdgeDirection</a></h4>
<p class="Blurb">Changes direction of existing graph.</p><pre>

void CGraph::ChangeEdgeDirection( int <EM CLASS="CodeItalic">startNode</EM>, int <EM CLASS="CodeItalic">endNode</EM> );
</pre><p><dl>
 Arguments
<dt>startNode<dd>  Starting node of the edge for which direction should be changed.
<dt>endNode<dd>  Ending node of the edge for which direction should be changed.
</dl></p>


<hr><h4><a name="declCGraph_GetNeighbors">GetNeighbors</a></h4>
<p class="Blurb">Gets all neighbors for given node with orientation vector.</p><pre>

int CGraph::GetNeighbors( int <EM CLASS="CodeItalic">nodeNum</EM>, int *<EM CLASS="CodeItalic">numOfNbrs</EM>, const int **<EM CLASS="CodeItalic">nbrs</EM>, const ENeighborType **nbrsTypes ) const;
void CGraph::GetNeighbors( int nodeNum, intVector* <EM CLASS="CodeItalic">nbrsOut</EM>, neighborTypeVector *<EM CLASS="CodeItalic">nbrsTypesOut</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node for which neighbors should be found.
<dt>numOfNbrs<dd>  Returned value, pointer to the variable that takes the value equal to the number of neighbors for the node.
<dt>nbrs<dd>  Returned value, pointer to the array of the neighbors of the node.
<dt>nbrsOut <dd>Returned value. Array of the neighbors of the node.
<dt>nbrs<dd><dt>nbrsTypesOut  <dd>Returned value, each element of which shows the type of the corresponding nieghbor from <EM CLASS="CodeItalic">nbrsOut.</EM>
</dl></p>


<hr><h4><a name="declCGraph_GetNumberOfNeighbors">GetNumberOfNeighbors</a></h4>
<p class="Blurb">Returns number of neighbors for given node.</p><pre>

inline int CGraph::GetNumberOfNeighbors( int <EM CLASS="CodeItalic">nodeNum</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node for which the number of the neighbors should be found.
</dl></p>


<hr><h4><a name="declCGraph_GetNumberOfNodes">GetNumberOfNodes</a></h4>
<p class="Blurb">Returns number of all nodes in graph.</p><pre>

inline int CGraph::GetNumberOfNodes() const;
</pre>


<hr><h4><a name="declCGraph_GetNumberOfEdges">GetNumberOfEdges</a></h4>
<p class="Blurb">Returns number of all edges in graph.</p><pre>

inline int CGraph::GetNumberOfEdges() const;
</pre>


<hr><h4><a name="declCGraph_IsCompleteSubgraph">IsCompleteSubgraph</a></h4>
<p class="Blurb">Checks subset of given nodes for completeness.</p><pre>

int CGraph::IsCompleteSubgraph( int <EM CLASS="CodeItalic">numOfNdsInSubgraph</EM>, const int *<EM CLASS="CodeItalic">subgraph</EM> ) const;
int CGraph::IsCompleteSubgraph( const intVector&amp; <EM CLASS="CodeItalic">subGraphIn</EM> ) const;
</pre><p><dl>
 Arguments
<dt>numOfNdsInSubgraph<dd>  Number of nodes in the subset.
<dt>subgraph<dd>  Subset of nodes.
</dl></p><p>
This function checks whether a subset of given nodes is complete. Returns 1 if the subset of nodes is complete, returns 0 otherwise.
</p>


<hr><h4><a name="declCGraph_IsChangeAllowed">IsChangeAllowed</a></h4>
<p class="Blurb">Returns status flag for graph.</p><pre>

inline int CGraph::IsChangeAllowed() const;
</pre><p>
This function returns 1 if the change of the graph is allowed and 0 otherwise.
</p>


<hr><h4><a name="declCGraph_IsExistingEdge">IsExistingEdge</a></h4>
<p class="Blurb">Returns information on edge existence.</p><pre>

int CGraph::IsExistingEdge( int <EM CLASS="CodeItalic">startNode</EM>, int <EM CLASS="CodeItalic">endNode</EM> ) const;
</pre><p><dl>
 Arguments
<dt>startNode<dd>  Starting node of the edge.
<dt>endNode<dd>  Ending node of the edge.
</dl></p><p>
This function returns 1 for the edge if it exists in the graph and 0 otherwise.
</p>


<hr><h4><a name="declCGraph_RemoveEdge">RemoveEdge</a></h4>
<p class="Blurb">Removes edge from graph.</p><pre>

int CGraph::RemoveEdge( int <EM CLASS="CodeItalic">startNode</EM>, int <EM CLASS="CodeItalic">endNode</EM> );
</pre><p><dl>
 Arguments
<dt>startNode<dd>  Starting node of the edge.
<dt>endNode<dd>  Ending node of the edge.
</dl></p>


<hr><h4><a name="declCGraph_SetNeighbors">SetNeighbors</a></h4>
<p class="Blurb">Sets neighbors for given node.</p><pre>

void CGraph::SetNeighbors( int <EM CLASS="CodeItalic">nodeNum</EM>, int <EM CLASS="CodeItalic">numOfNbrs</EM>,  const int *<EM CLASS="CodeItalic">nbrs</EM>, const ENeighborType *<EM CLASS="CodeItalic">nbrsTypes</EM> );
void CGraph::SetNeighbors( int <EM CLASS="CodeItalic">nodeNum</EM>, const intVector&amp; <EM CLASS="CodeItalic">nbrs</EM>,const neighborTypeVector&amp; <EM CLASS="CodeItalic">nbrsTypes</EM> );
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node for which neighbors should be set.
<dt>numOfNbrs<dd>  Number of the neighbors for the node.
<dt>nbrs<dd>  Array of the neighbors for the node.
<dt>nbrsTypes<dd>  1D array of types of the neighbors of the node numbered <EM CLASS="CodeItalic">nodeNum</EM>.
</dl></p>


<hr><h4><a name="declCGraph_ProhibitChange">ProhibitChange</a></h4>
<p class="Blurb">Prohibits any change of <EM CLASS="CodeReg">CGraph</EM> object.</p><pre>

inline void CGraph::ProhibitChange() const;
</pre>


<hr><h4><a name="declCGraph_FormCliqueFromSubgraph">FormCliqueFromSubgraph</a></h4>
<p class="Blurb">Forms a clique by connecting all the nodes of the subgraph between each other.</p><pre>

void CGraph::FormCliqueFromSubgraph( int <EM CLASS="CodeItalic">numOfNds</EM>, const int *<EM CLASS="CodeItalic">subGraph</EM> );
void CGraph::FormCliqueFromSubgraph( const intVector&amp; <EM CLASS="CodeItalic">subGraph </EM>);
</pre><p><dl>
 Arguments
<dt>numOfNds<dd>  Number of nodes in subgraph of nodes.
<dt>subGraph<dd>  Subgraph, all the nodes of which should be connected to each other to form a clique.
</dl></p>


<hr><h4><a name="declCGraph_GetNumberOfParents">GetNumberOfParents</a></h4>
<p class="Blurb">Returns number of parents of the node.</p><pre>

inline int CGraph::GetNumberOfParents( int <EM CLASS="CodeItalic">nodeNum </EM>) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node, for which number of parents is queried.
</dl></p>


<hr><h4><a name="declCGraph_GetNumberOfChildren">GetNumberOfChildren</a></h4>
<p class="Blurb">Returns number of children of the node.</p><pre>

inline int CGraph::GetNumberOfChildren( int <EM CLASS="CodeItalic">nodeNum </EM>) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node, for which number of children is queried.
</dl></p>


<hr><h4><a name="declCGraph_IsDirected">IsDirected</a></h4>
<p class="Blurb">Checks if the graph is directed.</p><pre>

inline int CGraph::IsDirected() const;
</pre><p>
This function returns 1, if the graph is directed, and 0, if the graph has at least one undirected edge.
</p>


<hr><h4><a name="declCGraph_IsUndirected">IsUndirected</a></h4>
<p class="Blurb">Checks if the graph is undirected.</p><pre>

inline int CGraph::IsUndirected() const;
</pre><p>
This function returns 1, if the graph is undirected, and 0, if the graph has at least one directed edge.
</p>


<hr><h4><a name="declCGraph_GetAdjacencyMatrix">GetAdjacencyMatrix</a></h4>
<p class="Blurb">Returns adjacency matrix.</p><pre>

inline void CGraph::GetAdjacencyMatrix( CMatrix&lt;int&gt;** <EM CLASS="CodeItalic">pAdjMatOut</EM> ) const;
</pre><p><dl>
 Arguments
<dt>pAdjMatOut<dd>  Returned parameter. Pointer to the adjacency martix for the graph.
</dl></p><p>
This function returns an adjacency matrix, which corresponds to the graph described by the related <EM CLASS="CodeReg">
CGraph</EM>
 object. Note, that the adjacency matrix is not stored inside the graph and should be formed only when the user calls this member function.
</p>


<hr><h4><a name="declCGraph_ClearGraph">ClearGraph</a></h4>
<p class="Blurb">Clears graph.</p><pre>

inline void CGraph::ClearGraph();
</pre><p>
This function clears the graph by deleting lists of neighbors for all nodes and then setting the number of nodes equal to zero.
</p>


<hr><h4><a name="decl_pnloperator ==">operator ==</a></h4>
<p class="Blurb">Checks if two graphs are identical.</p><pre>

inline bool CGraph::operator ==( const CGraph&amp; <EM CLASS="CodeItalic">rGraph </EM>) const;
</pre><p><dl>
 Arguments
<dt>rGraph<dd>  Reference to the graph, which is the right-hand-side operand of the comparison operation.
</dl></p><p>
This function checks if two graphs are identical, and returns `true', if they are, and `false' otherwise.
</p>


<hr><h4><a name="decl_pnloperator !=">operator !=</a></h4>
<p class="Blurb">Checks if two graphs are not identical.</p><pre>

inline bool CGraph::operator !=(const CGraph&amp; <EM CLASS="CodeItalic">rGraph</EM>) const;
</pre><p><dl>
 Arguments
<dt>rGraph<dd>  Reference to the graph, which is the right-hand-side operand of the comparison operation.
</dl></p><p>
This function checks if two graphs are not identical, and returns `true', if they are not, and `false' otherwise.
</p>


<hr><h4><a name="declCGraph_GetParents">GetParents</a></h4>
<p class="Blurb">Returns vector of parents for node.</p><pre>

inline void CGraph::GetParents( int </EM><EM CLASS="CodeItalic">nodeNum</EM><EM CLASS="CodeReg">, intVector *</EM><EM CLASS="CodeItalic">parents</EM><EM CLASS="CodeReg"> ) const;</EM></P></pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node, for which parents are inquired.
<dt>parents<dd>  Actually returned parameter. A pointer to a 1D vector of integers that are numbers of nodes, which appear to be parents of the node numbered <EM CLASS="CodeItalic">nodeNum</EM>.
</dl></p>


<hr><h4><a name="declCGraph_GetChildren">GetChildren</a></h4>
<p class="Blurb">Returns vector of children for node.</p><pre>

inline void CGraph::GetChildren( int <EM CLASS="CodeItalic">nodeNum</EM>, intVector *<EM CLASS="CodeItalic">children</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node, for which children are inquired.
<dt>children<dd>  Actually returned parameter. A pointer to a 1D vector of integers that are numbers of nodes, which appear to be children of the node numbered <EM CLASS="CodeItalic">nodeNum</EM>.
</dl></p>


<hr><h4><a name="declCGraph_IsDAG">IsDAG</a></h4>
<p class="Blurb">Checks if graph is directed acyclic graph.</p><pre>

int CGraph::IsDAG() const;
</pre><p>
This member function returns 1, if the graph is a directed acyclic graph (DAG), and 0 otherwise.
</p>

<hr><h4><a name="declCGraph_IsBinaryTree">IsBinaryTree</a></h4>
<p class="Blurb">Returns 1 if current graph is equal to a binary tree and 0 otherwise.</p>
<pre>int IsBinaryTree() const;</pre>

<hr><h4><a name="declCGraph_IsTopologicallySorted">IsTopologicallySorted</a></h4>
<p class="Blurb">Checks if graph is topologically sorted.</p><pre>

int CGraph::IsTopologicallySorted() const;
</pre><p>
This member function returns 1, if the graph is topologically sorted. Number of a parent is always less than numbers of its children.
</p>


<hr><h4><a name="declCGraph_NumberOfConnectivityComponents">NumberOfConnectivityComponents</a></h4>
<p class="Blurb">Returns number of graph connectivity components.</p><pre>

int CGraph::NumberOfConnectivityComponents() const;
</pre><p>
This function returns a number of connectivity components of the graph it has been called for. Note that if graph has more than one connectivity components, the inference engine throws an exception. This means that in the case of several connectivity components all of them should be treated as separate graphical models.
</p>


<hr><h4><a name="declCGraph_GetConnectivityComponents">GetConnectivityComponents</a></h4>
<p class="Blurb">Returns connectivity components.</p><pre>

void CGraph::GetConnectivityComponents( intVecVector *<EM CLASS="CodeItalic">decompositionOut</EM> ) const;
</pre><p><dl>
 Arguments
<dt>decompositionOut  <dd>Returned parameter. Array of connectivity components.
</dl></p><p>
This function returns connectivity components.
</p>


<hr><h4><a name="decl_pnloperator =">operator =</a></h4>
<p class="Blurb">Assigns new value to graph object.</p><pre>

CGraph&amp; CGraph::operator =( const CGraph&amp; <EM CLASS="CodeItalic">rGraph </EM>);
</pre><p><dl>
 Arguments
<dt>rGraph<dd>  Reference to a graph, which is the right-hand-side operand of the assignment operation.
</dl></p><p>
This function assigns one existing graph to the other, so that the result is an identical copy of the input graph.
</p>


<hr><h4><a name="declCGraph_Dump">Dump</a></h4>
<p class="Blurb">Dumps graph.</p><pre>

void CGraph::Dump() const;
</pre><p>
This function dumps the graph, that is, all the neighbors and neighbors types for all nodes, to the standard output.
</p>


<hr><h4><a name="declCGraph_GetAncestry">GetAncestry</a></h4>
<p class="Blurb">Finds nodes that lie outside given subgraph but have ancestors inside.</p><pre>

void CGraph::GetAncestry( intVector const <EM CLASS="CodeItalic">&amp;subGraph</EM>, intVector <EM CLASS="CodeItalic">*closure</EM> ) const;
</pre><p><dl>
 Arguments
<dt>subGraph  <dd>Vector of indices of the input subgraph.
<dt>closure<dd>  Output vector.
</dl></p><p>
This function returns indices of nodes that do not lie but have ancestors in the given subgraph.
</p>


<hr><h4><a name="declCGraph_GetAncestralClosure">GetAncestralClosure</a></h4>
<p class="Blurb">Finds nodes that either lie inside or have ancestors in given subgraph.</p><pre>

void CGraph::GetAncestralClosure( intVector const &amp;<EM CLASS="CodeItalic">subGraph</EM>,
 intVector *<EM CLASS="CodeItalic">closure</EM> ) const;
</pre><p><dl>
 Arguments
<dt>subGraph<dd>  Vector of indices of the input subgraph.
<dt>closure<dd>  Output vector.
</dl></p><p>
This function returns indices of nodes that either lie or have ancestors in the given subgraph.
</p>


<hr><h4><a name="declCgraph_GetAncestralClosure">GetAncestralClosure</a></h4>
<p class="Blurb">Finds nodes that either lie inside or have ancestors in given subgraph.</p><pre>

void Cgraph::GetAncestralClosure( intVector const &amp;<EM CLASS="CodeItalic">subGraph</EM>,
boolVector *<EM CLASS="CodeItalic">closure</EM>Mask ) const;
</pre><p><dl>
 Arguments
<dt>subGraph<dd>  Vector of indices of the input subgraph.
<dt>closureMask<dd>  Output boolean vector-mask.
</dl></p><p>
This function finds nodes that either lie inside or have ancestors in the given subgraph and fills the boolean mask accordingly. The <EM CLASS="CodeItalic">
i</EM>
-th element of the <EM CLASS="CodeItalic">
closureMask</EM>
 is set to true only if the <EM CLASS="CodeItalic">
i</EM>
-th node belongs to the ancestral closure.
</p>


<hr><h4><a name="declCGraph_GetSubgraphConnectivityComponents">GetSubgraphConnectivityComponents</a></h4>
<p class="Blurb">Finds plain connectivity components of induced subgraph.</p><pre>

void CGraph::GetSubgraphConnectivityComponents( intVector const &amp;<EM CLASS="CodeItalic">subGraph</EM>, intVecVector *<EM CLASS="CodeItalic">decomposition</EM> ) const;
</pre><p><dl>
 Arguments
<dt>subGraph<dd>  Vector of indices of the input subgraph.
<dt>decomposition<dd>  Output vector of vectors with indices of the decomposition nodes.
</dl></p><p>
This function finds plain connectivity components of the induced subgraph and fills in the decomposition output argument accordingly.
</p>


<hr><h4><a name="declCGraph_GetDConnectionList">GetDConnectionList</a></h4>
<p class="Blurb">Finds nodes d-connected to given node.</p><pre>

void CGraph::GetDConnectionList( int <EM CLASS="CodeItalic">node</EM>, intVector const &amp;<EM CLASS="CodeItalic">separator</EM>, intVector <EM CLASS="CodeItalic">*dseparationList</EM> ) const;
</pre><p><dl>
 Arguments
<dt>node  <dd>Given node.
<dt>separator<dd>  Separator for <EM CLASS="CodeItalic">
d</EM>
-separation.
<dt>dseparationList<dd>  Output vector of indices of nodes.
</dl></p><p>
This function finds nodes d-connected to the given node by the given separator. The definition of the d-connection runs as in [CDLS]
</p>


<hr><h4><a name="declCGraph_GetDConnectionTable">GetDConnectionTable</a></h4>
<p class="Blurb">Finds d-connection lists for all nodes of graph.</p><pre>

void CGraph::GetDConnectionTable( intVector const &amp;<EM CLASS="CodeItalic">separator</EM>, intVecVector <EM CLASS="CodeItalic">*dseparationTable</EM> ) const;
</pre><p><dl>
 Arguments
<dt>separator<dd>  Separator for d-separation.
<dt>dseparationTable<dd>  Output vector of vectors of indices of nodes.
</dl></p><p>
Finds d-connection lists for all nodes of the graph. The definition for the d-connection runs as in [CDLS].
</p>


<hr><h4><a name="declCGraph_GetReachableSubgraph">GetReachableSubgraph</a></h4>
<p class="Blurb">Finds nodes reachable from given subgraph if certain pairs of edges are banned.</p><pre>

void CGraph::GetReachableSubgraph( intVector const &amp;<EM CLASS="CodeItalic">subgraph</EM>, bool <EM CLASS="CodeItalic">*ban[]</EM>, intVector <EM CLASS="CodeItalic">*closure</EM> ) const;
void CGraph::GetReachableSubgraph( int <EM CLASS="CodeItalic">node</EM>, bool *<EM CLASS="CodeItalic">ban</EM>[], intVector *<EM CLASS="CodeItalic">closure</EM> ) const;
</pre><p><dl>
 Arguments
<dt>subgraph<dd>  Given subgraph.
<dt>ban<dd>  Three-dimensional boolean mask.
<dt>closure<dd>  Output vector of indices of nodes.
</dl></p>



<hr><h3><a name="declClassCDAG">Class CDAG</a></h3>

<IMG SRC="fig/PNLMarch.book-95.gif">

<p>
Class <EM CLASS="CodeReg">CDAG</EM> represents the structure of a DAG, with its ancestor matrix being a variable of
the class.
</p>




<hr><h4><a name="declCDAG_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CDAG* CDAG::Create( int <EM CLASS="CodeItalic">numOfNds</EM>, const int *<EM CLASS="CodeItalic">numOfNbrsIn</EM>,const int *const *<EM CLASS="CodeItalic">nbrsListIn</EM>, const ENeighborType *const *<EM CLASS="CodeItalic">nbrsTypesIn </EM>);
static CDAG* CDAG::Create( int <EM CLASS="CodeItalic">numOfNds</EM>, const int *const *<EM CLASS="CodeItalic">adjMatIn</EM> );
static CDAG* CDAG::Create(const CMatrix&lt;int&gt;* <EM CLASS="CodeItalic">pAdjMat</EM>);
static CDAG* CDAG::Create(const CGraph&amp; <EM CLASS="CodeItalic">pGraph</EM>);
</pre><p><dl>
 Arguments
<dt>numOfNds  <dd>Number of nodes of the DAG.
<dt>numOfNbrsIn<dd>  Array of integer, each ith integer is the number of neighbors of the ith nodes.
<dt>nbrsListIn<dd>  List of neighbors for a node.
<dt>nbrsTypesIn<dd>  2D list of neighbor types. Each element shows the type of the corresponding neighbor from <EM CLASS="CodeItalic">nbrsListIn</EM>.
<dt>adjMatIn<dd>  2D array of integers, represents an adjacent matrix.
<dt>pAdjMat<dd>  2D integer matrix, represents an adjacent matrix.
<dt>pGraph<dd>  Reference to a <EM CLASS="CodeReg">CGraph</EM> instance.
</dl></p><p>
This function creates a <EM CLASS="CodeReg">CDAG</EM> object.
</p>


<hr><h4><a name="declCDAG_Change">Change</a></h4>
<p class="Blurb">Changes <EM CLASS="CodeReg">DAG</EM>  object.</p><pre>

CDAG* CDAG::Change(int <EM CLASS="CodeItalic">iStartNode</EM>, int <EM CLASS="CodeItalic">iEndNode</EM>, EDAGChangeType <EM CLASS="CodeItalic">iChangeType</EM>);
</pre><p><dl>
 Arguments
<dt>iStartNode<dd>  ID of the node from which the directed edge comes.
<dt>iEndNode<dd>  ID of the node at which the directed edge points.
<dt>iChangeType<dd>  One of three operations: addition, deletion or reversing of the direction of the edge.
</dl></p><p>
This function allows to add, to delete or to reverse an edge of a <EM CLASS="CodeReg">
DAG</EM> object. The function returns <EM CLASS="CodeItalic">NULL </EM>if the change did not occur, otherwise returns the new <EM CLASS="CodeReg">
CDAG</EM> object.
</p>


<hr><h4><a name="declCDAG_ClearContent">ClearContent</a></h4>
<p class="Blurb">Deletes ancestor matrix of <EM CLASS="CodeReg">DAG.</EM></p><pre>

void CDAG::ClearContent();
</pre><p>
This function deletes the ancestor matrix of the <EM CLASS="CodeReg">DAG</EM> object.
</p>


<hr><h4><a name="declCDAG_Clone">Clone</a></h4>
<p class="Blurb">Creates replica of <EM CLASS="CodeReg">DAG.</EM></p><pre>

CDAG* CDAG::Clone();
</pre><p>
This function copies the <EM CLASS="CodeReg">DAG</EM> object and thus creates its replica.
</p>


<hr><h4><a name="declCDAG_CreateAncestorMatrix">CreateAncestorMatrix</a></h4>
<p class="Blurb">Creates ancestor matrix for <EM CLASS="CodeReg">DAG</EM></p><pre>

void CDAG::CreateAncestorMatrix();
</pre><p>
This function creates the ancestor matrix for a <EM CLASS="CodeReg">DAG</EM> object.
</p>


<hr><h4><a name="declCDAG_CreateMinimalSpanningTree">CreateMinimalSpanningTree</a></h4>
<p class="Blurb">Creates minimal spanning tree for given weight matrices.</p><pre>

CDAG* CDAG::CreateMinimalSpanningTree(const CMatrix&lt;float&gt;* <EM CLASS="CodeItalic">pWeightMatrix</EM>, const CMatrix&lt;float&gt;* <EM CLASS="CodeItalic">pWeightMatrix2</EM>);
</pre><p><dl>
 Arguments
<dt>pWeightMatrix<dd>  N*N 2D weight matrix, the primary weight. Element <EM CLASS="CodeItalic">
[i,j]</EM> connects node <EM CLASS="CodeItalic">i </EM>to node <EM CLASS="CodeItalic">j</EM>.
<dt>pWeightMatrix2<dd>  N*N 2D weight matrix, the secondary weight.
</dl></p><p>
This function creates a <EM CLASS="CodeReg">CDAG</EM> instance for the minimal spanning tree.
</p>


<hr><h4><a name="declCDAG_DoMove">DoMove</a></h4>
<p class="Blurb">Changes <EM CLASS="CodeReg">DAG  object.</EM></p><pre>

bool CDAG::DoMove( int <EM CLASS="CodeItalic">iStartNode</EM>, int <EM CLASS="CodeItalic">iEndNode</EM>, EDAGChangeType <EM CLASS="CodeItalic">iChangeType </EM>);
</pre><p><dl>
 Arguments
<dt>iStartNode<dd>  ID of the node from which the directed edge comes.
<dt>iEndNode<dd>  ID of the node at which the directed edge points.
<dt>iChangeType<dd>  One of three operations: addition, deletion or reversing of the direction of the edge.
</dl></p><p>
This function changes the DAG object by addition, deletion or reversing of an object edge. This function returns `true' when the change of the <EM CLASS="CodeReg">DAG </EM>object was permitted and the object was changed, returns `false' otherwise.
</p>


<hr><h4><a name="declCDAG_GetAllEdges">GetAllEdges</a></h4>
<p class="Blurb">Gets all edges of <EM CLASS="CodeReg">DAG </EM>object.</p><pre>

void CDAG::GetAllEdges( EDGEVECTOR* <EM CLASS="CodeItalic">pvOutput </EM>);
</pre><p><dl>
 Arguments
<dt>pvOutput<dd>   <EM CLASS="CodeItalic">EDGE</EM> vector which is used to store all the edges of the <EM CLASS="CodeReg">DAG</EM>.
</dl></p><p>
This function gets all the edges of the <EM CLASS="CodeReg">DAG</EM>.<EM CLASS="CodeItalic"> EDGE</EM> is a data structure which contains two integers: node ID from which the edge comes and node ID at which the edge points.
</p>


<hr><h4><a name="declCDAG_GetAllNeighbours">GetAllNeighbours</a></h4>
<p class="Blurb">Generates all valid neighbours for <EM CLASS="CodeReg">DAG</EM>object.</p><pre>

void CDAG::GetAllNeighbours( POINTVECTOR &amp;<EM CLASS="CodeItalic">vNeighbours</EM>, EDGEOPVECTOR &amp;<EM CLASS="CodeItalic">vOPs</EM>,
 bool (*IsValid)(CDAG* <EM CLASS="CodeReg">pDAG</EM>) );
</pre><p><dl>
 Arguments
<dt>vNeighbors<dd>  Vector of void* which stores all valid neighbors of the <EM CLASS="CodeReg">DAG </EM>object.
<dt>vOPs<dd>  <EM CLASS="CodeItalic">EDGEOP</EM> vector which stores all valid changes to the <EM CLASS="CodeReg">DAG </EM>object.
<dt>pDAG <dd><EM CLASS="CodeReg"></EM><EM CLASS="CodeItalic">)</EM>  External function called to check if a <EM CLASS="CodeReg">DAG</EM> is valid.
</dl></p><p>
This function generates all neighbor <EM CLASS="CodeReg">DAG</EM>s of the given class object that satisfy the conditions of the <EM CLASS="CodeReg">IsValid</EM> function.
</p>


<hr><h4><a name="declCDAG_GetAllValidMove">GetAllValidMove</a></h4>
<p class="Blurb">Generates all valid moves for DAG.</p><pre>

void CDAG::GetAllValidMove(EDGEOPVECTOR *<EM CLASS="CodeItalic">pvOutput</EM>, intVector*<EM CLASS="CodeItalic">pvAncesstorVector</EM>, intVector* <EM CLASS="CodeItalic">pvDescendantsVector</EM>, intVector* <EM CLASS="CodeItalic">pvNotParents</EM>, intVector* <EM CLASS="CodeItalic">pvNotChild</EM>) );
</pre><p><dl>
 Arguments
<dt>pvOutput<dd>  EDGEOP vector. Stores all valid changes to the DAG.
<dt>pvAncesstorVector <dd>Integer vector.
<dt>pvDescendantsVector <dd>Integer vector.
<dt>pvNotParent <dd>Integer vector.
<dt>pvNotChild  <dd>Integer vector.
</dl></p><p>
This function generates all valid moves for the <EM CLASS="CodeReg">
DAG</EM>. This function is carried out under the condition that the <EM CLASS="CodeItalic">
pvDescendantsVector</EM> nodes of a generated <EM CLASS="CodeReg">DAG</EM> are not ancestors of <EM CLASS="CodeItalic">pvAncesstorVector </EM>nodes and that <EM CLASS="CodeItalic">pvNotParent </EM>nodes are not ancestors of <EM CLASS="CodeItalic">pvNotChild </EM>nodes.
</p>


<hr><h4><a name="declCDAG_GetEdgeDirect">GetEdgeDirect</a></h4>
<p class="Blurb">Gets direction of edge.</p><pre>

int CDAG::GetEdgeDirect(int <EM CLASS="CodeItalic">startNode</EM>, int <EM CLASS="CodeItalic">endNode</EM>);
</pre><p><dl>
 Arguments
<dt>startNode<dd>  Node ID from which the edge comes.
<dt>EndNode<dd>  Node ID at which the edge points.
</dl></p><p>
This function learns the direction of the edge. The function returns<BR>1 if the edge is directed from <EM CLASS="CodeItalic">startNode</EM> to <EM CLASS="CodeItalic">
EndNode<BR></EM>
-1  if the edge is directed from <EM CLASS="CodeItalic">EndNode </EM>to <EM CLASS="CodeItalic">startNode<BR></EM>
0   if there is no edge between the two nodes.
</p>


<hr><h4><a name="decl_pnlGetMaxFanIn">GetMaxFanIn</a></h4>
<p class="Blurb">Computes MaxFanIn for <EM CLASS="CodeReg">DAG</EM> and returns it to object.</p><pre>
int CDAG::GetMaxFanIn();
</pre>


<hr><h4><a name="declCDAG_GetSubDAG">GetSubDAG</a></h4>
<p class="Blurb">Gets part of <EM CLASS="CodeReg">DAG</EM></p><pre>

CDAG* CDAG::GetSubDAG( intVector &amp;<EM CLASS="CodeItalic">vSubNodesSet </EM>);
</pre><p><dl>
 Arguments
<dt>vSubNodesSet<dd>  Integer vector which stores the node IDs that are to be extracted from the <EM CLASS="CodeReg">DAG</EM>.
</dl></p>


<hr><h4><a name="declCDAG_IsEquivalent">IsEquivalent</a></h4>
<p class="Blurb">Compares two <EM CLASS="CodeReg">DAGs.</EM></p><pre>

bool CDAG::IsEquivalent( CDAG *<EM CLASS="CodeItalic">pDAG </EM>);
</pre><p><dl>
 Arguments
<dt>pDAG<dd> instance compared to the given <EM CLASS="CodeReg">
DAG</EM>.
</dl></p><p>
This function compares two objects of the class. The function returns `true' if the <EM CLASS="CodeReg">
DAGs</EM> are identical, returns `false' otherwise.
</p>


<hr><h4><a name="declCDAG_IsValidMove">IsValidMove</a></h4>
<p class="Blurb">Checks if move generates non-<EM CLASS="CodeReg">DAG </EM>object.</p><pre>

bool CDAG::IsValidMove(int <EM CLASS="CodeItalic">iStartNode</EM>, int <EM CLASS="CodeItalic">iEndNode</EM>, EDAGChangeType <EM CLASS="CodeItalic">iChangeType</EM>);
</pre><p><dl>
 Arguments
<dt>iStartNode<dd>  Start node ID of the move.
<dt>iEndNode<dd>  End node ID of the move.
<dt>iChangType<dd>  One of the following operations: <EM CLASS="CodeItalic">add</EM>, <EM CLASS="CodeItalic">delete</EM>, <EM CLASS="CodeItalic">reverse.</EM>
</dl></p><p>
This function checks if the move can generate a non-<EM CLASS="CodeReg">DAG</EM> object. The function returns `true' if the move generates a <EM CLASS="CodeReg">
DAG</EM>, returns `false' if the move generates a non-<EM CLASS="CodeReg">DAG</EM>.
</p>


<hr><h4><a name="declCDAG_MarkovBlanket">MarkovBlanket</a></h4>
<p class="Blurb">Computes Markov Blanket for node.</p><pre>

void CDAG::MarkovBlanket(int <EM CLASS="CodeItalic">nNodeNumber</EM>, intVector *<EM CLASS="CodeItalic">pvOutPut</EM>);
</pre><p><dl>
 Arguments
<dt>nNodeNumber<dd>  Node ID for which Markov Blanket is to be computed.
<dt>pvOutPut<dd>  Pointer to the integer vector which stores the computed Markov Blanket.
</dl></p><p>
This function computes the Markov Blanket for a node.
</p>


<hr><h4><a name="declCDAG_RandomCreateADAG">RandomCreateADAG</a></h4>
<p class="Blurb">Creates random <EM CLASS="CodeReg">DAG.</EM></p><pre>

CDAG* CDAG::RandomCreateADAG(int <EM CLASS="CodeItalic">iNodeNumber</EM>, const intVector &amp;<EM CLASS="CodeItalic">vAncesstor</EM>, const intVector &amp;<EM CLASS="CodeItalic">vDescendants</EM>, intVector* <EM CLASS="CodeItalic">pvNotParent</EM>, intVector* <EM CLASS="CodeItalic">pvNotChild</EM>);
</pre><p><dl>
 Arguments
<dt>iNodeNumber<dd>  Number of nodes in generated DAG.
<dt>vAncesstor<dd>, <EM CLASS="CodeItalic">
<dt>vDescendants<dd>  </EM>
Integer vectors.Make sure that among <EM CLASS="CodeItalic">
vDescendants</EM> nodes of the generated <EM CLASS="CodeReg">DAG</EM> there are no ancestors of <EM CLASS="CodeItalic">vAncestor</EM> nodes.
<dt>pvNotParent<dd>, <EM CLASS="CodeItalic">pvNotChild  </EM>Integer vectors. Make sure that among <EM CLASS="CodeItalic">pvNotParent</EM> nodes of the generated <EM CLASS="CodeReg">DAG</EM> there are no ancestors of <EM CLASS="CodeItalic">pvNotChild</EM> nodes.
</dl></p>


<hr><h4><a name="declCDAG_SetSubDag">SetSubDag</a></h4>
<p class="Blurb">Replaces part of <EM CLASS="CodeReg">DAG</EM> by input sub-<EM CLASS="CodeReg">DAG</EM></p><pre>

bool CDAG::SetSubDag(intVector &amp;<EM CLASS="CodeItalic">vSubNodeSet</EM>, CDAG *<EM CLASS="CodeItalic">pSubDAG</EM>);
</pre><p><dl>
 Arguments
<dt>vSubNodeSet<dd>  Integer vector. Stores node IDs that are to be modified.
<dt>pSubDAG<dd>  <EM CLASS="CodeReg">DAG</EM> that is to replace a part of the given <EM CLASS="CodeReg">DAG</EM>.
</dl></p><p>
This function replaces a part of the given <EM CLASS="CodeReg">
DAG</EM> by a sub-<EM CLASS="CodeReg">DAG.</EM>The function returns `true' if the replacement has been successful, otherwise returns `false'.
</p>


<hr><h4><a name="declCDAG_SymmetricDifference">SymmetricDifference</a></h4>
<p class="Blurb">Compares structures of two <EM CLASS="CodeReg">DAGs.</EM></p><pre>

 int CDAG::SymmetricDifference(const CDAG* pDAG) const;
</pre><p><dl>
 Arguments
<dt>pDAG  <dd>Pointer to a <EM CLASS="CodeReg">
DAG</EM>
 to be compared with the given <EM CLASS="CodeReg">
DAG</EM>.
</dl></p><p>
This function compares structures of two class objects.
</p>


<hr><h4><a name="declCDAG_TopologicalCreateDAG">TopologicalCreateDAG</a></h4>
<p class="Blurb">Creates replica <EM CLASS="CodeReg">DAG</EM>.</p><pre>

CDAG* CDAG::TopologicalCreateDAG( intVector&amp; <EM CLASS="CodeItalic">vNodesMap </EM>);
</pre><p><dl>
 Arguments
<dt>vNodesMap<dd>  Integer vector. Preserves the map of the node ID of the given <EM CLASS="CodeReg">DAG</EM>
 for new node IDs. As a result, the node of the newly created <EM CLASS="CodeReg">DAG</EM> corresponds to the node <EM CLASS="CodeItalic">vNodesMap</EM>[i] of the given <EM CLASS="CodeReg">DAG</EM>.
</dl></p><p>
This function creates a replica of the given <EM CLASS="CodeReg">DAG</EM>. Node ID of the new <EM CLASS="CodeReg">DAG</EM> is provided by the input integer vector.
</p>


<hr><h4><a name="declCDAG_TopologicalSort">TopologicalSort</a></h4>
<p class="Blurb">Sorts nodes of <EM CLASS="CodeReg">DAG</EM> topologically.</p><pre>

bool CDAG::TopologicalSort( intVector* <EM CLASS="CodeItalic">pvOutput </EM>);
</pre><p><dl>
 Arguments
<dt>pvOutput<dd>  Integer vector. Preserves the map of the node ID of the given <EM CLASS="CodeReg">
DAG</EM> for new node IDs. As a result the<EM CLASS="CodeItalic"></EM>node of the newly created <EM CLASS="CodeReg">DAG</EM> corresponds to the node <EM CLASS="CodeItalic">pvOutput[i] </EM>of the given <EM CLASS="CodeReg">DAG</EM>.
</dl></p><p>
This function classifies a <EM CLASS="CodeReg">DAG</EM> object according to its topological order.
</p>


<hr><h2><a name="decl_pnlNode_Types">Node Types</a></h2>

<hr><h3><a name="decl_pnlClassCNode_Types">Class CNodeType</a></h3>

<IMG SRC="fig/PNLMarch.book-98.gif">

<p>
Class <EM CLASS="CodeReg">CNodeType</EM> represents node types for the model. By default model nodes are
binary and discrete.
</p>


<hr><h4><a name="declCNodeType_IsDiscrete">IsDiscrete</a></h4>
<p class="Blurb">Returns information on node discreteness.</p><pre>

inline int CNodeType::IsDiscrete() const;
</pre><p>
This function returns 1 if the node is discrete, returns 0 otherwise.
</p>


<hr><h4><a name="declCNodeType_GetNodeSize">GetNodeSize</a></h4>
<p class="Blurb">Returns node size.</p><pre>

inline int CNodeType::GetNodeSize() const;
</pre>


<hr><h4><a name="declCNodeType_SetType">SetType</a></h4>
<p class="Blurb">Sets node type.</p><pre>

inline void CNodeType::SetType( bool <EM CLASS="CodeItalic">isDiscrete</EM>, int <EM CLASS="CodeItalic">ndSize</EM> );
</pre><p><dl>
 Arguments
<dt>isDiscrete<dd>  Type of node value. Equals to <EM CLASS="CodeItalic">
true</EM>
 if the node is discrete, equals to <EM CLASS="CodeItalic">
false</EM>
 if the node is continuous.
<dt>ndSize<dd>  New node size.
</dl></p><p>
This function sets the type of the given node.
</p>


<hr><h4><a name="decl_pnloperator==">operator==</a></h4>
<p class="Blurb">Compares operands.</p><pre>

inline bool operator==( const CNodeType &amp;<EM CLASS="CodeItalic">ntIn </EM>) const;
</pre><p><dl>
 Arguments
<dt>ntIn  <dd>CNodeType object.
</dl></p><p>
This function compares two operands. Returns `true' if the operands are equal, returns `false' otherwise.
</p>


<hr><h4><a name="decl_pnloperator!=">operator!=</a></h4>
<p class="Blurb">Compares two operands.</p><pre>

inline bool operator!=( const CNodeType &amp;<EM CLASS="CodeItalic">ntIn </EM>) const;
</pre><p><dl>
 Arguments
<dt>ntIn  <dd>CNodeType object.
</dl></p><p>
This function compares two operands. The function returns `true' if the operands are  not equal; returns `false' otherwise.
</p>


<hr><h4><a name="decl_pnlModel_Domain">Model Domain</a></h4>


<p>
Model domain is a set of nodes that define a graphical model. Multiple graphical
models can have one model domain. This object keeps all information about the types
of variables, or nodes. For example, you can create a new graphical model using the
description of model variables from the model domain.
</p>



<hr><h4><a name="decl_pnlClassCModel_Domain">Class CModelDomain</a></h4>

<IMG SRC="fig/PNLMarch.book-99.gif">


<p>
<A NAME="pgfId-52970"></A>This class contains information on the variable types of all nodes to be used for creating a graphical model, as well as on the node types for nodes to become observed on entering evidence during inference. A graphical model keeps the pointer to the <EM CLASS="CodeReg">CModelDomain</EM> on which it was created and learns from it the  information on node types. </p>
<p>
This class also stores temporary <EM CLASS="CodeReg">CFactor</EM> objects that are not attached to any graphical model. Such objects appear during inference and learning  procedures. When the <EM CLASS="CodeReg">CModelDomain</EM> is destroyed they are deleated form it automatically.</p>
<p>
This class is derived from the <EM CLASS="CodeReg">CReferenceCounter</EM> class. It keeps pointers to <EM CLASS="CodeReg">CGraphicalModels</EM> that are based on the <EM CLASS="CodeReg">CModelDomain</EM>. The class cannot be deleted until any Graphical Model referres to it.</p>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CModelDomain* CModelDomain::Create( const nodeTypeVector&amp; <EM CLASS="CodeItalic">variableTypes</EM>, const intVector&amp; <EM CLASS="CodeItalic">variableAssociation</EM>, CGraphicalModel* <EM CLASS="CodeItalic">pCreaterOfMD</EM> = NULL );
static CModelDomain* CModelDomain::Create(int <EM CLASS="CodeItalic">numVariables</EM>, const CNodeType&amp; <EM CLASS="CodeItalic">commonVariableType</EM> = CNodeType(1,2), CGraphicalModel* <EM CLASS="CodeItalic">pCreaterOfMD</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>variableTypes <dd>Vector of different node types.
<dt>variableAssociation <dd>Vector of variable association with the variable types.
<dt>pCreatorOfMD  <dd>Pointer to the graphical model which creates a model domain.
<dt>numVariables  <dd>Number of variables in the model domain.
<dt>CommonVariableType  <dd>Variable type.
</dl></p><p>
Two function versions are available.The first creates a model domain with different variable types, the association for every node pointing at a node type.The second creates a model domain with all variables of the same type.
</p>


<hr><h4><a name="decl_pnlAttachFactor">AttachFactor</a></h4>
<p class="Blurb">Attaches factor to model domain.</p><pre>

</pre><p><dl>
 Arguments
<dt>pFactor<dd>  Pointer to the factor to be attached.
</dl></p><p>
Returns the number of this factor in array of pointers to the factors on the model domain.
</p>


<hr><h4><a name="declCModelDomain_ReleaseFactor">ReleaseFactor</a></h4>
<p class="Blurb">Releases attached factors from model domain.</p><pre>

void CModelDomain::ReleaseFactor( const CFactor *<EM CLASS="CodeItalic">pFactor </EM>);
</pre><p><dl>
 Arguments
<dt>pFactor <dd>Pointer to the factor which is to be released from the model domain.
</dl></p>


<hr><h4><a name="declCModelDomain_IsAFactorOwner">IsAFactorOwner</a></h4>
<p class="Blurb">Checks if model domain keeps pointer to query factor.</p><pre>

bool CModelDomain::IsAFactorOwner( const CFactor *pFactor );
</pre><dl><p>
 Arguments
<dt>pFactor <dd>Pointer to the factor which is to be released from the model domain.
</dl></p><p>
The function returns the value of 1 if the model domain keeps a pointer to the query factor, that is, if the model domain is the owner of the query factor. Otherwise, returns 0.
</p>


<hr><h4><a name="declCModelDomain_GetVariableType">GetVariableType</a></h4>
<p class="Blurb">Returns pointer to node type of query variable. </p><pre>

const CNodeType* CModelDomain::GetVariableType( int <EM CLASS="CodeItalic">varNumber </EM>) const;
</pre><p><dl>
 Arguments
<dt>Frumpier  <dd>Number of variables.
</dl></p>


<hr><h4><a name="declCModelDomain_GetVariableTypes">GetVariableTypes</a></h4>
<p class="Blurb">Returns variable types for query variables.</p><pre>

void CModelDomain::GetVariableTypes( intVector&amp; <EM CLASS="CodeItalic">vars</EM>, pConstNodeTypeVector* <EM CLASS="CodeItalic">varTypes</EM> ) const;
</pre><p><dl>
 Arguments
<dt>vars  <dd>Vector of number of variables.
<EM CLASS="CodeItalic">varTypes  </EM>varTypes  </EM>Returned parameter. Types of variables.
Returned parameter. Types of variables.
</dl></p><p>
This function fills in the input vector <EM CLASS="CodeItalic">varTypes</EM> by const pointers to variable types.
</p>


<hr><h4><a name="declCModelDomain_GetObsGauVarType">GetObsGauVarType</a></h4>
<p class="Blurb">Returns pointer to observed Gaussian variable type.</p><pre>

inline const CNodeType* CModelDomain::GetObsGauVarType() const;
</pre><p>
This function returns a pointer to the observed Gaussian variable type.
</p>


<hr><h4><a name="declCModelDomain_GetObsTabVarType">GetObsTabVarType</a></h4>
<p class="Blurb">Returns pointer to observed Tabular variable type.</p><pre>

inline const CNodeType* CModelDomain::GetObsTabVarType() const;
</pre><p>
This function returns the pointer to the observed Tabular variable type.
</p>


<hr><h4><a name="declCModelDomain_GetNumberOfVariableTypes">GetNumberOfVariableTypes</a></h4>
<p class="Blurb">Returns number of different variable types.</p><pre>

inline int CModelDomain::GetNumberOfVariableTypes() const;
</pre><p>
This function returns a number of different variable types.
</p>


<hr><h4><a name="declCModelDomain_GetVariableTypes">GetVariableTypes</a></h4>
<p class="Blurb">Returns all variable types. </p><pre>

void CModelDomain::GetVariableTypes( pConstNodeTypeVector* <EM CLASS="CodeItalic">varTypes</EM> )const;
void CModelDomain::GetVariableTypes( nodeTypeVector* <EM CLASS="CodeItalic">varTypes</EM> )const;
</pre><p><dl>
 Arguments
<dt>varTypes<dd>  Returned parameter. Vector of node types.
</dl></p><p>
The function is available in two versions.
</p>


<hr><h4><a name="declCModelDomain_GetNumberVariables">GetNumberVariables</a></h4>
<p class="Blurb">Returns number of variables of model domain.</p><pre>

inline int CModelDomain::GetNumberVariables() const;
</pre><p>
This function returns number of variables of the model domain.
</p>


<hr><h4><a name="declCModelDomain_GetVariableAssociations">GetVariableAssociations</a></h4>
<p class="Blurb">Returns association to variable types.</p><pre>

void CModelDomain::GetVariableAssociations( intVector* <EM CLASS="CodeItalic">variableAssociation </EM>) const;
inline const int* CModelDomain::GetVariableAssociations()const;
</pre><p><dl>
 Arguments
<dt>variableAssociation<dd>  Returned parameter. Vector of associations of variables to variable types.
</dl></p><p>
The function is available in two versions.The first adopts and fills the vector, the second returns the pointer to the association.
</p>


<hr><h4><a name="declCModelDomain_GetVariableAssociation">GetVariableAssociation</a></h4>
<p class="Blurb">Returns variable association.</p><pre>

inline int CModelDomain::GetVariableAssociation(int <EM CLASS="CodeItalic">variable</EM>)const;
</pre><p><dl>
 Arguments
<dt>variable  <dd>Number of a variable in the model domain.
</dl></p>


<hr><h2><a name="decl_pnlEvidences">Evidences</a></h2>



<hr><h3><a name="decl_pnlClassCNodeValues">Class CNodeValues</a></h3>


<IMG SRC="fig/PNLMarch.book-100.gif">

<p>
Class <EM CLASS="CodeReg">CNodeValues</EM> is intended for storing values of variables. Values of discrete nodes are represented by integers, while values of continuous nodes - by n floats, where n is <EM CLASS="CodeItalic">NodeSize</EM> of a corresponding node type.
</p>
<p>
A node can be observed either potentially or actually.
</p>
<p>
When a node is potentially observed, it can be observed and its observed value is at <EM CLASS="CodeReg">CNodeValues</EM> object, but the node is not actually observed. To make it actually observed, the corresponding observability flag needs to be changed to <EM CLASS="CodeItalic">true</EM> value.
</p>
<p>
Creation of evidences for the model is simplified in this way. The user can create evidence for all nodes, set observability flag for some of them to <EM CLASS="CodeItalic">false</EM>, and start inference with such evidence. To start inference with other observed nodes, the user can just toggle node observability states for some of them.
</p>
<p>
CNodeValues</EM> is basic for<EM CLASS="CodeReg"><a href="#decl_pnlModel_Domain">Model Domain</A></EM> and contains information about observed values of certain variables without indicating the numbers of these variables in the graphical model.<EM CLASS="CodeReg"><a href="#decl_pnlModel_Domain">Model Domain</A></EM> contains information on correspondence between the variables and the graphical model nodes.
</p>
<p>
Public destructor <EM CLASS="CodeReg">&#126;CNodeValues()</EM> deletes an object of the class.
</p>



<hr><h4><a name="declCNodeValues_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CNodeValues* CNodeValues::Create( int <EM CLASS="CodeItalic">nObsNds</EM>, const CNodeType* const* <EM CLASS="CodeItalic">obsNdsTypes</EM>, const valueVector&amp; <EM CLASS="CodeItalic">obsValues</EM> );
static CNodeValues* CNodeValues::Create( const pConstNodeTypeVector&amp; <EM CLASS="CodeItalic">obsNdsTypes</EM>, const valueVector&amp; <EM CLASS="CodeItalic">obsValues</EM> );
</pre><p><dl>
 Arguments
<dt>nObsNds <dd>Number of the observed nodes.
<dt>obsNdsTypes<dd>  Node types of observed nodes.
<dt>obsValues<dd>  Values of the observed nodes.
</dl></p><p>
This function returns objects of class <EM CLASS="CodeReg">CNodeValues</EM>. All nodes of any created object are actually observed.
</p>


<hr><h4><a name="declCNodeValues_GetValueBySerialNumber">GetValueBySerialNumber</a></h4>
<p class="Blurb">Returns pointer to value.</p><pre>

inline Value const* CNodeValues::GetValueBySerialNumber( int <EM CLASS="CodeItalic">SerialNumber</EM> ) const;
inline Value* CNodeValues::GetValueBySerialNumber( int <EM CLASS="CodeItalic">SerialNumber</EM> );
</pre><p><dl>
 Arguments
<dt>SerialNumber  <dd>Serial number of the observed variable.
</dl></p><p>
Both the functions return pointer to the value of the observed node. The <EM CLASS="CodeReg">const</EM> function solely provides observation of the observed node value. The <EM CLASS="CodeReg">non-const</EM> function enables user to change the value of the observed node in accordance with the returned pointer.
</p>


<hr><h4><a name="declCNodeValues_GetNumberObsNodes">GetNumberObsNodes</a></h4>
<p class="Blurb">Returns total number of observed nodes.</p><pre>

int CNodeValues::GetNumberObsNodes() const;
</pre><p>
This function returns the total number of both potentially and actually observed nodes.
</p>


<hr><h4><a name="declCNodeValues_GetObsNodesFlags">GetObsNodesFlags</a></h4>
<p class="Blurb">Returns pointer to array of observability flags.</p><pre>

const int * CNodeValues::GetObsNodesFlags() const;
</pre><p>
This function returns constant pointer to the array of observability flags for nodes of <EM CLASS="CodeReg">
CNodeValues</EM>
 class objects.
</p>


<hr><h4><a name="declCNodeValues_GetRawData">GetRawData</a></h4>
<p class="Blurb">Returns array of values.</p><pre>

void CNodeValues::GetRawData( valueVector* <EM CLASS="CodeItalic">values </EM>) const;
</pre><p><dl>
 Arguments
<dt>values  <dd>Array of values.
</dl></p><p>
This function returns array of values.
</p>


<hr><h4><a name="declCNodeValues_GetOffset">GetOffset</a></h4>
<p class="Blurb">Returns offsets in array of observed nodes.</p><pre>

const int * CNodeValues::GetOffset() const;
</pre><p>
This function returns the pointer to the array of offsets in the array of the values of observed variables. When the value of<EM CLASS="CodeItalic"> i</EM><EM CLASS="Superscript">th</EM> node needs to be found, the array of raw data should be addressed with the offset corresponding to the <EM CLASS="CodeItalic">i</EM>
<EM CLASS="Superscript">th</EM> value in the array of the offsets.
</p>


<hr><h4><a name="declCNodeValues_SetData">SetData</a></h4>
<p class="Blurb">Replaces old values with new values.</p><pre>

void CNodeValues::SetData( const valueVector&amp; <EM CLASS="CodeItalic">data</EM> );
</pre><p><dl>
 Arguments
<dt>data  <dd>Array of new values.
</dl></p>


<hr><h4><a name="declCNodeValues_GetNodeTypes">GetNodeTypes</a></h4>
<p class="Blurb">Returns array of pointers to node types.</p><pre>

const CNodeType *const* CNodeValues::GetNodeTypes() const;
</pre><p>
This function returns pointer to the array of pointers to<EM CLASS="CodeReg"> CNodeType</EM> class objects corresponding to the node types of observed variables.
</p>


<hr><h4><a name="declCNodeValues_MakeNodeHiddenBySerialNum">MakeNodeHiddenBySerialNum</a></h4>
<p class="Blurb">Changes observation flag from actually observed to hidden.</p><pre>

inline void CNodeValues::MakeNodeHiddenBySerialNum( int <EM CLASS="CodeItalic">serialNum</EM> );
</pre><p><dl>
 Arguments
<dt>serialNum <dd>Number of an observed node, the state of which is to be changed.
</dl></p>


<hr><h4><a name="declCNodeValues_MakeNodeObservednBySerialNum">MakeNodeObservednBySerialNum</a></h4>
<p class="Blurb">Changes observation flag from hidden to actually observed.</p><pre>

inline void CNodeValues::MakeNodeObservednBySerialNum( int <EM CLASS="CodeItalic">serialNum</EM> );
</pre><p><dl>
 Arguments
<dt>serialNum <dd>Number of a hidden node, the state of which is to be changed.
</dl></p>


<hr><h4><a name="declCNodeValues_ToggleNodeStateBySerialNumber">ToggleNodeStateBySerialNumber</a></h4>
<p class="Blurb">Toggles observability type.</p><pre>

void CNodeValues::ToggleNodeStateBySerialNumber( int <EM CLASS="CodeItalic">numOfNds</EM>, int *<EM CLASS="CodeItalic">nodeNums</EM> );
void CNodeValues::ToggleNodeStateBySerialNumber( const intVector&amp; <EM CLASS="CodeItalic">nodeNums</EM> );
</pre><p><dl>
 Arguments
<dt>numOfNds  <dd>Number of the nodes that require change of the state.
<dt>nodeNums  <dd>Serial numbers of the observed variables that require change of state.
</dl></p><p>
This function changes the state of the variables from potentially observable to actually observable and vice versa.
</p>

<hr><h3><a name="decl_pnlClassCEvidence">Evidence</a></h3>


<IMG SRC="fig/PNLMarch.book-101.gif">

<p>
Class <EM CLASS="CodeReg">CEvidence</EM> contains information on observed variables of graphical model: what nodes are observed and what values are taken. Class <EM CLASS="CodeReg">CEvidence</EM> is based on <EM CLASS="CodeReg"><a href="#decl_pnlClassCNodeValues">Class CNodeValues</A></EM>, which contains information on types and actual values of certain variables. Class <EM CLASS="CodeReg">CEvidence</EM> proper stores the array of numbers of observed variables in a graphical model, along with methods of getting information about an observed node or a set of observed nodes in a model. All the methods consist in establishing correspondence between numbers of the model nodes and their serial numbers within a <EM CLASS="CodeReg">CNodeValues</EM>
 object, as well as in calling the corresponding member functions of that class.</p>




<hr><h4><a name="declCEvidence_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CEvidence* CEvidence::Create( const CModelDomain* <EM CLASS="CodeItalic">pMD</EM>,const intVector&amp; <EM CLASS="CodeItalic">obsNodes</EM>, const valueVector&amp; <EM CLASS="CodeItalic">obsValues</EM> );
static CEvidence* CEvidence::Create( const CNodeValues* <EM CLASS="CodeItalic">values</EM>,const intVector&amp; <EM CLASS="CodeItalic">obsNodes</EM>, const CModelDomain* <EM CLASS="CodeItalic">pMD</EM>,int <EM CLASS="CodeItalic">takeIntoObservationFlags</EM> = 0 );
static CEvidence* CEvidence::Create( const CGraphicalModel* <EM CLASS="CodeItalic">pGrModel</EM>,const intVector&amp; <EM CLASS="CodeItalic">obsNodes</EM>, const valueVector&amp; <EM CLASS="CodeItalic">obsValues</EM>);
static CEvidence* CEvidence::Create( const CModelDomain *<EM CLASS="CodeItalic">pMD</EM>, int <EM CLASS="CodeItalic">nObsNodes</EM>, const int *<EM CLASS="CodeItalic">obsNodes</EM>, const valueVector&amp; <EM CLASS="CodeItalic">obsValues</EM> );
static CEvidence* CEvidence::Create( const CGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM>, int <EM CLASS="CodeItalic">nObsNodes</EM>, const int *<EM CLASS="CodeItalic">obsNodes</EM>, const valueVector&amp; <EM CLASS="CodeItalic">obsValues</EM> );
static CEvidence* CEvidence::Create( const CNodeValues *<EM CLASS="CodeItalic">values</EM>,int <EM CLASS="CodeItalic">nObsNodes</EM>, const int *<EM CLASS="CodeItalic">obsNodes</EM>, const CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, int <EM CLASS="CodeItalic">takeIntoObservationFlags</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>pMD <dd>Pointer to the model domain.
<dt>pGrModel<dd>  Pointer to a graphical model.
<dt>nObsNds <dd>Number of the observed nodes or variables.
<dt>obsNodes<dd>  Array of observed nodes in the graphical model or observed variables it the model domain.
<dt>obsValues<dd>  Array of the observed values listed in the same order as in the array <EM CLASS="CodeItalic">
obsNodes</EM>.
<dt>takeIntoObservationFlags<dd>  Flag makes all nodes or variables actually observed if <EM CLASS="CodeItalic">
takeIntoObservationFlag</EM> = 0 or puts the same flags as in <EM CLASS="CodeItalic">pNodeValues</EM> object if <EM CLASS="CodeItalic">takeIntoObservationFlag</EM> = 1.
</dl></p><p>
This function creates a <EM CLASS="CodeReg">CEvidence</EM> object.
</p>


<hr><h4><a name="declCEvidence_ToggleNodeState">ToggleNodeState</a></h4>
<p class="Blurb">Toggles observability type.</p><pre>

void CEvidence::ToggleNodeState( int <EM CLASS="CodeItalic">numOfNds</EM>, int *<EM CLASS="CodeItalic">nodeNums</EM> );
void CEvidence::ToggleNodeState( const intVector&amp; <EM CLASS="CodeItalic">nodeNums</EM> );
</pre><p><dl>
 Arguments
<dt>numOfNds  <dd>Number of the nodes that require change of the state.
<dt>nodeNums  <dd>Numbers of the observed nodes that require change of the state.
</dl></p><p>
This function changes the state of the nodes from potentially observable to actually observable and vice versa.
</p>


<hr><h4><a name="declCEvidence_GetValue">GetValue</a></h4>
<p class="Blurb">Returns pointer to value of observed node.</p><pre>

const Value* CEvidence::GetValue( int <EM CLASS="CodeItalic">nodeNum</EM> ) const;
Value* CEvidence::GetValue( int <EM CLASS="CodeItalic">nodeNum</EM> );
</pre><p><dl>
 Arguments
<dt>nodeNum <dd>Serial number of the observed node in the model.
</dl></p><p>
Both the functions return pointer to the value of the observed node by its serial number in the graphical model. The <EM CLASS="CodeReg">const</EM>
 function solely provides observation of the observed node value. The <EM CLASS="CodeReg">non-const</EM> function enables you to change the value of the observed node in accordance with the returned pointer.
</p>


<hr><h4><a name="declCEvidence_GetAllObsNodes">GetAllObsNodes</a></h4>
<p class="Blurb">Returns pointer to array of numbers of observed nodes.</p><pre>

const int * CEvidence::GetAllObsNodes() const;
</pre><p>
This function returns pointer to the array of numbers of observed nodes. To get the number of observed nodes, use the function <EM CLASS="CodeReg">GetNumberObsNodes</EM> of basic CEvidence class.
</p>


<hr><h4><a name="decl_pnlIsNodeObserved">IsNodeObserved</a></h4>
<p class="Blurb">Returns current observability status of the node.</p><pre>

</pre><p><dl>
 Arguments
<dt>nodeNum <dd>Number of the node in the graphical model.
</dl></p><p>
This function returns 1, if node is actually observed, and 0 otherwise.
</p>


<hr><h4><a name="decl_pnlMakeNodeObserved">MakeNodeObserved</a></h4>
<p class="Blurb">Changes observation flag for node to actually observed.</p><pre>

</pre><p><dl>
 Arguments
<dt>nodeNum <dd>Number of the node in the graphical model.
</dl></p><p>
This function makes the node actually observed, if it was hidden, and throws an exception, if it is already actually observed.
</p>


<hr><h4><a name="decl_pnlMakeNodeHidden">MakeNodeHidden</a></h4>
<p class="Blurb">Changes observation flag for node to hidden.</p><pre>

</pre><p><dl>
 Arguments
<dt>nodeNum <dd>Number of the node in the graphical model.
</dl></p><p>
This function makes the node hidden, if it was actually observed, and throws an exception, if it is already hidden.
</p>


<hr><h4><a name="declCEvidence_GetObsNodesWithValues">GetObsNodesWithValues</a></h4>
<p class="Blurb">Returns pointer to vector of actually observed nodes and their values.</p><pre>

void CEvidence::GetObsNodesWithValues( intVector* <EM CLASS="CodeItalic">pObsNds</EM>, pConstValueVector* <EM CLASS="CodeItalic">pObsValues</EM>,pConstNodeTypeVector* <EM CLASS="CodeItalic">pNodeTypes</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>pObsNds <dd>Pointer to the vector that contains numbers of actually observed nodes from the graphical model.
<dt>pObsValues  <dd>Pointer to the vector of pointers to raw data of actually observed values. The order of these values corresponds to the order at <EM CLASS="CodeItalic">pObsNds</EM>.
<dt>pNodeTypes  <dd>Pointer to the vector that contains pointers to the node types of observed nodes. The order of these values corresponds to the order at <EM CLASS="CodeItalic">pObsNds</EM>.
</dl></p><p>
The function takes pointers to vectors and fills these vectors with requested information.
</p>


<hr><h4><a name="declCEvidence_GetModelDomain">GetModelDomain</a></h4>
<p class="Blurb">Returns model domain.</p><pre>

inline const CModelDomain* CEvidence::GetModelDomain() const;
</pre>


<hr><h4><a name="declCEvidence_Dump">Dump</a></h4>
<p class="Blurb">Dumps evidence content.</p><pre>

void CEvidence::Dump() const;
</pre>


<hr><h4><a name="declCEvidence_Save">Save</a></h4>
<p class="Blurb">Saves evidences to file. </p><pre>

static bool CEvidence::Save(const char *<EM CLASS="CodeItalic">fname</EM>,  pConstEvidenceVector&amp; <EM CLASS="CodeItalic">evVec</EM>);
</pre><p><dl>
 Arguments
<dt>fname <dd>File name.
<dt>evVec <dd>Array of evidences.
</dl></p><p>
This function saves evidences created for the static graphical model into a file. This function returns `true' if the evidence is saved, returns `false' otherwise.
</p>


<hr><h4><a name="declCEvidence_Save">Save</a></h4>
<p class="Blurb">Saves evidences to file. </p><pre>

static bool CEvidence::Save(const char *<EM CLASS="CodeItalic">fname</EM>,  pConstEvidenceVecVector&amp; <EM CLASS="CodeItalic">evVec</EM>);
</pre><p><dl>
 Arguments
<dt>fname <dd>File name.
<dt>evVec <dd>Array of evidences.
</dl></p><p>
This function saves evidences created for the dynamic graphical model into a file. This function returns `true' if the evidence is saved, returns `false' otherwise.
</p>


<hr><h4><a name="declCEvidence_Load">Load</a></h4>
<p class="Blurb">Loads evidences from file. </p><pre>

static bool CEvidence::Load( const char *<EM CLASS="CodeItalic">fname</EM>,  pEvidencesVector* <EM CLASS="CodeItalic">evVec</EM>, const CModelDomain *<EM CLASS="CodeItalic">pMD</EM> );
</pre><p><dl>
 Arguments
<dt>fname <dd>File name.
<dt>evVec <dd>Empty vector which is to store evidences.
<dt>pMD <dd>Pointer to the model domain.
</dl></p><p>
This function reads data from the file and creates evidences for the static graphical model.
</p>


<hr><h4><a name="declCEvidence_Load">Load</a></h4>
<p class="Blurb">Loads evidences to file. </p><pre>

static bool CEvidence::Load(const char *<EM CLASS="CodeItalic">fname</EM>, pEvidencesVecVector* <EM CLASS="CodeItalic">evVec</EM>, const CModelDomain *<EM CLASS="CodeItalic">pMD</EM>);
</pre><p><dl>
 Arguments
<dt>fname <dd>File name.
<dt>evVec <dd>Array of evidences.
<dt>pMD <dd>Pointer to the model domain.
</dl></p><p>
This function reads data from the file and creates evidences for DBN.


<hr><h2><a name="decl_pnlGraphical_Models">Graphical Models</a></h2>



<hr><h3><a name="decl_pnlClassCGraphicalModel">Class CGraphicalModel</a></h3>


<IMG SRC="fig/PNLMarch.book-102.gif">

<p>
Class<EM CLASS="CodeReg"> CGraphicalModel</EM> represents a graphical model, which consists of the graph and of factors that are set for the graph nodes. Class <EM CLASS="CodeReg">CGraphicalModel</EM> is a parent to two classes: <EM CLASS="CodeReg"><a href="#decl_pnlClassCStaticGraphicalModel">Class CStaticGraphicalModel</A></EM> and <EM CLASS="CodeReg"><a href="#decl_pnlCDynamicGraphicalModel">Class CDynamicGraphicalModel</A></EM>.
</p>



<hr><h4><a name="declCGraphicalModel_AllocFactor">AllocFactor</a></h4>
<p class="Blurb">Allocates factor for domain.</p><pre>

int CGraphicalModel::AllocFactor( int <EM CLASS="CodeItalic">number</EM> );
int CGraphicalModel::AllocFactor( int <EM CLASS="CodeItalic">numOfNdsInDomain</EM>, int *<EM CLASS="CodeItalic">domain</EM> );
int CGraphicalModel::AllocFactor( const intVector&amp; <EM CLASS="CodeItalic">domain</EM> );
</pre><p><dl>
 Arguments
<dt>number<dd>  Index of the domain for which the factor should be allocated.
<dt>numOfNdsInDomain<dd>  Number of nodes in the domain for which the factor should be allocated.
<dt>domain<dd>  Domain for which the factor is allocated.
</dl></p><p>
This function allocates a factor for a domain. The domain is specified either by its index or by the nodes from this domain.
</p>


<hr><h4><a name="declCGraphicalModel_AllocFactors">AllocFactors</a></h4>
<p class="Blurb">Allocates space for all factors of model.</p><pre>

int CGraphicalModel::AllocFactors();
</pre><p>
This function allocates space for all the factors of the model.
</p>


<hr><h4><a name="declCGraphicalModel_AttachFactor">AttachFactor</a></h4>
<p class="Blurb">Attaches factor to model.</p><pre>

int CGraphicalModel::AttachFactor( CFactor *<EM CLASS="CodeItalic">pFactor </EM>);
</pre><p><dl>
 Arguments
<dt>pFactor<dd>  Pointer to the factor to be attached to the model.
</dl></p><p>
This function attaches a factor to the model if the factor has an existing domain in terms of the graphical model.
</p>


<hr><h4><a name="declCGraphicalModel_AttachFactors">AttachFactors</a></h4>
<p class="Blurb">Attaches set of new factors and returns set of old factors for destruction.</p><pre>

CFactors* CGraphicalModel::AttachFactors( CFactors *<EM CLASS="CodeItalic">pFactors</EM>);
</pre><p><dl>
 Arguments
<dt>pFactors<dd>  New factors to be attached to the model instead of the old factors.
</dl></p><p>
This function attaches a set of factors object and returns the set of old factors for the user to destroy them.
</p>


<hr><h4><a name="declCGraphicalModel_GetGraph">GetGraph</a></h4>
<p class="Blurb">Returns non-constant pointer to class object.<DIV>

inline CGraph* CGraphicalModel::GetGraph() const;
</dl></p><p>
This function returns a non-constant pointer to the <EM CLASS="CodeReg">CGraph</EM> class object, which is attached to the model.
</p>


<hr><h4><a name="declCGraphicalModel_GetModelType">GetModelType</a></h4>
<p class="Blurb">Returns type of model.</p><pre>

inline CModelTypes CGraphicalModel::GetModelType() const;
</pre>


<hr><h4><a name="declCGraphicalModel_GetNodeAssociations">GetNodeAssociations</a></h4>
<p class="Blurb">Returns constant pointer to array of node associations for all nodes of model.</p><pre>

inline const int* CGraphicalModel::GetNodeAssociations() const;
</pre>


<hr><h4><a name="declCGraphicalModel_GetNodeType">GetNodeType</a></h4>
<p class="Blurb">Returns constant pointer to class object for specified node number.</p><pre>

inline const CNodeType* CGraphicalModel::GetNodeType(int <EM CLASS="CodeItalic">nodeNum</EM>) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Number of the node for which the node type is inquired.
</dl></p><p>
This function returns a constant pointer to the <EM CLASS="CodeReg">CNodeType</EM> object for the specified node number.
</p>


<hr><h4><a name="declCGraphicalModel_GetNodeTypes">GetNodeTypes</a></h4>
<p class="Blurb">Provides access to all node types of model.</p><pre>

inline void CGraphicalModel::GetNodeTypes( nodeTypeVector* <EM CLASS="CodeItalic">nodeTypes</EM> ) const;
inline void CGraphicalModel::GetNodeTypes( pConstNodeTypeVector* <EM CLASS="CodeItalic">nodeTypes</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeTypes<dd>  Returned parameter. Array of all <EM CLASS="CodeReg">CNodeType</EM> objects attached to the model.
</dl></p>


<hr><h4><a name="declCGraphicalModel_GetNumberOfNodes">GetNumberOfNodes</a></h4>
<p class="Blurb">Returns number of nodes for model.</p><pre>

inline int CGraphicalModel::GetNumberOfNodes() const;
</pre><p>
This function returns the whole number of nodes for the static graphical model and returns the number of the nodes per slice for the dynamic graphical model.
</p>


<hr><h4><a name="declCGraphicalModel_GetNumberOfNodeTypes">GetNumberOfNodeTypes</a></h4>
<p class="Blurb">Returns number of node types for model.</p><pre>

inline int CGraphicalModel::GetNumberOfNodeTypes() const;
</pre>


<hr><h4><a name="declCGraphicalModel_GetNumberOfFactors">GetNumberOfFactors</a></h4>
<p class="Blurb">Returns number of factors attached to model.</p><pre>

inline int CGraphicalModel::GetNumberOfFactors() const;
</pre>


<hr><h4><a name="decl_pnlGetFactor">GetFactor</a></h4>
<p class="Blurb">Returns non-constant pointer to class object for specified domain number.<DIV>
CFactor* CGraphicalModel::GetFactor( int <EM CLASS="CodeItalic">domainNumber </EM>);
</pre><p><dl>
 Arguments
<dt>domainNumber<dd>  Number of domain for which the factor needs to be found.
</dl></p><p>
This function returns a non-constant pointer to the <EM CLASS="CodeReg">
<a href="#decl_pnlClassCFactor">Class CFactor</A></EM>
 object for the specified domain number.
</p>


<hr><h4><a name="declCGraphicalModel_GetFactors">GetFactors</a></h4>
<p class="Blurb">Returns all factors attached to specified subset of nodes.</p><pre>

int CGraphicalModel::GetFactors( int <EM CLASS="CodeItalic">nNodes</EM>, const int* <EM CLASS="CodeItalic">nodes</EM>,  int *<EM CLASS="CodeItalic">nFactors</EM>, CFactor ***<EM CLASS="CodeItalic">factors</EM> );
virtual void CGraphicalModel::GetFactors( int <EM CLASS="CodeItalic">nNodes</EM>, const int* <EM CLASS="CodeItalic">nodes</EM>,int *<EM CLASS="CodeItalic">nFactors</EM>, CFactor ***<EM CLASS="CodeItalic">factors</EM> ) const = 0;
virtual int CGraphicalModel::GetFactors( int <EM CLASS="CodeItalic">nNodes</EM>, const int* <EM CLASS="CodeItalic">nodes</EM>, pFactorVector *<EM CLASS="CodeItalic">factors</EM>) const = 0;
virtual int CGraphicalModel::GetFactors( const intVector&amp; <EM CLASS="CodeItalic">nodes</EM>, pFactorVector *<EM CLASS="CodeItalic">factors</EM> ) const;
</pre><p>
This function enables the user to receive all the factors attached to the specified subset of nodes. Several factors may be attached to the same subset if the subset is a common part of several domains.
</p>


<hr><h4><a name="declCGraphicalModel_GetModelDomain">GetModelDomain</a></h4>
<p class="Blurb">Returns model domain.</p><pre>

inline CModelDomain* CGraphicalModel::GetModelDomain() const;
</pre>


<hr><h4><a name="declCGraphicalModel_IsValid">IsValid</a></h4>
<p class="Blurb">Checks validity of graphical model.</p><pre>

virtual bool CGraphicalModel::IsValid( std::string* <EM CLASS="CodeItalic">descriptionOut</EM> = NULL ) const = 0;
</pre><p><dl>
 Arguments
<dt>descriptionOut  <dd>Error message.
</dl></p><p>
This function checks the validity of the function. The function returns `true' if the model is valid, returns `false' otherwise.
</p>


<hr><h3><a name="decl_pnlClassCStaticGraphicalModel">Class CStaticGraphicalModel</a></h3>

<IMG SRC="fig/PNLMarch.book-103.gif">

<P>
</A>Class <EM CLASS="CodeReg">CStaticGraphicalModel</EM> is a parent to two subclasses: <EM CLASS="CodeReg"><a href="#decl_pnlClassCBNet">Class CBNet</A></EM> and <EM CLASS="CodeReg"><a href="#decl_pnlClassCMNet">Class CMNet</A></EM>.
</P>



<hr><h4><a name="declCStaticGraphicalModel_IsValidAsBaseForDynamicModel">IsValidAsBaseForDynamicModel</a></h4>
<p class="Blurb">Checks validity of model for creation of dynamic model.</p><pre>

bool CStaticGraphicalModel::IsValidAsBaseForDynamicModel(std::string* <EM CLASS="CodeItalic">descriptionOut</EM> = NULL) const;
</pre><p><dl>
 Arguments
<dt>descriptionOut  <dd>Error message.
</dl></p><p>
This function checks if the model is valid for the creation of the dynamic graphical model.
</p>


<hr><h3><a name="decl_pnlClassCBNet">Class CBNet</a></h3>

<IMG SRC="fig/PNLMarch.book-104.gif">


<hr><h4><a name="declCBNet_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CBNet* CBNet::Create( int <EM CLASS="CodeItalic">numberOfNodes</EM>, int <EM CLASS="CodeItalic">numberOfNodeTypes</EM>,const CNodeType *<EM CLASS="CodeItalic">nodeTypes</EM>,const int *<EM CLASS="CodeItalic">nodesAssociation</EM>, CGraph *<EM CLASS="CodeItalic">pGraph</EM> );
static CBNet* CBNet::Create( int <EM CLASS="CodeItalic">numberOfNodes</EM>,const nodeTypeVector&amp; <EM CLASS="CodeItalic">nodeTypes</EM>, const intVector&amp; <EM CLASS="CodeItalic">nodesAssociation</EM>, CGraph *<EM CLASS="CodeItalic">pGraph</EM> );
static CBNet* CBNet::Create( CGraph *<EM CLASS="CodeItalic">pGraph</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
</pre><p><dl>
 Arguments
<dt>numberOfNodeTypes <dd>Number of all node types.
<dt>nodeTypes <dd>Array of node types.
<dt>nodesAssociation  <dd>Array for nodes association with node types.
<dt>pGraph  <dd>Graph structure of the model.
<dt>numberOfNodes <dd>Number of nodes.
<dt>pMD <dd>Model domain.
</dl></p><p>
This function creates a class object.
</p>


<hr><h4><a name="declCBNet_Copy">Copy</a></h4>
<p class="Blurb">Creates new object by copying. </p><pre>

static CBNet* CBNet::Copy(const CBNet* <EM CLASS="CodeItalic">pBNet</EM>);
</pre><p><dl>
 Arguments
<dt>pBNet<dd>  Pointer to a <EM CLASS="CodeReg">CBNet</EM> object to be copied.
</dl></p><p>
This function creates a new <EM CLASS="CodeReg">
CBNet </EM>
object by copying the input object and returns a pointer to it<EM CLASS="CodeReg">.</EM> Call of the class destructor deletes the instance.
</p>


<hr><h4><a name="declCBNet_CreateWithRandomMatrices">CreateWithRandomMatrices</a></h4>
<p class="Blurb">Creates <EM CLASS="CodeReg">BNet</EM> object with random matrices.
</p><pre>
static CBNet* CBNet::CreateWithRandomMatrices( CGraph* <EM CLASS="CodeItalic">pGraph</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD </EM>);
</pre><p><dl>
 Arguments
<dt>pGraph  <dd>Graph structure.
<dt>pMD <dd>Model domain.
</dl></p><p>
This function creates a <EM CLASS="CodeItalic">BNet</EM> object with dense random matrices. Coverings matrices of a Gaussian distribution are matrix units.
</p>


<hr><h4><a name="declCBNet_ConvertToSparse">ConvertToSparse</a></h4>
<p class="Blurb">Converts object with dense matrices into object with sparse matrices.</p><pre>

CBNet* CBNet::ConvertToSparse() const;
</pre><p>
This function converts a <EM CLASS="CodeReg">BNet</EM> object with dense matrices into a <EM CLASS="CodeReg">BNet</EM> object with sparse matrices.
</p>


<hr><h4><a name="declCBNet_ConvertToDense">ConvertToDense</a></h4>
<p class="Blurb">Converts object with sparse matrices into object with dense matrices.</p><pre>

CBNet* CBNet::ConvertToDense() const;
</pre><p>
This function converts a <EM CLASS="CodeReg">BNet</EM> object with sparse matrices into a <EM CLASS="CodeReg">BNet</EM> object with dense matrices.
</p>


<hr><h4><a name="declCBNet_CreateTabularCPD">CreateTabularCPD</a></h4>
<p class="Blurb">Creates valid tabular CPD.</p><pre>

void CBNet::CreateTabularCPD( int <EM CLASS="CodeItalic">childNodeNumber</EM>, const floatVector&amp; <EM CLASS="CodeItalic">matrixData</EM> );
</pre><p><dl>
 Arguments
<dt>childNodeNumber <dd>Factor number.
<dt>matrixData  <dd>Array of matrix data.
</dl></p><p>
This function creates a tabular CPD using the given data.
</p>


<hr><h4><a name="declCBNet_FindMixtureNodes">FindMixtureNodes</a></h4>
<p class="Blurb">Finds numbers of mixture nodes.</p><pre>

void CBNet::FindMixtureNodes( intVector* <EM CLASS="CodeItalic">mixureNds </EM>);
</pre><p><dl>
 Arguments
<dt>mixureNds <dd>Input parameter. Empty vector of mixture nodes.
</dl></p><p>
This function finds numbers of mixture nodes of the mixture Gaussian distribution.
</p>


<hr><h4><a name="declCBNet_GenerateSamples">GenerateSamples</a></h4>
<p class="Blurb">Generates random evidences for <EM CLASS="CodeItalic">BNet</EM> given evidence.</p><pre>

virtual void CBNet::GenerateSamples( pEvidencesVector* <EM CLASS="CodeItalic">evidences</EM>, int <EM CLASS="CodeItalic">nSamples</EM>,const CEvidence* <EM CLASS="CodeItalic">pEv</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>evidences <dd>Input-output parameter. An empty vector of evidences to be created.
<dt>nSamples  <dd>Input parameter. Number of samples.
<dt>pEv <dd>Given evidence.
</dl></p><p>
This function generates samples from  the static graphical model.
</p>


<hr><h4><a name="declCBNet_IsValid">IsValid</a></h4>
<p class="Blurb">Checks model validity.</p><pre>

bool CBNet::IsValid(std::string* <EM CLASS="CodeItalic">descriptionOut</EM> = NULL) const;
</pre><p><dl>
 Arguments
<dt>descriptionOut  <dd>Output argument with an error message.
</dl></p><p>
This function checks the validity of the model. Returns `true' if the model is valid, returns `false' otherwise.
</p>

<hr><h3><a name="decl_pnlClassCMNet">Class CMNet</a></h3>

<IMG SRC="fig/PNLMarch.book-105.gif">



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates object of subclass.</p><pre>

static CMNet* CMNet::Create( int <EM CLASS="CodeItalic">numberOfCliques</EM>, const int *<EM CLASS="CodeItalic">cliqueSizes</EM>, const int **<EM CLASS="CodeItalic">cliques</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
static CMNet* CMNet::Create( const intVecVector&amp; <EM CLASS="CodeItalic">cliques</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM></P>static CMNet*  CMNet::Create( int <EM CLASS="CodeItalic">numberOfNodes</EM>, int <EM CLASS="CodeItalic">numberOfNodeTypes</EM>, const CNodeType *<EM CLASS="CodeItalic">nodeTypes</EM>, const int *<EM CLASS="CodeItalic">nodesAssociation</EM>, int <EM CLASS="CodeItalic">numberOfCliques</EM>, const int *<EM CLASS="CodeItalic">cliqueSizes</EM>, const int **<EM CLASS="CodeItalic">cliques</EM> );
static CMNet* CMNet::Create(int <EM CLASS="CodeItalic">numberOfNodes</EM>,const nodeTypeVector&amp;<EM CLASS="CodeItalic"> nodeTypes</EM>, const intVector&amp; <EM CLASS="CodeItalic">nodesAssociation</EM>, const intVecVector&amp; <EM CLASS="CodeItalic">cliques </EM>);
</pre><p><dl>
 Arguments
<dt>numberOfCliques<dd>  Number of cliques in the model.
<dt>cliqueSizes<dd>  Array of clique sizes.
<dt>cliques<dd>  Cliques.
<dt>pMD<dd>  Model domain.
<dt>numberOfNodes<dd>  Number of nodes in the model.
<dt>numberOfNodeTypes<dd>  Number of node types in the model.
<dt>nodeTypes<dd>  Array of node types.
<dt>nodesAssociation<dd>  Array of nodes association with node types.
</dl></p>


<hr><h4><a name="declCMNet_CreateWithRandomMatrices">CreateWithRandomMatrices</a></h4>
<p class="Blurb">Creates object with random matrices.</p><pre>

static CMNet* CMNet::CreateWithRandomMatrices( int <EM CLASS="CodeItalic">numberOfCliques</EM>,const int *<EM CLASS="CodeItalic">cliqueSizes</EM>,const int **<EM CLASS="CodeItalic">cliques,</EM> CModelDomain* <EM CLASS="CodeItalic">pMD</EM>);
static CMNet* CMNet::CreateWithRandomMatrices(  const intVecVector&amp; <EM CLASS="CodeItalic">cliques</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>);
</pre><p><dl>
 Arguments
<dt>numberOfCliques <dd>Number of cliques<EM CLASS="CodeItalic">.</EM>
<dt>cliqueSizes <dd>Array of clique sizes.
<dt>cliques <dd>Cliques.
<dt>pMD <dd>Model domain.
</dl></p><p>
This function creates a class object with dense random matrices. Covariance matrices of the Gaussian distribution are matrix units.
</p>


<hr><h4><a name="declCMNet_GetClique">GetClique</a></h4>
<p class="Blurb">Returns clique nodes.</p><pre>

inline void CMNet::GetClique( int <EM CLASS="CodeItalic">clqNum</EM>, int *<EM CLASS="CodeItalic">clqSize</EM>, const int **<EM CLASS="CodeItalic">clq</EM> )const;
inline void CMNet::GetClique( int <EM CLASS="CodeItalic">clqNum</EM>, intVector *<EM CLASS="CodeItalic">clq</EM>) const;
</pre><p><dl>
 Arguments
<dt>clqNum<dd>  Number of the clique.
<dt>clqSize<dd>  Returned parameter. Number of clique nodes.
<dt>clq<dd>  Returned parameter. Array of clique nodes.
</dl></p><p>
This function returns clique nodes.
</p>


<hr><h4><a name="decl_pnlConvertFromBNet">ConvertFromBNet</a></h4>
<p class="Blurb">Creates class object by converting input <EM CLASS="CodeItalic">BNet</EM>
</p><pre>

static CMNet* CMNet::ConvertFromBNet(const CBNet *<EM CLASS="CodeItalic">pBNet</EM>);
</pre><p><dl>
 Arguments
<dt>pBNet <dd>Bayesian network.
</dl></p><p>
This function creates a class object by converting the input <EM CLASS="CodeReg">BNet</EM>.
</p>


<hr><h4><a name="decl_pnlConvertFromBNetUsingEvidence">ConvertFromBNetUsingEvidence</a></h4>
<p class="Blurb">Creates object by converting input <EM CLASS="CodeReg">BNet</EM> using given evidence.
</p><pre>

static CMNet* CMNet::ConvertFromBNetUsingEvidence( const CBNet *<EM CLASS="CodeItalic">pBNet</EM>, const CEvidence *<EM CLASS="CodeItalic">pEvidence</EM> );
</pre><p><dl>
 Arguments
<dt>pBNet <dd>Bayesian network.
<dt>pEvidence <dd>Evidence.
</dl></p><p>
This function creates a class object by converting the input <EM CLASS="CodeReg">BNet</EM>.
</p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates object by copying input <EM CLASS="CodeReg">MNet</EM>
</p><pre>

static CMNet* CMNet::Copy(const CMNet *<EM CLASS="CodeItalic">pMNet</EM>);
</pre><p><dl>
 Arguments
<dt>pMNet <dd>Markov network.
</dl></p><p>
This function creates a new class object by copying the input <EM CLASS="CodeReg">
MNet</EM>.
</p>


<hr><h4><a name="declCMNet_CreateTabularPotential">CreateTabularPotential</a></h4>
<p class="Blurb">Allocates factor and creates matrix.</p><pre>

void CMNet::CreateTabularPotential( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, const floatVector&amp; <EM CLASS="CodeItalic">data</EM> );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of nodes.
<dt>data  <dd>Given data.
</dl></p><p>
This function allocates a factor and creates a new matrix with the given data.
</p>


<hr><h4><a name="declCMNet_ComputeLogLik">ComputeLogLik</a></h4>
<p class="Blurb">Computes logarithm of likelihood. </p><pre>

virtual float CMNet::ComputeLogLik( const CEvidence *<EM CLASS="CodeItalic">pEv</EM> ) const;
</pre><p><dl>
 Arguments
<dt>pEv <dd>Evidence.
</dl></p><p>
This function computes the logarithm of likelihood.
</p>


<hr><h4><a name="declCMNet_GetClqsNumsForNode">GetClqsNumsForNode</a></h4>
<p class="Blurb">Gets cliques containing node.</p><pre>

inline void CMNet::GetClqsNumsForNode( int <EM CLASS="CodeItalic">node</EM>, intVector *<EM CLASS="CodeItalic">clqs</EM> ) const;
</pre><p><dl>
 Arguments
<dt>node  <dd>Node number.
<dt>clqs  <dd>Cliques containing the<EM CLASS="CodeItalic">
 node.</EM>
</P>
</dl></p><p>
This function gets numbers of cliques that contain the given node.
</p>


<hr><h4><a name="declCMNet_GetNumberOfCliques">GetNumberOfCliques</a></h4>
<p class="Blurb">Returns number of cliques of model.</p><pre>

inline int CMNet::GetNumberOfCliques() const;
</pre>


<hr><h4><a name="declCMNet_GenerateSamples">GenerateSamples</a></h4>
<p class="Blurb">Generates random evidence.</p><pre>

virtual void CMNet::GenerateSamples( pEvidencesVector* <EM CLASS="CodeItalic">evidences</EM>, int <EM CLASS="CodeItalic">nSamples</EM>, const CEvidence *<EM CLASS="CodeItalic">pEvIn</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>evidences <dd>Input-output parameter. An empty vector of evidences that will be created by this method.
<dt>nSamples  <dd>Input parameter. Number of samples.
<dt>pEvIn <dd>Input parameter. Pointer to evidence.
</dl></p><p>
This function generates random evidences from <EM CLASS="CodeReg">MNet</EM>.
</p>


<hr><h3><a name="decl_pnlClassCMRF2">Class CMRF2</a></h3>


<IMG SRC="fig/PNLMarch.book-106.gif">

<p>
<EM CLASS="CodeReg"><a href="#decl_pnlClassCMNet">Class CMNet</A></EM> is a superclass for subclass <EM CLASS="CodeReg">CMRF2</EM>
 that represents a pairwise Markov network. This subclass implements <EM CLASS="CodeReg">CMNet</EM> virtual functions, so that the implementation takes into account that all the cliques consist of only two nodes.
</p>




<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CMRF2* CMRF2::Create( int <EM CLASS="CodeItalic">numberOfCliques</EM>,  const int *<EM CLASS="CodeItalic">cliqueSizesIn</EM>, const int **<EM CLASS="CodeItalic">cliquesIn</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
static CMRF2* CMRF2::Create( const intVecVector&amp; <EM CLASS="CodeItalic">clqsIn</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
static CMRF2* CMRF2::Create( int <EM CLASS="CodeItalic">numberOfNodes</EM>, int <EM CLASS="CodeItalic">numberOfNodeTypes</EM>, const CNodeType *<EM CLASS="CodeItalic">nodeTypesIn</EM>,const int *<EM CLASS="CodeItalic">nodeAssociationIn</EM>, int <EM CLASS="CodeItalic">numberOfCliques</EM>, const int *<EM CLASS="CodeItalic">cliqueSizesIn</EM>, const int **<EM CLASS="CodeItalic">cliquesIn</EM> );
static CMRF2* CMRF2::Create( int <EM CLASS="CodeItalic">numberOfNodes</EM>, const nodeTypeVector&amp; <EM CLASS="CodeItalic">nodeTypesIn</EM>,const intVector&amp; <EM CLASS="CodeItalic">nodeAssociationIn</EM>, const intVecVector&amp; <EM CLASS="CodeItalic">cliquesIn</EM> );
</pre><p><dl>
 Arguments
<dt>numberOfCliques <dd>Number of cliques.
<dt>cliqueSizesIn <dd>Returned parameter. Sizes of cliques.
<dt>cliquesIn   <dd>Cliques.
<dt>pMD <dd>Model domain.
<dt>numberOfNodes <dd>Number of nodes.
<dt>numberOfNodeTypes <dd>Number of node types.
<dt>nodeTypesIn <dd>Node types.
<dt>nodeAssociationIn <dd>Association of nodes.
</dl></p>


<hr><h4><a name="decl_pnlCMRF2_CreateWithRandomMatrices">CreateWithRandomMatrices</a></h4>
<p class="Blurb">Creates object with random matrices.</p><pre>

static CMRF2* CMRF2::CreateWithRandomMatrices( int <EM CLASS="CodeItalic">numberOfCliques</EM>,const int *<EM CLASS="CodeItalic">cliqueSizesIn</EM>,const int **<EM CLASS="CodeItalic">cliquesIn</EM>,CModelDomain* <EM CLASS="CodeItalic">pMD</EM>);
static CMRF2* CMRF2::CreateWithRandomMatrices( const intVecVector&amp; <EM CLASS="CodeItalic">clquesIn</EM>,
ModelDomain* <EM CLASS="CodeItalic">pMD</EM>);
</pre><p><dl>
 Arguments
<dt>numberOfCliques <dd>Number of cliques.
<dt>cliqueSizesIn <dd>Clique size.
<dt>cliquesIn <dd>Cliques.
<dt>pMD <dd>Model domain.
</dl></p>

<hr><h3><a name="decl_pnlClassCIDNet">Class CIDNet</a></h3>
<hr><h4><a name="decl_pnlCIDNet_Create">Create</a></h4>
<p class="Blurb">Returns CIDNet class object</p>
static CIDNet* Create(int numberOfNodes, int numberOfNodeTypes, const CNodeType *nodeTypesIn, const int *nodeAssociationIn, CGraph *pGraphIn);

<p><dl>  
 Arguments 

<dt>numberOfNodes  <dd>Number of nodes in new Influence Diagram. 
<dt>numberOfNodeTypes <dd>Number of node types in new Influence Diagram 
<dt>nodeTypesIn <dd>Pointer to the array of node types 
<dt>nodeAssociationIn <dd>Pointer to the array of node associations. 
<dt>pGraphIn <dd>Graph to be attached to the model. 
</dl> </p>
<p><b>Discussion  </b></p>
<p>This function creates a CIDNet object from an input model and returns a pointer to it </p>

<hr><h4><a name="decl_pnlCIDNet_GetUnValueNodes">GetUnValueNodes </a></h4>
<p class="Blurb">Gets chance and decision nodes of the input object.</p>
intVector* GetUnValueNodes() const;
  
<hr><h4><a name="decl_pnlCIDNet_GetDecisionNodes">GetDecisionNodes</a></h4>
<p class="Blurb">Gets decision nodes of the input object</p>
void GetDecisionNodes(intVector& decisionNodesOut) const;
<p><dl>  
 Arguments 
<dt>decisionNodesOut <dd>Reference to an array where decision nodes will be stored 
</dl></p>

<hr><h4><a name="decl_pnlCIDNet_GetValueNodes">GetValueNodes</a></h4>
<p class="Blurb">Gets utility nodes of the input object.</p>
void GetValueNodes(intVector& valueNodesOut) const; 
  
<p><dl> 
 Arguments 
<dt>valueNodesOut <dd>Reference to an array where utility nodes will be stored 
</dl></p> 

<hr><h4><a name="decl_pnlCIDNet_IsLIMID">IsLIMID</a></h4>

<p class = "Blurb">Checks whether the net is Limited Memory Influence Diagram or not</p>
bool IsLIMID(void) const; 
 
<p> <b>Discussion</b> </p>
<p>This function Checks whether the net is Limited Memory Influence Diagram or not by checking influences between different decision nodes. </p>
 
<hr><h3><a name="decl_pnlClassCDiagnostics">Class CDiagnostics</a></h3>
<p>Class CDiagnostics carries out diagnostics using marginal approach.</p>

<hr><h4><a name="decl_pnlCDiagnostics_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p>
<pre>static CDiagnostics *Create(const CBNet *pBNet);</pre>
<p><dl> 
 Arguments 
<dt>pBNet <dd>Pointer to the class CBNet. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetTargetNodes">SetTargetNodes</a></h4>
<p class="Blurb">Determine target nodes (hypothesis set).</p>
<pre>void SetTargetNodes(intVector &targetNodes);</pre>
<p><dl> 
 Arguments 
<dt>targetNodes <dd>list of target(hypothesis) nodes. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetObservationNodes">SetObservationNodes</a></h4>
<p class="Blurb">Determine test nodes.</p> 
<pre>void SetObservationNodes(intVector &observationNodes);</pre>
<p><dl> 
 Arguments 
<dt>observationNodes <dd>list of test nodes. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetTargetState">SetTargetState</a></h4>
<p class="Blurb">Allow to define target state for specific node.</p> 
<pre>void SetTargetState(int node, int state);</pre>
<p><dl> 
 Arguments 
<dt>node <dd>Number of target node. 
<dt>state <dd>Target state value for it`s node. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetTargetStates">SetTargetStates</a></h4>
<p class="Blurb">Allow to define target state for list of nodes.</p>
<pre>void SetTargetStates(int node, intVector &listStates);</pre>
<p><dl> 
 Arguments 
<dt>node <dd>Number of target node. 
<dt>listStates <dd>List of target state values for it`s node. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_GetTestsList">GetTestsList</a></h4>
<p class="Blurb">Return sorted vector of numbers test nodes in order of contraction Value Of Information function.</p>
<pre>intVector GetTestsList(const intVector &pursuedHypNodes, const intVector &pursuedHypNodesState);</pre>
<p><dl> 
 Arguments 
<dt>pursuedHypNodes <dd>List of pursued nodes. 
<dt>pursuedHypNodesState <dd>List of pursued states of pursued nodes. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetCost">SetCost</a></h4>
<p class="Blurb">Set cost of observation for test node.</p>
<pre>void SetCost(int node, float nodeCost);</pre>
<p><dl> 
 Arguments 
<dt>node <dd>Number of node for which the cost is set. 
<dt>nodeCost <dd>The cost value. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetCostRatio">SetCostRatio</a></h4>
<p class="Blurb">Set Value Of Information parameter.</p>
<pre>void SetCostRatio(float costR);</pre>
<p><dl> 
 Arguments 
<dt>costR <dd>The cost ratio value. 
</dl></p> 

<hr><h4><a name="declCDiagnostics_SetAlgorithm">SetAlgorithm</a></h4>
<p class="Blurb">Allow to define diferent algorithms for calculation of Value Of Information.</p>
<pre>void SetAlgorithm(int algNumber);</pre>
<p><dl> 
 Arguments 
<dt>algNumber <dd> <pre>The algorithm number: 
	0 - using Marginal Strength 1; 
	1 - using Marginal Strength 2; </pre>
</dl></p> 
 
 



<hr><h3><a name="decl_pnlClassSFactorGraph">Class CFactorGraph</a></h3>


<IMG SRC="fig/PNLMarch.book-107.gif">

<p>
Factor graph is a graphical representation of the factorized distribution. All factors of the distribution are represented by factor-nodes, which are connected to variable-nodes lying in the factor domain. The resulting graph of the distribution is called the factor graph.
</p>
<p>
The <EM CLASS="CodeReg">CFactorGraph</EM> class is a graphical model which consists of a set of factors. The set of factors constitutes a probability distribution. All the factors are potentials.
</p>





<hr><h4><a name="declCFactorGraph_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CFactorGraph* CFactorGraph::Create( CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const CFactors* <EM CLASS="CodeItalic">pFactors</EM> );
</pre><p><dl>
 Arguments
<dt>pMD <dd>Pointer to the model domain.
<dt>pFactors  <dd>Pointer to the <EM CLASS="CodeReg">CFactors</EM>object which contains all factors describing the factor graph object.
</dl></p><p>
This function creates a factor graph out of all factors of the model domain.
</p>


<hr><h4><a name="declCFactorGraph_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CFactorGraph* CFactorGraph::Create(CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, int <EM CLASS="CodeItalic">numFactors</EM> );
</pre><p><dl>
 Arguments
<dt>pMD <dd>Pointer to the model domain.
<dt>numFactors  <dd>Number of factors in the factor graph.
</dl></p><p>
This function creates a factor graph of several allocated factors.
</p>


<hr><h4><a name="declCFactorGraph_Copy">Copy</a></h4>
<p class="Blurb">Creates replica of input object.</p><pre>

static CFactorGraph* CFactorGraph::Copy( const CFactorGraph* <EM CLASS="CodeItalic">pFG</EM> );
</pre><p><dl>
 Arguments
<dt>pFG <dd>Pointer to the <EM CLASS="CodeReg">CFactorGraph</EM> object.
</dl></p><p>
This function creates a new <EM CLASS="CodeReg">CFactorGraph </EM>object by copying the input object.
</p>


<hr><h4><a name="declCFactorGraph_Shrink">Shrink</a></h4>
<p class="Blurb">Creates factor graph with given evidence by shrinking all potentials of given factor. </p><pre>

CFactorGraph* CFactorGraph::Shrink( const CEvidence* <EM CLASS="CodeItalic">pEvidence</EM> )const;
</pre><p><dl>
 Arguments
<dt>pEvidence <dd>Pointer to the <EM CLASS="CodeReg">Evidence</EM> object.
</dl></p><p>
This function creates a factor graph with the given evidence by shrinking all the potentials of the given factor.
</p>


<hr><h4><a name="declCFactorGraph_GetNumFactorsAllocated">GetNumFactorsAllocated</a></h4>
<p class="Blurb">Returns numbers of allocated factors.</p><pre>

inline int CFactorGraph::GetNumFactorsAllocated() const;
</pre>


<hr><h4><a name="decl_pnlConvertFromBNet">ConvertFromBNet</a></h4>
<p class="Blurb">Creates class object by converting <EM CLASS="CodeItalic">BNet</EM> object
</p><pre>

static CFactorGraph* CFactorGraph::ConvertFromBNet( const CBNet* <EM CLASS="CodeItalic">pBNet </EM>);
</pre><p><dl>
 Arguments
<dt>pBNet <dd>Pointer to a <EM CLASS="CodeReg">CBNet</EM> object to be converted.
</dl></p><p>
This function creates a <EM CLASS="CodeReg">CFactorGraph</EM> object by converting the given <EM CLASS="CodeReg">BNet</EM> object.
</p>


<hr><h4><a name="declCFactorGraph_ConvertFromMNet">ConvertFromMNet</a></h4>
<p class="Blurb">Creates class object by converting <EM CLASS="CodeReg">MNet</EM> object.</p><pre>

static CFactorGraph* CFactorGraph::ConvertFromMNet( const CMNet* <EM CLASS="CodeItalic">pMNet </EM>);
</pre><p><dl>
 Arguments
<dt>pMNet <dd>Pointer to a <EM CLASS="CodeReg">CMNet</EM> object to be copied
</dl></p><p>
This function creates a <EM CLASS="CodeReg">CFactorGraph</EM> object by converting <EM CLASS="CodeReg">MNet</EM> object.
</p>


<hr><h4><a name="declCFactorGraph_IsValid">IsValid</a></h4>
<p class="Blurb">Checks validity of function.</p><pre>

bool CFactorGraph::IsValid( std::string* <EM CLASS="CodeItalic">descriptionOut</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>descriptionOut  <dd>Error message.
</dl></p>


<hr><h4><a name="declCFactorGraph_GetNbrFactors">GetNbrFactors</a></h4>
<p class="Blurb">Returns numbers of factors.</p><pre>

inline void CFactorGraph::GetNbrFactors( int <EM CLASS="CodeItalic">node</EM>, intVector* <EM CLASS="CodeItalic">nbrsFactorsOut </EM>) const;
</pre><p><dl>
 Arguments
<dt>node  <dd>Node<EM CLASS="CodeItalic">.</EM>
<dt>nbrsFactors <dd>Numbers of factors.
</dl></p><p>
This function returns numbers of factors neighboring to the node.
</p>


<hr><h4><a name="declCFactorGraph_GetNbrFactors">GetNbrFactors</a></h4>
<p class="Blurb">Returns factors neighboring to given node.</p><pre>

inline void CFactorGraph::GetNbrFactors( int <EM CLASS="CodeItalic">node</EM>, intVector* <EM CLASS="CodeItalic">nbrsFactors </EM>) const;
</pre><p><dl>
 Arguments
<dt>node  <dd>Number of the node.
<dt>nbrsFactors <dd>Returned parameter.Vector of numbers of factors neighboring to the node factors.
</dl></p><p>
This function returns factors neighboring to the given node. A factor is called neighboring to the node if the latter lies in the factor domain.
</p>


<hr><h4><a name="declCFactorGraph_GetNumNbrFactors">GetNumNbrFactors</a></h4>
<p class="Blurb">Returns number of factors neighboring to given node.</p><pre>

inline int CFactorGraph::GetNumNbrFactors( int <EM CLASS="CodeItalic">node </EM>) const;
</pre><p><dl>
 Arguments
<dt>node  <dd>Number of the node.
</dl></p><p>
This function returns the number of factors neighboring to the given node.
</p>


<hr><h3><a name="decl_pnlClassCJunctionTree">Class CJunctionTree</a></h3>


<IMG SRC="fig/PNLMarch.book-108.gif">

<p>
<A NAME="pgfId-53793"></A>This class represents the structure of a Junction tree. It is used in the Junction Tree Inference Engine for internal local computations. A Junction tree instance is created on the creation of the <EM CLASS="CodeReg">JtreeInfEngine.</EM>
</p>



<hr><h4><a name="declCJunctionTree_Create">Create</a></h4>
<p class="Blurb">Creates Junction tree.</p><pre>

static CJunctionTree* CJunctionTree::Create( const CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel</EM>,const intVecVector&amp; <EM CLASS="CodeItalic">subGrToConnect</EM> = intVecVector() );
static CJunctionTree* CJunctionTree::Create( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM>, int <EM CLASS="CodeItalic">numOfSubGrToConnect</EM> = 0,const int *<EM CLASS="CodeItalic">subGrToConnectSizes</EM> = NULL, const int **<EM CLASS="CodeItalic">subGrToConnect</EM> = NULL );
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd>Graphical model from which the tree is to be constructed.
<dt>numOfSubGrToConnect <dd>Number of subgraphs to be connected to the tree.
<dt>subGrToConnectSizes <dd>Sizes of subgraphs to be connected to the tree.
<dt>subGrToConnect  <dd>Subgraphs the user wants to appear in the tree.
</dl></p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates replica of input Junction tree.</p><pre>

const CJunctionTree* <EM CLASS="CodeItalic">pJTree</EM></P></pre><p><dl>
 Arguments
<dt>pJTree  <dd>Junction tree to be copied.
<A NAME="pgfId-53810"></A>Discussion</H6>
<P CLASS="Body">
</dl></p><p>
This function copies the input Junction tree.
</p>


<hr><h4><a name="declCJunctionTree_GetNodeContent">GetNodeContent</a></h4>
<p class="Blurb">Returns clique of Junction tree.</p><pre>

inline void CJunctionTree::GetNodeContent( int <EM CLASS="CodeItalic">nodeNumber</EM>, int *<EM CLASS="CodeItalic">nodeContentSz</EM>, const int **<EM CLASS="CodeItalic">content</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeNumber  <dd>Number of the clique.
<dt>nodeContentSz <dd>Returned parameter. Size of the clique.
<dt>content <dd>Returned parameter.Pointer to the clique.
</dl></p><p>
This function returns the Junction tree clique with the number of <EM CLASS="CodeItalic">
nodeNumber</EM>.
</p>


<hr><h4><a name="declCJunctionTree_GetNodesConnectedByUser">GetNodesConnectedByUser</a></h4>
<p class="Blurb">Returns set of connected nodes.</p><pre>

inline void CJunctionTree::GetNodesConnectedByUser( int <EM CLASS="CodeItalic">nodeSetNum</EM>, int *<EM CLASS="CodeItalic">numOfNds</EM>, const int **<EM CLASS="CodeItalic">nds</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeSetNum  <dd>Number of the set of nodes.
<dt>numOfNds  <dd>Return parameter. Size of the set of nodes.
<dt>nds <dd>Return parameter. Pointer to the set of nodes.
</dl></p><p>
This function returns the set of nodes which were connected when the Junction tree was created.
</p>


<hr><h4><a name="declCJunctionTree_GetFactorAssignmentToClique">GetFactorAssignmentToClique</a></h4>
<p class="Blurb">Returns arrays of indices that show assignment of input model factors to Junction tree cliques. </p><pre>

inline void CJunctionTree::GetFactorAssignmentToClique( int *<EM CLASS="CodeItalic">numberOfFactors</EM>, const int **<EM CLASS="CodeItalic">factorAssign</EM> ) const;
</pre><p><dl>
 Arguments
<dt>numberOfFactors <dd>Return parameter. Number of factors of the input model.
<dt>factorAssign  <dd>Return parameter. Pointer to an array of indices.
</dl></p><p>
This function returns arrays of indices that show to what cliques of the Junction tree input model factors are assigned.
</p>


<hr><h4><a name="declCJunctionTree_GetSeparatorDomain">GetSeparatorDomain</a></h4>
<p class="Blurb">Returns domain of separator between two cliques of Junction tree.</p><pre>

inline void CJunctionTree::GetSeparatorDomain( int <EM CLASS="CodeItalic">firstClqNum</EM>, int <EM CLASS="CodeItalic">secondClqNum</EM>, int *<EM CLASS="CodeItalic">domSize</EM>, const int **<EM CLASS="CodeItalic">domain</EM> ) const;
</pre><p><dl>
 Arguments
<dt>firstClqNum <dd>Number of the first clique.
<dt>secondClqNum  <dd>Number of the second clique.
<dt>domSize <dd>Return parameter.Size of the domain on the separator.
<dt>domain  <dd>Return parameter.Pointer to the separator.
</dl></p><p>
This function returns the domain   of the separator which is located between two cliques of the Junction tree.
</p>


<hr><h4><a name="declCJunctionTree_GetNodePotential">GetNodePotential</a></h4>
<p class="Blurb">Returns pointer to potential defined for Junction tree clique.</p><pre>

inline CPotential* CJunctionTree::GetNodePotential( int <EM CLASS="CodeItalic">nodeNum </EM>);
</pre><p><dl>
 Arguments
<dt>nodeNum <dd>Number of the clique of the Junction tree.
</dl></p><p>
This function returns the pointer to the potential that is defined for a clique of the Junction tree.
</p>


<hr><h4><a name="declCJunctionTree_GetSeparatorPotential">GetSeparatorPotential</a></h4>
<p class="Blurb">Returns pointer to potential defined for separator between two cliques.</p><pre>

inline CPotential* CJunctionTree::GetSeparatorPotential( int <EM CLASS="CodeItalic">firstClqNum</EM>, int <EM CLASS="CodeItalic">secondClqNum</EM> );
</pre><p><dl>
 Arguments
<dt>firstClqNum <dd>Number of the first clique.
<dt>secondClqNum  <dd>Number of the second clique.
</dl></p><p>
This function returns the pointer to the potential that is defined for the separator between two cliques.
</p>


<hr><h4><a name="declCJunctionTree_GetClqNumsContainingSubset">GetClqNumsContainingSubset</a></h4>
<p class="Blurb">Returns numbers of Junction tree cliques with common subset of nodes.</p><pre>

inline void CJunctionTree::GetClqNumsContainingSubset( int <EM CLASS="CodeItalic">numOfNdsInSubset</EM>, const int *<EM CLASS="CodeItalic">subset</EM>, int *<EM CLASS="CodeItalic">numOfClqs</EM>, const int **<EM CLASS="CodeItalic">clqsContSubset</EM> ) const;
</pre><p><dl>
 Arguments
<dt>numOfNdsInSubset  <dd>Size of the subset.
<dt>subset  <dd>Pointer to the subset of nodes.
<dt>numOfClqs <dd>Return parameter. Number of cliques with a common subset.
<dt>clqsContSubset<dd>  Pointer to the array of numbers of cliques with a common subset.
</dl></p><p>
This function returns numbers to the Junction tree cliques that have a common subset of nodes.
</p>


<hr><h4><a name="declCJunctionTree_InitCharge">InitCharge</a></h4>
<p class="Blurb">Initializes charge for Junction tree.  </p><pre>

void CJunctionTree::InitCharge( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM>, const CEvidence *<EM CLASS="CodeItalic">pEvidence</EM>, int <EM CLASS="CodeItalic">sumOnMixtureNode</EM> = 1 );
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd>Pointer to the input graphical model.
<dt>pEvidence <dd>Pointer to the evidence to be taken into account.
<dt>sumOnMixtureNode  <dd>Shows if the distribution for the mixture node is to be computed during inference.
</dl></p><p>
This function initializes charge for the Junction tree. The Junction tree charge comprises both potentials for cliques and potentials for separators.
</p>


<hr><h4><a name="declCJunctionTree_ClearCharge">ClearCharge</a></h4>
<p class="Blurb">Clears charge.</p><pre>

void CJunctionTree::ClearCharge();
</pre>


<hr><h4><a name="decl_pnloperator=">operator=</a></h4>
<p class="Blurb">Performs initialization.</p><pre>

CJunctionTree&amp; CJunctionTree::operator=( const CJunctionTree &amp;<EM CLASS="CodeItalic">JTree </EM>);
</pre><p><dl>
 Arguments
<dt>JTree <dd>RHS of the assignment operator.
</dl></p><p>
This function performs initialisation by copying potentials of one tree to another tree under the condition that the structures of Junction trees are identical.
</p>


<hr><h4><a name="declCJunctionTree_GetNumberOfNodes">GetNumberOfNodes</a></h4>
<p class="Blurb">Returns numbers of Junction tree nodes.</p><pre>

inline int CJunctionTree::GetNumberOfNodes() const;
</pre><p>
This function returns numbers of Junction tree nodes. The node numbers correspond to the numbers of the Junction tree cliques.
</p>


<hr><h4><a name="declCJunctionTree_DumpNodeContents">DumpNodeContents</a></h4>
<p class="Blurb">Dumps Junction tree cliques to outstream.</p><pre>

inline void CJunctionTree::DumpNodeContents() const;
</pre><p>
This function dumps Junction tree cliques out to the outstream. Standard output of the outstream is set by default but may be redirected.
</p>


<hr><h3><a name="decl_pnlCDynamicGraphicalModel">Class CDynamicGraphicalModel</a></h3>

<IMG SRC="fig/PNLMarch.book-109.gif">

<p>
<A NAME="pgfId-58804"></A>Class <EM CLASS="CodeReg">CDynamicGraphicalModel</EM> is a superclass for all classes that implement dynamic graphical models.
</p>



<hr><h4><a name="declCDynamicGraphicalModel_CreatePriorSliceGrModel">CreatePriorSliceGrModel</a></h4>
<p class="Blurb">Creates static graphical model.</p><pre>

virtual CStaticGraphicalModel* CDynamicGraphicalModel::CreatePriorSliceGrModel()const = 0;
</pre><p>
This function creates a static graphical model corresponding to the prior slice of the dynamic graphical model.
</p>


<hr><h4><a name="declCDynamicGraphicalModel_UnrollDynamicModel">UnrollDynamicModel</a></h4>
<p class="Blurb">Creates static graphical model by unrolling of dynamic graphical model.</p><pre>

CStaticGraphicalModel* CDynamicGraphicalModel::UnrollDynamicModel( int <EM CLASS="CodeItalic">numOfSlices</EM> );
</pre><p><dl>
 Arguments
<dt>numOfSlices<dd>  Number of slices.
</dl></p><p>
This member function unrolls a dynamic graphical model as a number of slices and   thus constructs a static graphical model.
</p>


<hr><h4><a name="declCDynamicGraphicalModel_GetInterfaceNodes">GetInterfaceNodes</a></h4>
<p class="Blurb">Returns numbers of interface nodes.</p><pre>

inline void CDynamicGraphicalModel::GetInterfaceNodes( intVector* <EM CLASS="CodeItalic">interfaceNds</EM>) const;
inline void CDynamicGraphicalModel::GetInterfaceNodes( int *<EM CLASS="CodeItalic">numOfNds</EM>, const int **<EM CLASS="CodeItalic">interfaceNds</EM> ) const;
</pre><p><dl>
 Arguments
<dt>numOfNds<dd>  Returned parameter. Number of interface nodes.
<dt>interfaceNds<dd>  Returned parameter. Array of interface nodes.
</dl></p><p>
This function returns numbers of interface nodes.
</p>


<hr><h4><a name="declCDynamicGraphicalModel_GetStaticModel">GetStaticModel</a></h4>
<p class="Blurb">Returns a pointer to static graphical model.</p><pre>

inline CStaticGraphicalModel* CDynamicGraphicalModel::GetStaticModel() const;
</pre><p>
This member function returns a pointer to the static graphical model used for creating a dynamic graphical model.
</p>


<hr><h3><a name="decl_pnlCDBN">Class CDBN</a></h3>

<IMG SRC="fig/PNLMarch.book-110.gif">

<p>
<EM CLASS="CodeReg">CDBN </EM>is a subclass of <EM CLASS="CodeReg"><a href="#decl_pnlCDynamicGraphicalModel">Class CDynamicGraphicalModel</A></EM>
 and implements virtual functions of the parent class.
</p>

<hr><h4><a name="declCDBN_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CDBN* CDBN::Create( CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to <EM CLASS="CodeReg">BNet</EM>, which is to represent a DBN unrolled for first two time-slices.
</dl></p><p>
Thi function creates a <EM CLASS="CodeReg">CDBN</EM> object.
</p>


<hr><h4><a name="declCDBN_GenerateSamples">GenerateSamples</a></h4>
<p class="Blurb">Generates samples from DBN.</p><pre>

void CDBN::GenerateSamples( pEvidencesVecVector* <EM CLASS="CodeItalic">evidences</EM>,const intVector&amp; <EM CLASS="CodeItalic">nSlices)</EM> const;
</pre><p><dl>
 Arguments
<dt>evidences <dd>Output parameter. Generated evidence.
<dt>nSlices<dd>  Input parameter. Number of slices for which evidence is generated.
</dl></p><p>
Generates samples from the dynamic graphical model.
</p>


<hr><h2><a name="decl_pnlDistribution_Functions">Distribution Functions</a></h2>





<hr><h3><a name="decl_pnlClassCDistribFun">Class CDistribFun</a></h3>


<IMG SRC="fig/PNLMarch.book-111.gif">


<hr><h4><a name="decl_pnloperator=">operator=</a></h4>
<p class="Blurb">Assigns data to object from input distribution function.</p><pre>

virtual CDistribFun&amp; CDistribFun::operator = ( const CDistribFun&amp; <EM CLASS="CodeItalic">rDistrFun</EM> );
</pre><p><dl>
 Arguments
<dt>rDistrFun  <dd>Reference to the <EM CLASS="CodeReg">
CDistribFun</EM>
 object.
</dl></p><p>
This function assigns data from the input factor to the object for which it is called only when both of them are of the same size and type.
</p>
</pre></dl></p>


<hr><h4><a name="decl_pnlGetNodeTypesVector">GetNodeTypesVector</a></h4>
<p class="Blurb">Returns node types to nodes for which it was created.</p><pre>

inline const pConstNodeTypeVector CDistribFun::*GetNodeTypesVector() const;
</pre><p>
This function returns node types to the nodes for which it was created.
</p>


<hr><h4><a name="declCDistribFun_SetVariableType">SetVariableType</a></h4>
<p class="Blurb">Sets position for node type in distribution.</p><pre>

inline void CDistribFun::SetVariableType( int <EM CLASS="CodeItalic">position</EM>, const CNodeType* <EM CLASS="CodeItalic">varType</EM> );
</pre><p><dl>
 Arguments
<dt>position  <dd>Order number.
<dt>varType<dd>  Pointer to node types.
</dl></p><p>
This function sets a certain position for the given node type in the distribution.
</p>


<hr><h4><a name="declCDistribFun_IsValid">IsValid</a></h4>
<p class="Blurb">Checks validity of distribution function.</p><pre>

virtual bool CDistribFun::IsValid( std::string* <EM CLASS="CodeItalic">discription</EM> = NULL ) const = 0;
</pre><p><dl>
 Arguments
<dt>discription <dd>Error message.
</dl></p><p>
This function checks if the distribution function is valid.
</p>


<hr><h4><a name="declCDistribFun_AllocMatrix">AllocMatrix</a></h4>
<p class="Blurb">Creates matrix and allocates it to factor.</p><pre>

virtual void CDistribFun::AllocMatrix( const float *<EM CLASS="CodeItalic">data</EM>, EMatrixType <EM CLASS="CodeItalic">mType</EM>,   int <EM CLASS="CodeItalic">numberOfWeightMatrix</EM> = -1,  const int *<EM CLASS="CodeItalic">parentIndices </EM>= NULL );
</pre><p><dl>
 Arguments
<dt>data<dd>  Array that corresponds to a certain part of the distribution.
<dt>mType<dd>  Type of matrix allocated to the factor.
<dt>numberOfWeightMatrix<dd>  Number of the matrix called if several matrices of a given type are associated with the factor.This argument is omitted if only one matrix is involved.
<dt>parentIndices   <dd>Array of values of discrete parents.
</dl></p><p>
This function creates a new matrix and allocates it to the distribution function.
</p>


<hr><h4><a name="declCDistribFun_AttachMatrix">AttachMatrix</a></h4>
<p class="Blurb">Enters data in matrix and associates matrix with distribution function.</p><pre>

virtual void CDistribFun::AttachMatrix( CMatrix&lt;float&gt; *<EM CLASS="CodeItalic">pMatrix</EM>,  EMatrixType <EM CLASS="CodeItalic">mType</EM>,  int <EM CLASS="CodeItalic">numberOfWeightMatrix = -1,</EM>  const int *<EM CLASS="CodeItalic">parentIndices = NULL </EM>) = 0;
</pre><p><dl>
 Arguments
<dt>pMatrix <dd>Pointer to the <EM CLASS="CodeReg">
CMultiDMatrix</EM>
 object.
<dt>mTypes  <dd>Matrix type.
<dt>numberOfWeightMatrix  <dd>Number of the matrix called if several matrices of a given type are associated with the factor. The argument is optional. It is omitted when one matrix is involved.
<dt>parentIndices   <dd>Array of values of discrete parents.
</dl></p><p>
This function enters data into the matrix and associates the matrix with the distribution function.
</p>


<hr><h4><a name="decl_pnlGetMatrix">GetMatrix</a></h4>
<p class="Blurb">Returns pointer to matrix attached to factor.</p><pre>

virtual CMatrix&lt;float&gt; CDistribFun::*GetMatrix( EMatrixType <EM CLASS="CodeItalic">mType</EM>,  int <EM CLASS="CodeItalic">numWeightMat = -1</EM>, const int *<EM CLASS="CodeItalic">parentIndices </EM><EM CLASS="CodeReg">=</EM><EM CLASS="CodeItalic"> </EM><EM CLASS="CodeReg">NULL</EM> ) const = 0;
</pre><p><dl>
 Arguments
<dt>mType<dd>  Type of the matrix called.
<dt>numWeightMat<dd>  Number of the matrix called among several matrices of the given type. The argument is omitted when only one matrix is involved.
<dt>paretnIndices<dd>  Array of values of discrete parents.
</dl></p><p>
This function returns the pointer to a matrix attached to the factor. The function identifies one of the following matrix types: <EM CLASS="CodeItalic">
matTable, matMean, matCov, matWeights, mathH, matK.</EM>

<hr><h4><a name="declCDistribFun_GetNumberOfNodes">GetNumberOfNodes</a></h4>
<p class="Blurb">Returns size of distribution function domain.</p><pre>

inline int CDistribFun::GetNumberOfNodes() const;
</pre><p>
This function returns the size of the domain corresponding to the distribution function.
</p>


<hr><h4><a name="declCDistribFun_IsDistributionSpecific">IsDistributionSpecific</a></h4>
<p class="Blurb">Checks whether distribution is specific.</p><pre>

virtual inline int CDistribFun::IsDistributionSpecific() const = 0;
</pre><p>
This function checks whether the distribution is specific and returns:
</p>


<hr><h4><a name="decl_pnlGetStatisticalMatrix">GetStatisticalMatrix</a></h4>
<p class="Blurb">Returns statistical matrix.</p><pre>

virtual CMatrix&lt;float&gt;* CDistribFun::GetStatisticalMatrix (EStatisticalMatrixType mType,int *parentIndices = NULL ) const = 0;
</pre><p><dl>
 Arguments
<dt>mType <dd>Matrix type.
<dt>parentIndices <dd>Array of values of discrete parents.
</dl></p><p>
This function returns the pointer to the matrix attached to the factor. It identifies one of the following matrix types: <EM CLASS="CodeItalic">
stMatTable, stMatMu, stMatSigma, stMatCoeff.</EM>
</p>


<hr><h4><a name="declCDistribFun_MarginalizeData">MarginalizeData</a></h4>
<p class="Blurb">Marginalizes object.</p><pre>

virtual void CDistribFun::MarginalizeData( const CDistribFun *<EM CLASS="CodeItalic">pOldData</EM>pOldData</EM>, const int *<EM CLASS="CodeItalic">DimsOfKeep</EM>, int <EM CLASS="CodeItalic">NumDimsOfKeep</EM>, int <EM CLASS="CodeItalic">maximize</EM> ) = 0;
</pre><p><dl>
 Arguments
<dt>pOldData<dd>  Pointer to the distribution function.
<dt>DimsOfKeep<dd>  Pointer to an array of numbers of the dimensions that should constitute the domain of the returned marginalized object.
<dt>NumDimsOfKeep<dd>  Size of the returned object domain.
<dt>maximize<dd>  Flag of the marginalization type:<BR>
- for discrete variables:<BR>
&#183; 0 stands for simple summation;<BR>
&#183; 1 stands for finding maximum value.<BR>
- for continuous variables:<BR>
&#183; both are integration operations.
</dl></p><p>
This function converts the source object to a new <EM CLASS="CodeReg">
CDistributionFunction</EM>
 object that is generated either by adding or by integrating the source object referring to the nodes that do not lie in the returned object domain. The returned object domain should be a subset of the source domain.
</p>


<hr><h4><a name="declCDistribFun_MultiplyInSelfData">MultiplyInSelfData</a></h4>
<p class="Blurb">Multiplies and puts result into distribution function. </p><pre>

virtual void CDistribFun::MultiplyInSelfData( const int *<EM CLASS="CodeItalic">pBigDomain</EM>, const int *<EM CLASS="CodeItalic">pSmallDomain</EM>, const CDistribFun *<EM CLASS="CodeItalic">pOtherData</EM> ) = 0;
</pre><p><dl>
 Arguments
<dt>pBigDomain  <dd>Dimensions numbers of the domain of the larger distribution function for which the function is called.
<dt>pSmallDomain  <dd>Dimensions numbers of the domain of the smaller distribution function.
<dt>pOtherData  <dd>Reference to the multiplier of <EM CLASS="CodeReg">
CDistribFun</EM> type.
</dl></p><p>
This function changes the object, for which it is called, by changing its data matrices.
</p>


<hr><h4><a name="declCDistribFun_DivideInSelfData">DivideInSelfData</a></h4>
<p class="Blurb">Divides object.</p><pre>

virtual void CDistribFun::DivideInSelfData( const int *<EM CLASS="CodeItalic">pBigDomain</EM>, const int *<EM CLASS="CodeItalic">pSmallDomain</EM>, const CDistribFun *<EM CLASS="CodeItalic">pOtherData </EM>);
</pre><p><dl>
 Arguments
<dt>pBigDomain  <dd>Domain of the divident.
<dt>pSmallDomain  <dd>Domain of the divisor.
<dt>pOtherData  <dd>Pointer to the denominator of <EM CLASS="CodeReg">
CDistribFun</EM> type.
</dl></p><p>
This function changes the object, for which it is called, by changing its data
</p>
</pre>


<hr><h4><a name="declCDistribFun_ShrinkObservedNodes">ShrinkObservedNodes</a></h4>
<p class="Blurb">Creates new distribution function by shrinking dimensions corresponding to observed nodes.</p><pre>

virtual void CDistribFun::ShrinkObservedNodes( const CDistribFun* <EM CLASS="CodeItalic">pOldData</EM>, const int *<EM CLASS="CodeItalic">pDimsOfObserved</EM>, const Value* const* <EM CLASS="CodeItalic">pObsValues</EM>, int <EM CLASS="CodeItalic">numObsDim</EM>, const CNodeType* <EM CLASS="CodeItalic">pObsTabNT</EM>, const CNodeType* <EM CLASS="CodeItalic">pObsGauNT</EM> );
</pre><p><dl>
 Arguments
<dt>pOldData<dd>  Pointer to the source data.
<dt>pDimsOfObserved<dd>  Array of observed dimensions.
<dt>pObsValues<dd>  Array of observed values.
<dt>numObsDim<dd>  Number of observed dimensions.
<dt>pObsTabNT<dd>  Pointer to the observed Tabular node type.
<dt>pObsGauNT<dd>  Pointer to the observed Gaussian node type.
</dl></p><p>
This function creates a new distribution function with the same number of nodes as in the domain of the source distribution function but with modified observed nodes. Due to the change of values of the observed nodes the joint probability distribution changes too.
</p>


<hr><h4><a name="declCDistribFun_ExpandData">ExpandData</a></h4>
<p class="Blurb">Expands dimensions corresponding to observation.</p><pre>

virtual void CDistribFun::ExpandData( const int* <EM CLASS="CodeItalic">pDimsToExpand</EM>, int <EM CLASS="CodeItalic">numDimsToExpand</EM>, const Value* const* <EM CLASS="CodeItalic">valuesArray</EM>, const CNodeType* const *<EM CLASS="CodeItalic">allFullNodeTypes</EM>, int <EM CLASS="CodeItalic">UpdateCanonical</EM> = 1 );
</pre><p><dl>
 Arguments
<dt>pDimsToExpand<dd>  Array of dimensions to expand.
<dt>numDimsToExpand<dd>  Number of dimensions to expand.
<dt>valuesArray<dd>  Array of observed values.
<dt>allFullNoodeTypes<dd>  Array of pointers of node types of variables in the distribution.
<dt>UpdateCanonical <dd>Flag used for Gaussian distributions:<BR>
1 - updates the canonical form of the distribution,<BR>
0 - does not update the canonical form of the distribution.
</dl></p><p>
This function expands the probability distribution by filling empty spaces with zeros.
</p>


<hr><h4><a name="declCDistribFun_ClearStatisticalData">ClearStatisticalData</a></h4>
<p class="Blurb">Sets to zero all elements of matrices used in learning process.</p><pre>

virtual void CDistribFun::ClearStatisticalData() = 0;
</pre><p>
This function sets to zero all elements of the matrices which are used in the learning process.
</p>


<hr><h4><a name="declCDistribFun_StatisticalDataEM">StatisticalDataEM</a></h4>
<p class="Blurb">Updates statistical data.</p><pre>

virtual void CDistribFun::StatisticalDataEM( const CDistribFun* <A NAME="OLE_LINK1"></A><EM CLASS="CodeItalic">infData</EM>, const CEvidence *<EM CLASS="CodeItalic">pEvidence</EM> = NULL, float <EM CLASS="CodeItalic">weightingCoeff</EM> = 1.0f, const int* <EM CLASS="CodeItalic">domain</EM> = NULL ) = 0;
</pre><p><dl>
 Arguments
<dt>InfData <dd>Pointer to the distribution function inference result.
<dt>pEvidence <dd>Pointer to an <EM CLASS="CodeItalic">
Evidence</EM>
 object.
<dt>WeightingCoeff  <dd>Weighting coefficient.
<dt>domain  <dd>Domain node numbers.
</dl></p><p>
This function estimates factors and updates statistical data.
</p>


<hr><h4><a name="declCDistribFun_StatisticalDataML">StatisticalDataML</a></h4>
<p class="Blurb">Gathers statistical data.</p><pre>

virtual void CDistribFun::StatisticalDataML( const CEvidence* const* <EM CLASS="CodeItalic">pEvidences</EM>, int <EM CLASS="CodeItalic">EvidenceNumber</EM>, const int *<EM CLASS="CodeItalic">domain</EM>, float <EM CLASS="CodeItalic">weightingCoeff</EM> = 1.0f ) = 0;
</pre><p><dl>
 Arguments
<dt>pEvidences  <dd>Array of evidences.
<dt>EvidenceNumber  <dd>Number of evidences.
<dt>domain<dd>  Numbers of domain nodes.
<dt>WeightingCoeff<dd>  Weighting coefficient.
</dl></p><p>
This function estimates factors and updates statistical data.
</p>


<hr><h4><a name="declCDistribFun_SetStatistics">SetStatistics</a></h4>
<p class="Blurb">Sets statistical data.</p><pre>

virtual void CDistribFun::SetStatistics( const CMatrix&lt;float&gt;* <EM CLASS="CodeItalic">pMat</EM>, EStatisticalMatrix <EM CLASS="CodeItalic">matrixType</EM>, const int* <EM CLASS="CodeItalic">parentsComb</EM> = NULL ) = 0;
</pre><p><dl>
 Arguments
<dt>pMat  <dd>Input parameter. Matrix with statistical data.
<dt>matrixType  <dd>Type of matrix.
<dt>parentsComb<dd>  Combination of discrete parents.
</dl></p><p>
This function sets statistical data for learning.
</p>


<hr><h4><a name="declCDistribFun_GetNormalized">GetNormalized</a></h4>
<p class="Blurb">Normalizes distribution function.</p><pre>

virtual CDistribFun* CDistribFun::GetNormalized() const = 0;
</pre><p>
This function creates a new distribution function by normalizing the given distribution function.
</p>


<hr><h4><a name="declCDistribFun_ProcessingStatisticalData">ProcessingStatisticalData</a></h4>
<p class="Blurb">Updates distribution function after gathering statistical data. </p><pre>

virtual float CDistribFun::ProcessingStatisticalData( float <EM CLASS="CodeItalic">numEvidences</EM> ) = 0;
</pre><p><dl>
 Arguments
<dt>numEvidences  <dd>Number of evidences.
</dl></p><p>
This function performs factor estimation and updates the distribution function with the newly acquired statistical data.
</p>


<hr><h4><a name="declCDistribFun_CloneDistribFun">CloneDistribFun</a></h4>
<p class="Blurb">Creates replica of distribution function.</p><pre>

virtual CDistribFun* CDistribFun::CloneDistribFun() const = 0;
</pre>


<hr><h4><a name="declCDistribFun_CloneWithSharedMatrices">CloneWithSharedMatrices</a></h4>
<p class="Blurb">Creates replica of distribution function.</p><pre>

virtual CDistribFun* CDistribFun::CloneWithSharedMatrices() const = 0;
</pre><p>
This function creates a replica of the distribution function so that the newly created distribution function shares its matrices with the source distribution function.
</p>


<hr><h4><a name="declCDistribFun_GetMultipliedDelta">GetMultipliedDelta</a></h4>
<p class="Blurb">Returns delta distributions that are multiplied by given distribution.</p><pre>

virtual int CDistribFun::GetMultipliedDelta( const int **<EM CLASS="CodeItalic">positions</EM>, const float **<EM CLASS="CodeItalic">values</EM>, const int **<EM CLASS="CodeItalic">offsets</EM> ) const = 0;
</pre><p><dl>
 Arguments
<dt>positions <dd>Returned parameter. Array of positions multiplied by delta distribution.
<dt>values  <dd>Returned parameter. Mean values of delta distributions.
<dt>offsets <dd>Returned parameter. Array of offsets to next mean values.
</dl></p><p>
 Discussion</H6>
<P CLASS="Body">
</dl></p><p>
This function returns delta distributions that are multiplied by the distribution. The returned integer value is the number of positions multiplied by delta distributions.
</p>


<hr><h4><a name="decl_pnlConvertCPDDistribFunToPot">ConvertCPDDistribFunToPot</a></h4>
<p class="Blurb">Converts distribution function for CPD into distribution function for potential.</p><pre>

virtual CDistribFun CDistribFun::*ConvertCPDDistribFunToPot()const = 0;
</pre><p>
Converts the distribution function which was created for use in a Conditional Probability Distribution (CPD) into the distribution function for use in a potential.
</p>


<hr><h4><a name="decl_pnlCPD_to_pi">CPD_to_pi</a></h4>
<p class="Blurb">Computes pi message for Pearl inference.</p><pre>

virtual CDistribFun CDistribFun::*CPD_to_pi( CDistribFun *const* <EM CLASS="CodeItalic">allPiMessages</EM>, int *<EM CLASS="CodeItalic">multParentIndices</EM>, int <EM CLASS="CodeItalic">numMultNodes</EM>, int <EM CLASS="CodeItalic">posOfExceptParent</EM>, int <EM CLASS="CodeItalic">maximizeFlag</EM> = 0 )const = 0;
</pre><p><dl>
 Arguments
<dt>allPiMessages <dd>Array of all pi messages received by the current distribution.
<dt>multParentIndices <dd>Indices of parent nodes.
<dt>numMultNodes<dd>  Number of parent nodes.
<dt>posOfExceptParent <dd>Position of the parent which is not to be multiplied.
<dt>maximizeFlag  <dd>Flag of maximization in multiplication process.
</dl></p><p>
This function computes pi messages for Pearl inference.
</p>


<hr><h4><a name="decl_pnlCPD_to_lambda">CPD_to_lambda</a></h4>
<p class="Blurb">Computes lambda message for Pearl inference.</p><pre>

virtual CDistribFun CDistribFun::*CPD_to_lambda( const CDistribFun *<EM CLASS="CodeItalic">lambda</EM>, CDistribFun *const* <EM CLASS="CodeItalic">allPiMessages</EM>, int *<EM CLASS="CodeItalic">multParentIndices</EM>, int <EM CLASS="CodeItalic">numMultNodes</EM>, int <EM CLASS="CodeItalic">posOfExceptNode</EM>, int <EM CLASS="CodeItalic">maximizeFlag</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>lambda  <dd>Received Lambda message.
<dt>allPiMessages <dd>Array of all pi messages received by the current distribution.
<dt>multParentIndices<dd>  Indices of parent nodes.
<dt>numMultNodes  <dd>Number of parent nodes.
<dt>posOfExceptNode <dd>Position of the parent that is not to be multiplied.
<dt>maximizeFlag<dd>  Flag of maximisation in multiplication process.
</dl></p>


<hr><h4><a name="declCDistribFun_Normalize">Normalize</a></h4>
<p class="Blurb">Normalizes distribution function.</p><pre>

virtual CDistribFun* CDistribFun::Normalize();
</pre><p>
This function normalizes distribution function.
</p>


<hr><h4><a name="declCDistribFun_GetDistributionType">GetDistributionType</a></h4>
<p class="Blurb">Returns distribution type.</p><pre>

EDistributionType CDistribFun::GetDistributionType() const;
</pre><p>
This function returns one of the following distribution types: <EM CLASS="CodeItalic">dtTabular</EM>, <EM CLASS="CodeItalic">dtGaussian</EM> or <EM CLASS="CodeItalic">dtCondGaussian</EM>.
</p>


<hr><h4><a name="declCDistribFun_IsEqual">IsEqual</a></h4>
<p class="Blurb">Compares distributions.</p><pre>

virtual int CDistribFun::IsEqual( const CDistribFun *<EM CLASS="CodeItalic">dataToCompare</EM>, float <EM CLASS="CodeItalic">epsilon</EM>, int <EM CLASS="CodeItalic">withCoeff</EM> = 1) const = 0;
</pre><p><dl>
 Arguments
<dt>dataToCompare <dd>Pointer to the distribution function for comparison.
<dt>epsilon <dd>Float value of accuracy to compare.
<dt>WithCoeff <dd>Flag of the type of comparison. Normalizing constants for Gaussian and Conditional Gaussian distribution are compared if it is equal to 0.
</dl></p><p>
This function returns 1 if the compared distributions are of the same size, type and have the same floating point matrices, returns 0 otherwise.
</p>


<hr><h4><a name="declCDistribFun_GetMPE">GetMPE</a></h4>
<p class="Blurb">Returns maximum probability explanation.</p><pre>

virtual CNodeValues* CDistribFun::GetMPE() = 0;
</pre><p>
This function returns maximum probability explanation of the distribution function.
</p>


<hr><h4><a name="declCDistribFun_ConvertToSparse">ConvertToSparse</a></h4>
<p class="Blurb">Converts distribution with dense matrices into distribution with sparse matrices.</p><pre>

virtual CDistribFun* CDistribFun::ConvertToSparse() const = 0;
</pre><p>
This function converts the distribution with dense matrices into the distribution with sparse matrices.
</p>


<hr><h4><a name="declCDistribFun_ConvertToDense">ConvertToDense</a></h4>
<p class="Blurb">Converts distribution with sparce matrices into distribution with dense matrices.</p><pre>

virtual CDistribFun* CDistribFun::ConvertToDense() const = 0;
</pre><p>
This function converts the distribution with sparse matrices into the distribution with dense matrices.
</p>


<hr><h4><a name="declCDistribFun_IsSparse">IsSparse</a></h4>
<p class="Blurb">Checks if distribution matrices are sparce.</p><pre>

virtual int CDistribFun::IsSparse() const = 0;
</pre><p>
This function checks if the matrices of the distribution are sparce.
</p>


<hr><h4><a name="declCDistribFun_IsDense">IsDense</a></h4>
<p class="Blurb">Checks if distribution matrices are dense.</p><pre>

virtual int CDistribFun::IsDense() const = 0;
</pre><p>
This function checks if the matrices of the distribution are dense.
</p>


<hr><h4><a name="declCDistribFun_ResetNodeTypes">ResetNodeTypes</a></h4>
<p class="Blurb">Replaces node types of model domain by node types of distribution function.</p><pre>

inline void CDistribFun::ResetNodeTypes( pConstNodeTypeVector &amp;<EM CLASS="CodeItalic">nodeTypes</EM> );
</pre><p><dl>
 Arguments
<dt>nodeTypes <dd>Array of <EM CLASS="CodeReg">CNodeTypes</EM> objects.
</dl></p><p>
This function replaces node types of the model domain by identical node types from another model domain.
</p>


<hr><h4><a name="declCDistribFun_CreateDefaultMatrices">CreateDefaultMatrices</a></h4>
<p class="Blurb">Allocates default matrices to distribution function.</p><pre>

virtual void CDistribFun::CreateDefaultMatrices( int <EM CLASS="CodeItalic">isRandom</EM> = 1 );
</pre><p><dl>
 Arguments
<dt>isRandom  <dd>Type of matrix data.
</dl></p><p>
This function creates default matrices and allocates them to the distribution function.
</p>


<hr><h4><a name="declCDistribFun_GetMatricesValidityFlag">GetMatricesValidityFlag</a></h4>
<p class="Blurb">Checks validity of matrices.</p><pre>

inline bool CDistribFun::GetMatricesValidityFlag() const;
</pre>


<hr><h4><a name="declCDistribFun_Dump">Dump</a></h4>
<p class="Blurb">Dumps content of object.</p><pre>

virtual void CDistribFun::Dump() const = 0;
</pre>



<hr><h3><a name="decl_pnlClassCTabularDistribFun">Class CTabularDistribFun</a></h3>




<hr><h4><a name="declCTabularDistribFun_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CTabularDistribFun* CTabularDistribFun::Create( int <EM CLASS="CodeItalic">NodeNumber</EM>, const CNodeType *const* <EM CLASS="CodeItalic">NodeTypes</EM>, const float *<EM CLASS="CodeItalic">data, </EM><EM CLASS="CodeReg">int</EM><EM CLASS="CodeItalic"> allocMatrices </EM>= 0<EM CLASS="CodeItalic">, </EM>int<EM CLASS="CodeItalic"> asDense = </EM>-1<EM CLASS="CodeItalic"> </EM> );
</pre><p><dl>
 Arguments
<dt>NodeNumber  <dd>Number of nodes in the domain.
<dt>NodeTypes <dd>Pointer to the array of <EM CLASS="CodeReg">CNodeTypes</EM> of the nodes in the domain.
<dt>data  <dd>Pointer to the array of float values of probabilities.
<dt>allocMatrices <dd>Flag of matrix allocation.
<dt>asDense <dd>Type of the martix created.
</dl></p><p>
This function creates a class object.
</p>


<hr><h4><a name="decl_pnlCreateUnitFunctionDistribution">CreateUnitFunctionDistribution</a></h4>
<p class="Blurb">Creates unit-function distribution.<DIV>
static CTabularDistribFun* CTabularDistribFun::CreateUnitFunctionDistribution ( int <EM CLASS="CodeItalic">NumberOfNodes</EM>, const CNodeType *const*<EM CLASS="CodeItalic">nodeTypes</EM>, int <EM CLASS="CodeItalic">asDense</EM> = 1 );
</pre><p><dl>
 Arguments
<dt>NumberOfNodes <dd>Number of nodes in the domain.
<dt>nodeTypes <dd>Pointer to the array of <EM CLASS="CodeItalic">CNodeTypes</EM> of the domain nodes.
<dt>asDense <dd>Distribution function with dense matrices.
</dl></p><p>
This function creates a class object in the form of a unit-function distribution.
</p>


<hr><h4><a name="declCTabularDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates class object by copying input object.</p><pre>

static CTabularDistribFun* CTabularDistribFun::Copy(const CTabularDistribFun* pInpDistr );
</pre>


<hr><h4><a name="declCTabularDistribFun_BayesUpdateFactor">BayesUpdateFactor</a></h4>
<p class="Blurb">Updates statistical data.</p><pre>

void CTabularDistribFun::BayesUpdateFactor( const CEvidence* const* <EM CLASS="CodeItalic">pEvidences</EM>, int <EM CLASS="CodeItalic">nEv</EM>, const int* <EM CLASS="CodeItalic">domain</EM> );
</pre><p><dl>
 Arguments
<dt>pEvidences  <dd>Array of evidences<EM CLASS="CodeItalic">.</EM>
<dt>nEv <dd>Number of evidences<EM CLASS="CodeItalic">.</EM>
<dt>domain  <dd>Array of nodes<EM CLASS="CodeItalic">.</EM>
</dl></p><p>
This function updates statistical data by using priors.
</p>


<hr><h4><a name="decl_pnlPriorToCPD">PriorToCPD</a></h4>
<p class="Blurb">Converts pseudo counts to probability.</p><pre>
void CTabularDistribFun::PriorToCPD();
</pre>


<hr><h4><a name="declCTabularDistribFun_CPDToPi">CPDToPi</a></h4>
<p class="Blurb">Computes pi message for Pearl inference.</p><pre>

void CTabularDistribFun::CPDToPi( CDistribFun *const* <EM CLASS="CodeItalic">allPiMessages</EM>, int *<EM CLASS="CodeItalic">multParentIndices</EM>, int <EM CLASS="CodeItalic">numMultNodes</EM>, int <EM CLASS="CodeItalic">posOfExceptParent</EM>, int <EM CLASS="CodeItalic">maximizeFlag</EM> = 0 ) const;
</pre><p><dl>
 Arguments
<dt>allPiMessages <dd>Array of all pi messages received by the current distribution.
<dt>multParentIndices <dd>Indices of parent nodes.
<dt>numMultNodes<dd>  Number of parent nodes.
<dt>posOfExceptParent <dd>Position of the parent which is not to be multiplied.
<dt>maximizeFlag  <dd>Flag of maximization in multiplication process.
</dl></p><p>
This function computes pi messages for Pearl inference.
</p>


<hr><h4><a name="declCTabularDistribFun_CPDToLambda">CPDToLambda</a></h4>
<p class="Blurb">Computes lambda message for Pearl inference.</p><pre>

void CTabularDistribFun::CPDToLambda( const CDistribFun *<EM CLASS="CodeItalic">lambda</EM>, CDistribFun *const* <EM CLASS="CodeItalic">allPiMessages</EM>, int *<EM CLASS="CodeItalic">multParentIndices</EM>, int <EM CLASS="CodeItalic">numMultNodes</EM>, int <EM CLASS="CodeItalic">posOfExceptNode</EM>, int <EM CLASS="CodeItalic">maximizeFlag</EM> = 0 ) const;
</pre><p><dl>
 Arguments
<dt>lambda  <dd>Received Lambda message.
<dt>allPiMessages <dd>Array of all pi messages received by the current distribution.
<dt>multParentIndices<dd>  Indices of parent nodes.
<dt>numMultNodes  <dd>Number of parent nodes.
<dt>posOfExceptNode <dd>Position of the parent that is not to be multiplied.
<dt>maximizeFlag<dd>  Flag of maximisation in multiplication process.
</dl></p><p>
This function computes lambda message for Pearl inference.
</p>


<hr><h4><a name="declCTabularDistribFun_IsMatrixNormalizedForCPD">IsMatrixNormalizedForCPD</a></h4>
<p class="Blurb">Checks if martix is normalized for CPD.</p><pre>

bool CTabularDistribFun::IsMatrixNormalizedForCPD( float <EM CLASS="CodeItalic">eps</EM> = 1e-5f ) const;
</pre><p><dl>
 Arguments
<dt>eps <dd>Accuracy<EM CLASS="CodeItalic">.</EM>
</dl></p><p>
This function checks if the matirx is normalized for CPD.

<hr><h4><a name="declCTabularDistribFun_MarginalizeData">MarginalizeData</a></h4>
</p><p class="Blurb">Marginalizes object.</p><pre>

virtual void CTabularDistribFun::MarginalizeData( const CDistribFun *<EM CLASS="CodeItalic">pOldData</EM>,  const int *<EM CLASS="CodeItalic">DimsOfKeep</EM>, int <EM CLASS="CodeItalic">NumDimsOfKeep</EM>, int <EM CLASS="CodeItalic">maximize</EM> ) = 0;
</pre><p><dl>
 Arguments
<dt>pOldData<dd>  Pointer to the distribution function.
<dt>DimsOfKeep<dd>  Pointer to an array of numbers of the dimensions that should constitute the domain of the returned marginalized object.
<dt>NumDimsOfKeep<dd>  Size of the returned object domain.
<dt>maximize<dd>  Flag of the marginalization type.<BR>
For discrete variables:<BR>
&#183; 0 stands for simple summation<BR>
&#183; 1 stands for finding maximum value.<BR>
For continuous variables:<BR>
&#183; both are integration operations.
</dl></p><p>
This function marginalizes the source object. The object is marginalized in itself and thus should have an appropriate size.
</p>


<hr><h3><a name="decl_pnlClassCGaussianDistribFun">Class CGaussianDistribFun</a></h3>

<IMG SRC="fig/PNLMarch.book-112.gif">


<hr><h4><a name="declCGaussianDistribFun_CreateInMomentForm">CreateInMomentForm</a></h4>
<p class="Blurb">Creates class object in moment form.</p><pre>

static CGaussianDistribFun* CGaussianDistribFun::CreateInMomentForm( int <EM CLASS="CodeItalic">isPot</EM>, int <EM CLASS="CodeItalic">NumberOfNodes</EM>, const CNodeType *const* <EM CLASS="CodeItalic">NodeTypes</EM>, const float *<EM CLASS="CodeItalic">dataMean</EM>, const float *<EM CLASS="CodeItalic">dataCov</EM>, const float **<EM CLASS="CodeItalic">dataWeight</EM> = NULL );
</pre><p><dl>
 Arguments
<dt>isPot<dd>  Flag of the desired Gaussian distribution use:
1 - distribution is created for use in potential
0 - distribution is created for use in CPD.
<dt>NumberOfNodes<dd>  Number of nodes in the domain.
<dt>NodeTypes <dd>Pointer to the array of <EM CLASS="CodeItalic">CNodeTypes</EM> of nodes in the domain.
<dt>dataMean  <dd>Pointer to the array of float values of data for matrix mean.
<dt>dataCov <dd>Pointer to the array of float values of data for covariance matrix.
<dt>dataWeight  <dd>Pointers to weights of distributions.
</dl></p><p>
This function creates CGaussianDistribFun class object in the moment form.
</p>


<hr><h4><a name="declCGaussianDistribFun_CreateInCanonicalForm">CreateInCanonicalForm</a></h4>
<p class="Blurb">Returns  class object in canonical form.</p><pre>

static CGaussianDistribFun* CGaussianDistribFun::CreateInCanonicalForm( int <EM CLASS="CodeItalic">numberOfNodes</EM>, const CNodeType *const* <EM CLASS="CodeItalic">nodeTypes</EM>, const float *<EM CLASS="CodeItalic">dataH</EM>, const float *<EM CLASS="CodeItalic">dataK</EM>, float <EM CLASS="CodeItalic">g</EM> = 0.0f );
</pre><p><dl>
 Arguments
<dt>numberOfNodes <dd>Number of nodes in domain.
<dt>nodeTypes <dd>Pointer to the array of <EM CLASS="CodeItalic">CNodeTypes </EM>of nodes in domain.
<dt>dataH <dd>Pointer to the array of float values of data for matrix H.
<dt>dataK <dd>Pointer to the array of float values of data for matrix K.
<dt>g <dd>Float value of normalisation constant in the canonical form.
</dl></p><p>
This function creates a CGaussianDistribFun object in the canonical form.
</p>


<hr><h4><a name="declCGaussianDistribFun_CreateDeltaDistribution">CreateDeltaDistribution</a></h4>
<p class="Blurb">Creates class object of special form.</p><pre>

static CGaussianDistribFun* CGaussianDistribFun::CreateDeltaDistribution( int <EM CLASS="CodeItalic">numberOfNodes</EM>, const CNodeType *const* <EM CLASS="CodeItalic">nodeTypes</EM>, const float *<EM CLASS="CodeItalic">dataMean</EM>, int <EM CLASS="CodeItalic">isMoment</EM> = 1 );
</pre><p><dl>
 Arguments
<dt>numberOfNodes <dd>Number of nodes in the domain.
<dt>nodeTypes <dd>Pointer to the array of <EM CLASS="CodeReg">
CNodeTypes</EM>
 of nodes in the domain.
<dt>dataMean  <dd>Pointer to the array of float values of data for matrix mean.
<dt>isMoment  <dd>Flag of the desired form of Gaussian distribution:<BR>
1 - moment form,<BR>
0 - canonical form.
</dl></p><p>
This function creates a class object of the special form.
</p>


<hr><h4><a name="decl_pnlCreateUnitFunctionDistribution">CreateUnitFunctionDistribution</a></h4>
<p class="Blurb">Creates class object of special form.</p><pre>

static CGaussianDistribFun* CGaussianDistribFun::CreateUnitFunctionDistribution ( int <EM CLASS="CodeItalic">numberOfNodes</EM>, const CNodeType *const*<EM CLASS="CodeItalic">nodeTypes</EM>, int <EM CLASS="CodeItalic">isPotential</EM> = 1, int <EM CLASS="CodeItalic">isCanonical</EM> = 1);
</pre><p><dl>
 Arguments
<dt>numberOfNodes <dd>Number of nodes in the domain.
<dt>nodeTypes <dd>Pointer to the array of <EM CLASS="CodeItalic">
CNodeTypes</EM>
 of nodes in the domain.
<dt>isPotential<dd>  Flag of the desired use of the Gaussian distribution:<BR>
1 - distribution is created for use in potential,<BR>
0 - distribution is created for use in CPD
<dt>isCanonical <dd>Flag of the desired form of Gaussian distribution:<BR>
0 - moment form,<BR>
1 - canonical form.
</dl></p><p>
This function creates a class object of the special form.
</p>


<hr><h4><a name="declCGaussianDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates replica of given class object.</p><pre>

static CGaussianDistribFun* CGaussianDistribFun::Copy( const CGaussianDistribFun* <EM CLASS="CodeItalic">pInpDistr</EM> );
</pre><p><dl>
 Arguments
<dt>pInpDistr <dd>Pointer to the <EM CLASS="CodeReg">CGaussianDistribFun</EM> object to be copied.
</dl></p><p>
This function creates a new CGaussianDistribFun class object by means of copying the input object.
</p>


<hr><h4><a name="declCGaussianDistribFun_CheckMomentFormValidity">CheckMomentFormValidity</a></h4>
<p class="Blurb">Checks if function is valid in moment form.</p><pre>

int CGaussianDistribFun::CheckMomentFormValidity();
</pre>


<hr><h4><a name="declCGaussianDistribFun_CheckCanonicalFormValidity">CheckCanonicalFormValidity</a></h4>
<p class="Blurb">Checks if function is valid in canonical form.</p><pre>

int CGaussianDistribFun::CheckCanonicalFormValidity();
</pre>


<hr><h4><a name="declCGaussianDistribFun_GetCanonicalFormFlag">GetCanonicalFormFlag</a></h4>
<p class="Blurb">Checks if distribution function is canonical.</p><pre>

inline int CGaussianDistribFun::GetCanonicalFormFlag() const;
</pre><p>
This function checks if the function is canonical. The function returns 1 if the distribution function is canonical, returns 0 otherwise.
</p>


<hr><h4><a name="declCGaussianDistribFun_GetMomentFormFlag">GetMomentFormFlag</a></h4>
<p class="Blurb">Checks if distribution function is in moment form.</p><pre>

Inline int CGaussianDistribFun::GetMomentFormFlag() const;
</pre><p>
This function returns 1 if the distribution function is in moment form, returns 0 otherwise.
</p>


<hr><h4><a name="declCGaussianDistribFun_SetCoefficient">SetCoefficient</a></h4>
<p class="Blurb">Sets normalization coefficient.</p><pre>

void CGaussianDistribFun::SetCoefficient( float <EM CLASS="CodeItalic">coeff</EM>, int <EM CLASS="CodeItalic">isCanonical</EM> = 1);
</pre><p><dl>
 Arguments
<dt>coeff <dd>Coefficient value<EM CLASS="CodeItalic">.</EM>
<dt>isCanonical <dd>Flag of distribution form<EM CLASS="CodeItalic">.</EM>
</dl></p><p>
This function sets the normalization coefficient for the Gaussian distribution.
</p>


<hr><h4><a name="declCGaussianDistribFun_GetFactorFlag">GetFactorFlag</a></h4>
<p class="Blurb">Checks if function is for use in potential.</p><pre>

inline int CGaussianDistribFun::GetFactorFlag() const;
</pre>


<hr><h4><a name="declCGaussianDistribFun_UpdateMomentForm">UpdateMomentForm</a></h4>
<p class="Blurb">Updates moment form of distribution function.</p><pre>

void CGaussianDistribFun::UpdateMomentForm();
</pre>


<hr><h4><a name="declCGaussianDistribFun_UpdateCanonicalForm">UpdateCanonicalForm</a></h4>
<p class="Blurb">Updates canonical form of distribution function.</p><pre>

void CGaussianDistribFun::UpdateCanonicalForm();
</pre>


<hr><h4><a name="declCGaussianDistribFun_CoputeProbability">CoputeProbability</a></h4>
<p class="Blurb">Computes probability of data setting.</p><pre>

double CGaussianDistribFun::CoputeProbability( const C2DNumericDenseMatrix&lt;float&gt;* <EM CLASS="CodeItalic">pMatVariable</EM>, int <EM CLASS="CodeItalic">asLog</EM> = 1, int <EM CLASS="CodeItalic">numObsParents</EM> = 0, const int* <EM CLASS="CodeItalic">obsParentsIndices</EM> = NULL, C2DNumericDenseMatrix&lt;float&gt;* const* <EM CLASS="CodeItalic">pObsParentsMats</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>pMatVariable  <dd>Pointer to the matrix with the given data.
<dt>asLog <dd>Flag of taking the logarithm.
<dt>numObsParents <dd>Number of observed parents.
<dt>obsParentsIndices <dd>Indices.
<dt>pObsParentsMats <dd>Matrices with the given data<EM CLASS="CodeItalic">.</EM>
</P>
</dl></p><p>
This function computes likelihood of the given data.
</p>


<hr><h3><a name="decl_pnlClassCConsGaussianDistribFun">Class CCondGaussianDistribFun</a></h3>

<IMG SRC="fig/PNLMarch.book-113.gif">



<hr><h4><a name="declCCondGaussianDistribFun_Create">Create</a></h4>
<p class="Blurb">Returns CCondGaussianDistribFun class object in moment form.</p><pre>

static CCondGaussianDistribFun* CCondGaussianDistribFun::Create( int <EM CLASS="CodeItalic">isPot</EM>, int <EM CLASS="CodeItalic">nNodes</EM>, const CNodeType *const* <EM CLASS="CodeItalic">nodeTypes</EM>, int <EM CLASS="CodeItalic">asDenseMatrix</EM> = 1, CGaussianDistribFun* const <EM CLASS="CodeItalic">pDefaultDistr</EM> = NULL );
</pre><p><dl>
 Arguments
<dt>isPot <dd>Flag of the desired use of the Gaussian distribution:<BR>
1 - distribution is created for use in potential,<BR>
0 - distribution is created for use in CPD.
<dt>nNodes  <dd>Number of nodes in the domain.
<dt>nodeTypes <dd>Pointer to the array of <EM CLASS="CodeItalic">
CNodeTypes</EM>
 of nodes in the domain.
<dt>asDenseMatrix <dd>Flag of the desired form of matrices of Gaussian distribution:<BR>
1 - dense<BR>
0 - sparse.
<dt>pDefaultDistr <dd>Pointer to the Gaussian distribution, if it is used for all combinations of parents with the same matrices.
</dl></p>


<hr><h4><a name="declCCondGaussianDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates class object by copying input object.</p><pre>

static CCondGaussianDistribFun* CCondGaussianDistribFun::Copy( const CCondGaussianDistribFun* <EM CLASS="CodeItalic">pInputDistr</EM> );
</pre><p><dl>
 Arguments
<dt>pInpDistr <dd>Pointer to CCondGaussianDistribFun object.
</dl></p><p>
This function creates a new <EM CLASS="CodeReg">CCondGaussianDistribFun </EM>class object by copying the input object.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_EnterDiscreteEvidence">EnterDiscreteEvidence</a></h4>
<p class="Blurb">Enters discrete evidence and creates new distribution function.</p><pre>

CCondGaussianDistribFun* CCondGaussianDistribFun::EnterDiscreteEvidence( int <EM CLASS="CodeItalic">nDiscrObsNodes</EM>, const int* <EM CLASS="CodeItalic">discrObsNodes</EM>, const int *<EM CLASS="CodeItalic">discrValues</EM>, const CNodeType* <EM CLASS="CodeItalic">pObsTabNodeType</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nDiscrObsNodes  <dd>Number of discrete observed nodes.
<dt>discrObsNodes <dd>Positions of discrete observed nodes.
<dt>discrValues <dd>Array of discrete values.
<dt>pObsTabNodeType <dd>Pointer to the observed Tabular node type.
</dl></p><p>
This function creates a new distribution function entering discrete evidence.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_EnterFullContinuousEvidence">EnterFullContinuousEvidence</a></h4>
<p class="Blurb">Enters continuous evidence and creates new tabular distribution.</p><pre>

CTabularDistribFun* CCondGaussianDistribFun::EnterFullContinuousEvidence( int <EM CLASS="CodeItalic">nContObsParents</EM>, const int* <EM CLASS="CodeItalic">contObsParentsIndices</EM>, const C2DNumericDenseMatrix&lt;float&gt;* <EM CLASS="CodeItalic">obsChildValue</EM>, C2DNumericDenseMatrix&lt;float&gt;* const* <EM CLASS="CodeItalic">obsValues</EM>, const CNodeType* <EM CLASS="CodeItalic">pObsGauNodeType</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nContObsParents <dd>Number of observed continuous parents.
<dt>contObsParentsIndices<dd>  Positions of observed continuous parents.
<dt>obsChildValue <dd>Value of the observed child node.
<dt>obsValues   <dd>Array of values of observed parents.
<dt>pObsGauNodeType <dd>Pointer to the observed Gaussian node type.
</dl></p><p>
Creates a new tabular distribution by means of entering continuous evidence.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_GetDiscreteParentsIndices">GetDiscreteParentsIndices</a></h4>
<p class="Blurb">Returns discrete parent indices.</p><pre>

inline void CCondGaussianDistribFun::GetDiscreteParentsIndices( intVector* const <EM CLASS="CodeItalic">discrParents</EM> ) const;
</pre><p><dl>
 Arguments
<dt>discrParents  <dd>Output parameter.Node numbers of discrete parents in the domain.
</dl></p><p>
This function returns indices of discrete parents.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_GetContinuousParentsIndices">GetContinuousParentsIndices</a></h4>
<p class="Blurb">Returns continuous parent indices.</p><pre>

inline void CCondGaussianDistribFun::GetContinuousParentsIndices( intVector* const <EM CLASS="CodeItalic">contParents</EM> ) const;
</pre><p><dl>
 Arguments
<dt>contParents <dd>Output parameter.Node numbers of continuous parents in the domain.
</dl></p><p>
This function returns indices of continuous parents.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_GetMatrixWithDistribution">GetMatrixWithDistribution</a></h4>
<p class="Blurb">Returns matrix with Gaussian distribution function. </p><pre>

inline CMatrix&lt;CGaussianDistribFun*&gt;* CCondGaussianDistribFun::GetMatrixWithDistribution();
</pre><p>
This function returns the coefficient for the input parent combination of the Gaussian distribution.
</p>

<hr><h4><a name="declCCondGaussianDistribFun_SetCoefficient">SetCoefficient</a></h4>
<p class="Blurb">Sets normalization coefficient.</p><pre>

void CCondGaussianDistribFun::SetCoefficient( float <EM CLASS="CodeItalic">coeff</EM>, int <EM CLASS="CodeItalic">isCanonical</EM>,const int* <EM CLASS="CodeItalic">pParentCombination</EM> );
</pre><p><dl>
 Arguments
<dt>coeff <dd>Coefficient to be set.
<dt>isCanonical <dd>Flag of the distribution form.
<dt>pParentCombination  <dd>Pointer to the combination of discrete parents.
</dl></p><p>
This function sets normalization coefficient.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_GetCoefficient">GetCoefficient</a></h4>
<p class="Blurb">Gets value of normalization coefficient.</p><pre>

float CCondGaussianDistribFun::GetCoefficient( int <EM CLASS="CodeItalic">isCanonical</EM>, const int* <EM CLASS="CodeItalic">pParentCombination</EM> );
</pre><p><dl>
 Arguments
<dt>isCanonical <dd>Flag of distribution form.
<dt>pParentCombination  <dd>Pointer to combination of parents.
</dl></p><p>
This function gets the value of the normalization coefficient.
</p>


<hr><h4><a name="declCCondGaussianDistribFun_GetMatrixNumEvidences">GetMatrixNumEvidences</a></h4>
<p class="Blurb">Returns matrix with number of evidences of discrete parents.</p><pre>

inline CDenseMatrix&lt;float&gt;* CCondGaussianDistribFun::GetMatrixNumEvidences();
</pre>

<hr><h4><a name="declCCondGaussianDistribFun_Dump">Dump</a></h4>
<p class="Blurb">Dumps content of object.</p><pre>

void CCondGaussianDistribFun::Dump();
</pre>


<hr><h3><a name="decl_pnlClassCScalarDistribFun">Class CScalarDistribFun</a></h3>


<IMG SRC="fig/PNLMarch.book-114.gif">


<hr><h4><a name="declCScalarDistribFun_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CScalarDistribFun* CScalarDistribFun::Create( int <EM CLASS="CodeItalic">NodeNumber</EM>, const CNodeType *const* <EM CLASS="CodeItalic">NodeTypes</EM>, int <EM CLASS="CodeItalic">asDense</EM> = 1 );
</pre><p><dl>
 Arguments
<dt>NodeNumber  <dd>Number of nodes.
<dt>NodeTypes <dd>Array of node types.
<dt>asDense <dd>Flag.
</dl></p><p>
This function creates a class object.
</p>

<hr><h4><a name="declCScalarDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates replica of input object.</p><pre>

static CScalarDistribFun* CScalarDistribFun::Copy( const CScalarDistribFun *<EM CLASS="CodeItalic">pInpDistr</EM> );
</pre><p><dl>
 Arguments
<dt>pInpDistr <dd>Pointer to the input distribution.
</dl></p><p>
This function creates a replica of the input object.
</p>

<hr><h4><a name="declCScalarDistribFun_Dump">Dump</a></h4>
<p class="Blurb">Dumps content of object.</p><pre>

void CScalarDistribFun::Dump();
</pre>


<hr><h3><a name="decl_pnlClassCTreeDistribFun">Class CTreeDistribFun</a></h3>


<IMG SRC="fig/PNLMarch.book-115.gif">


<hr><h4><a name="declTreeDistribFun_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CTreeDistribFun* TreeDistribFun::Create( int <EM CLASS="CodeItalic">nodeNumber</EM>, const CNodeType *const* <EM CLASS="CodeItalic">nodeTypes</EM>, const SCARTParams* <EM CLASS="CodeItalic">params</EM> = 0);
</pre><p><dl>
 Arguments
<dt>nodeNumber  <dd>Number of nodes in the domain.
<dt>nodeTypes<dd>  Pointer to the array of <EM CLASS="CodeItalic">CNodeTypes</EM> nodes in the domain.
<dt>params  <dd>Parameters for underlying CART. The value <EM CLASS="CodeReg">NULL</EM> sets the parameter to default values.
</dl></p><p>
This function creates a class<EM CLASS="CodeReg"> </EM>object.
</p>


<hr><h4><a name="declTreeDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates class object by copying input object.</p><pre>

static CTreeDistribFun * TreeDistribFun::Copy(  const CTreeDistribFun * <EM CLASS="CodeItalic">pInputDistr</EM> );
</pre><p><dl>
 Arguments
<dt>pInputDistr <dd>Pointer to the input distribution.
</dl></p><p>
This function creates a new class object by copying the input object.
</p>


<hr><h4><a name="declTreeDistribFun_Copy">UpdateTree</a></h4>
<p class="Blurb">Updates decision Tree structure for node distribution function.</p>
 
<pre>void UpdateTree(const CGraph* pGraphTree, TreeNodeFields *fields);</pre>
  
<p><dl>
 Arguments 
<dt>pGraphTree <dd>Pointer to the class CGraph that will be used for creation a new decision tree. 
<dt>fields <dd>Pointer to the array of the new decision Tree nodes properties. 
</dl></p>
 
<hr><h4><a name="declTreeDistribFun_ConvertGraphToTree">ConvertGraphToTree</a></h4>
<p class="Blurb">Creates new decision Tree structure without filling tree nodes properties.</p>
 
<pre>void ConvertGraphToTree(CxCART *pCart,CxCARTNode *node, const CGraph *pGraph, 
	int nodeNum) const;
</pre>
<p></dl>  
 Arguments 
<dt>pCart <dd>Pointer to the structure that allows storing decision Tree. 
<dt>node <dd>Pointer to the stucture that allows storing tree node properties. 
<dt>pGraph <dd>Pointer to the class CGraph that will be used for creation a new decision tree. 
<dt>nodeNum <dd>Current added node number. 
 

<hr><h4><a name="declTreeDistribFun_FillTree">FillTree</a></h4>
<p class="Blurb">Fills tree nodes properties.</p>

<pre>void FillTree(CxCART *pCart,CxCARTNode *node, const CGraph *pGraph, 
	TreeNodeFields *fields, int nodeNum) const;
</pre>
<p><dl>  
 Arguments 
<dt>pCart <dd>Pointer to the structure that allows storing decision Tree. 
<dt>node <dd>Pointer to the stucture that allows storing tree node properties. 
<dt>pGraph <dd>Pointer to the class CGraph that will be used for creation a new decision tree. 
<dt>fields <dd>Pointer to the array of the new decision Tree nodes properties. 
<dt>nodeNum <dd>Current added node number. 
</dl></p>


<hr><h4><a name="declTreeDistribFun_FillTree">SetDomain</a></h4>
<p class="Blurb">Allows to define parents for current node.</p>
 
<pre>void SetDomain(intVector domain );</pre>
<p><dl>  
 Arguments 
<dt>domain  <dd>Node domain. 
</dl></p> 


<hr><h4><a name="declTreeDistribFun_GenerateSample">GenerateSample</a></h4>
<p class="Blurb">Generates sample using current evidence.</p>
 
<pre>void GenerateSample(CEvidence* evidence, int maximize) const;</pre>
  
<p><dl>
Arguments 
<dt>evidence <dd>Pointer to the current decision Tree parents evidence. 
<dt>maximize <dd> <pre>Flag of the marginalization type: 
	for discrete variables: 
		0 stands for simple summation. 
		1 stands for finding maximum value. 
	for continuous variables: 
		both are integration operations..  </pre>
</dl></p> 
 

<hr><h4><a name="declTreeDistribFun_GetAdjectives">GetAdjectives</a></h4>
<p class="Blurb">In continuous case returns correspound expectation and covariance using current evidence.</p>
 
<pre>int GetAdjectives(const CEvidence* pEv, float &expect, float &varian) const;</pre>
  
<p><dl>
 Arguments 
<dt>pEv <dd>Pointer to the current decision Tree parents evidence. 
<dt>expect <dd>decision Tree node expectation for current parents configuraion. 
<dt>varian <dd>decision Tree node variance for current parents configuraion.. 
</dl></p> 
 

<hr><h4><a name="declTreeDistribFun_GetAdjectives">GetProbability</a></h4>
<p class="Blurb">In discrete case returns correspound probability vector using current evidence.</p>
 
<pre>floatVector GetProbability(const CEvidence* pEv) const;</pre>
  
<p><dl>
 Arguments 
<dt>pEv <dd>Pointer to probability vector for current evidence. 
</dl></p> 
 
<hr><h3><a name="decl_pnlClassCSoftMaxDistribFun">Class CSoftMaxDistribFun</a></h3>
<p>Class CSoftMaxDistribFun implements basic operations wiht distribution on SoftMax node when it has only continuous parents. In this case distribution can de defined by one matrix of weights and one offset vector.
</p>

<hr><h4><a name="declSoftMaxDistribFun_Clone">Clone</a></h4>
<p class="Blurb">Clones SoftMaxDistribFun object and return pointer to it.</p>
<pre>CDistribFun* Clone();</pre>

<hr><h4><a name="declSoftMaxDistribFun_Create">Create</a></h4>
<p class="Blurb">Returns class object</p>
 
<pre>CSoftMaxDistribFun* Create(int NumberOfNodes, const CNodeType *const* NodeTypes, 
	const float *dataWeight, const float *dataOffset)
</pre>  

<p><dl>
 Arguments 
<dt>NumberOfNodes <dd>Quantity of SoftMax node parents 
<dt>NodeTypes <dd>Pointer to the array of parent nodes types. 
<dt>dataWeight <dd>Pointer to float matrix of SoftMax node weights. 
<dt>dataOffset <dd>Pointer to float vector of SoftMax node offsets. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_CreateUnitFunctionDistribution">CreateUnitFunctionDistribution</a></h4>
<p class="Blurb">Creates unit form of distribution.</p>
 
<pre>CSoftMaxDistribFun* CreateUnitFunctionDistribution(int NumberOfNodes, 
	const CNodeType *const* NodeTypes);
</pre>
<p><dl>
 Arguments 
<dt>NumberOfNodes <dd>Quantity of SoftMax node parents 
<dt>NodeTypes <dd>Pointer to the array of parent nodes types. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates a copy of an input object and returns a pointer to it.</p>
 
<pre>CSoftMaxDistribFun* Copy(const CSoftMaxDistribFun* pInpDistr);</pre>
  
<p><dl>
 Arguments 
<dt>pInpDistr <dd>Pointer to the SoftMaxDistribFun object. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_IsValid">IsValid</a></h4>
<p class="Blurb">Checks weather this distribution is a unit distribution.</p>
 
<pre>bool IsValid(std::string* description) const;</pre>
  
<p><dl>
 Arguments 
<dt>description <dd>Output message. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_CreateDefaultMatrices">CreateDefaultMatrices</a></h4>
<p class="Blurb">Creates random  matrices for this distribution. </p>

<pre>void CreateDefaultMatrices(int typeOfMatrices);</pre>
  
<p><dl>
 Arguments 
<dt>typeOfMatrices <dt>We may think about different types of matricies, but now only random type is realized 
</dl></p> 


<hr><h4><a name="declSoftMaxDistribFun_AllocMatrix">AllocMatrix</a></h4>
<p class="Blurb">Creates matrices and attaches them to this distribution. </p>
 
<pre>void AllocMatrix(const float *data, EMatrixType mType, int numberOfWeightMatrix, 
	const int *parentIndices);
</pre>
  
<p><dl>
 Arguments 
<dt>data <dd>data for matrix creation 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>numberOfWeightMatrix <dd>this parameter is not used here 
<dt>parentIndices <dd>this parameter is not used here 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_AttachMatrix">AttachMatrix</a></h4>
<p class="Blurb">Attaches definite matrix to distribution.</p>

 
<pre>void AttachMatrix(CMatrix* pMatrix, EMatrixType mType, int numberOfWeightMatrix, 
	const int *parentIndices);
</pre>  
<p><dl>
 Arguments 
<dt>pMatrix <dd>pointer to matrix, which you want to attach. 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>numberOfWeightMatrix <dd>this parameter is not used here 
<dt>parentIndices <dd>this parameter is not used here 
</dl></p> 
 
 
<hr><h4><a name="declSoftMaxDistribFun_AllocOffsetVector">AllocOffsetVector</a></h4>
<p class="Blurb">Creates an offset vector and attaches it to a distribution</p>
 
<pre>void AllocOffsetVector(const float *data);</pre>
  
<p><dl>
 Arguments 
<dt>data <dd>a source data for vector creation 
</dl></p> 
 

<hr><h4><a name="declSoftMaxDistribFun_AttachOffsetVector">AttachOffsetVector</a></h4>
<p class="Blurb">Attaches offset vector to a distribution.</p>
 
<pre>void AttachOffsetVector(const floatVector *pVector);</pre>  

<p><dl>
 Arguments 
<dt>pVector <dd>pointer to the offset vector, which you want to attach. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_IsEqual">IsEqual</a></h4>
<p class="Blurb">Compares current SoftMaxDistribFun object with input one.</p>
 
<pre>int IsEqual(const CDistribFun *dataToCompare, float epsilon, int withCoeff, 
	float* maxDifference) const;
</pre>  
<p><dl>
 Arguments 
<dt>dataToCompare <dd>SoftMaxDistribFun object to compare 
<dt>epsilon <dd>accuracy of comparing 
<dt>withCoeff <dd>this parameter is not used here 
<dt>maxDifference <dd>an output value of maximum difference 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_GetMatrix">GetMatrix</a></h4>
<p class="Blurb">Returns pointer to a SoftMax weight matrix.</p>
 
<pre>CMatrix* GetMatrix(EMatrixType mType, int numWeightMat, const int *parentIndices) const;</pre>
  
<p><dl>
 Arguments 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>numWeightMat <dd>this parameter is not used here 
<dt>parentIndices <dd>this parameter is not used here 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_GetOffsetVector">GetOffsetVector</a></h4>
<p class="Blurb">Returns pointer to a SoftMax offset vector</p>
 
<pre>floatVector* GetOffsetVector();</pre>

<hr><h4><a name="declSoftMaxDistribFun_GetStatisticalMatrix">GetStatisticalMatrix</a></h4>
<p class="Blurb">Returns pointer to a matrix, which had been produced while maximize Likelihood</p>
 
<pre>CMatrix *GetStatisticalMatrix(EStatisticalMatrix mType, int *parentIndices) const;</pre>
  
<p><dl>
 Arguments 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>parentIndices <dd>this parameter is not used here 
</dl></p> 
 

<hr><h4><a name="declSoftMaxDistribFun_GetStatisticalOffsetVector">GetStatisticalOffsetVector</a></h4>
<p class="Blurb">Returns pointer to a offset vector, which had been produced while maximize Likelihood</p>
<pre>floatVector* GetStatisticalOffsetVector();</pre>

<hr><h4><a name="declSoftMaxDistribFun_InitLearnData">InitLearnData</a></h4>
<p class="Blurb">Copies a weight matrix and offset vector to statistical weight matrix and statistical offset vector.</p>
<pre>void InitLearnData();</pre>
  
<hr><h4><a name="declSoftMaxDistribFun_CopyLearnDataToDistrib">CopyLearnDataToDistrib</a></h4>
<p class="Blurb">Copies the results of learning process - statistical weight matrix and offset vector, to distribution parameters</p>
<pre>void CopyLearnDataToDistrib();</pre>

<hr><h4><a name="declSoftMaxDistribFun_Dump">Dump</a></h4>
<p class="Blurb">Organizes convinient results output.</p> 
<pre>void Dump() const;</pre>
  
<hr><h4><a name="declSoftMaxDistribFun_SetStatistics">SetStatistics</a></h4>
<p class="Blurb">Fills statistical weight matrix of distribution.</p>

<pre>void SetStatistics(const CMatrix *pMat, EStatisticalMatrix matrix, const int* parentsComb)</pre>
  
<p><dl>
 Arguments 
<dt>pMat <dd>a data vector, which will be stored as statistical offset vector 
<dt>matrix <dd>this parameter is not used here 
<dt>parentsComb <dd>Discrete parents state combination. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_SetOffsetStatistics">SetOffsetStatistics</a></h4>
<p class="Blurb">Fills statistical offset vector.</p>

<pre>void SetOffsetStatistics(const floatVector *pVec);</pre>
  
<p><dl>
 Arguments 
<dt>pVec <dd>a data vector, which will be stored as statistical offset vector 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_SetMaximizingMethod">SetMaximizingMethod</a></h4>
<p class="Blurb">Sets method, which would be used for likelihood maximizing.</p>
 
<pre>void SetMaximizingMethod (SMMaximizeMethod met);</pre>
  
<p><dl>
 Arguments 
<dt>met <dd>Defines likelihood maximizing method, which you want to use. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_GetMaximizingMethod">GetMaximizingMethod</a></h4>
<p class="Blurb">Gets method, which is used for likelihood maximizing.</p>
 
<pre>SMMaximizeMethod GetMaximizingMethod ();</pre>
  
<b> <p>Discussion</p> </b>
<p>There are three possible maximizing methods. They are Gradient, Conjugate Gradient and Newton-Rafsen(using Hessian). </p>

<hr><h4><a name="declSoftMaxDistribFun_MaximumLikelihood">MaximumLikelihood</a></h4>
<p class="Blurb">Calls definite maximizing method, according to current value of Maximizing Method</p>
 
<pre>void MaximumLikelihood(float **Observation, int NumberOfObservations, 
	float Accuracy, float step);</pre>
  
<p><dl>
 Arguments 
<dt>Observation <dd>Matrix of observations on SoftMax node and it's continous parents 
<dt>NumberOfObservations <dd>Number of Observations. 
<dt>Accuracy <dd>Maximizing method parameter, defines the stop condition. 
<dt>step <dd>Maximizing method parameter, it is better to set the value between 0 and 1. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_CalculateHessian">CalculateHessian</a></h4>
<p class="Blurb">Calculates Hessian matrix for Likelihood function using Evidences</p>
 
<pre>void CalculateHessian(float ** pContVectorEvidence, int NumberOfObservations);</pre>
  
<p><dl>
 Arguments 
<dt>pContVectorEvidence <dd>Matrix of observations on SoftMax node and it's continous parents 
<dt>NumberOfObservations <dd>Number of Observations. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_CalculateLikelihood">CalculateLikelihood</a></h4>
<p class="Blurb">Calculates Likelihood using Evidences</p>
 
<pre>float CalculateLikelihood(float **Observations, int NumOfObservations);</pre>
  
<p><dl>
 Arguments 
<dt>Observations <dd>Matrix of observations on SoftMax node and it's continous parents 
<dt>NumberOfObservations <dd>Number of Observations. 
</dl></p> 

<hr><h4><a name="declSoftMaxDistribFun_MaximumLikelihoodGradient">MaximumLikelihoodGradient</a></h4>
<h4><a name="declSoftMaxDistribFun_MaximumLikelihoodConjugateGradient">MaximumLikelihoodConjugateGradient</a></h4>
<h4><a name="declSoftMaxDistribFun_MaximumLikelihoodHessian">MaximumLikelihoodHessian</a></h4>
<p class="Blurb">Functions for likelihood maximizing</p>
 
<pre>void MaximumLikelihoodGradient(float **Observations, int NumOfObservations, 
	float Accuracy, float step);
void MaximumLikelihoodConjugateGradient(float **Observations, int NumOfObservations, 
	float Accuracy, float step);
void MaximumLikelihoodHessian(float ** Observations, int NumberOfObservations, 
	float Accuracy, float step);
</pre>
  
<p><dl>
 Arguments 
<dt>Observation <dd>Matrix of observations on SoftMax node and it's continous parents 
<dt>NumberOfObservations <dd>Number of Observations. 
<dt>Accuracy <dd>Maximizing method parameter, defines the stop condition. 
<dt>step <dd>Maximizing method parameter, it is better to set the value between 0 and 1. 
</dl></p> 

<hr><h3><a name="decl_pnlClassCCondSoftMaxDistribFun">Class CCondSoftMaxDistribFun</a></h3>
<p>Class CCondSoftMax implements basic operations wiht distribution on SoftMax node when it has both continuous and descrete parents. In this case distribution can be defined by number of SoftMaxDistribFun objects. Each of these objects corresponds to definite desrete parents state configuration.</p>

<hr><h4><a name="declCondSoftMaxDistribFun_">Clone</a></h4>
<h4><a name="declCondSoftMaxDistribFun_">CloneWithSharedMatrices</a></h4>
<p class="Blurb">Creates a full copy of current CCondSoftMax object</p>
 
<pre>CDistribFun* Clone() const;
CDistribFun* CloneWithSharedMatrices();</pre>

<hr><h4><a name="declCondSoftMaxDistribFun_Create">Create</a></h4>
<p class="Blurb">Creates a CCondSoftMax class object and returns a pointer to it.</p>
 
<pre>CCondSoftMaxDistribFun* Create(int nNodes, const CNodeType *const* nodeTypes, 
	CSoftMaxDistribFun* const pDefaultDistr);</pre>

<p><dl> 
 Arguments 
<dt>nNodes <dd>Number of nodes in domain 
<dt>nodeTypes <dd>pointer to the array of node types. 
<dt>pDefaultDistr <dd>--------------------------------------- 
</dl></p> 


<hr><h4><a name="declCondSoftMaxDistribFun_Copy">Copy</a></h4>
<p class="Blurb">Creates a copy of input object and returns a pointer to it.</p>
 
<pre>CCondSoftMaxDistribFun* Copy(const CCondSoftMaxDistribFun* pInpDistr);</pre>
 
<p><dl> 
 Arguments 
<dt>pInpDistr <dd>an object of CCondSoftMaxDistribFun type, which you want to copy. 
</dl></p> 


<hr><h4><a name="declCondSoftMaxDistribFun_IsValid">IsValid</a></h4>
<p class="Blurb">Chekes wheather this distribution is a unit one or not</p>
 
<pre>bool IsValid(std::string* description) const;</pre>
  
<p><dl> 
 Arguments 
<dt>description <dd>an output message 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_InitLearnData">InitLearnData</a></h4>
<p class="Blurb">Copies distribution parameters to statistical distribution parameters.</p>
<pre>void InitLearnData();</pre>
 
<hr><h4><a name="declCondSoftMaxDistribFun_CopyLearnDataToDistrib">CopyLearnDataToDistrib</a></h4>
<p class="Blurb">Copies the result of learning prosess - statistical distribution parameters - to distribution.</p>
<pre>void CopyLearnDataToDistrib();</pre>

<hr><h4><a name="declCondSoftMaxDistribFun_CreateDefaultMatrices">CreateDefaultMatrices</a></h4>
<p class="Blurb">Fill sdistribution matrices with random values.</p>
 
<pre>void CreateDefaultMatrices(int typeOfMatrices);</pre>
  
<p><dl> 
 Arguments 
<dt>typeOfMatrices <dd>We may think about different types of matricies, but now only random type is realized 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_SetDistribFun">SetDistribFun</a></h4>
<p class="Blurb">Sets definite Distribution function as distribution on SoftMax node with definite discrete parents state combination.</p>
 
<pre>void SetDistribFun(CSoftMaxDistribFun* inputDistr, const int* discreteParentCombination);</pre>
   
<p><dl> 
 Arguments 
<dt>inputDistr <dd>pointer to SoftMaxDistribFun object 
<dt>discreteParentCombination <dd>combination of discrete parents states. It defines a place, where SoftMaxDistribFun object will be stored 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_AllocDistribFun">AllocDistribFun</a></h4>
<p class="Blurb">Creates CSoftMaxDistribFun  object for definite discrete parents state combination and attaches it to distribution. </p>

<pre>void AllocDistribFun(const int* discreteParentCombination, int isUniform);</pre>
 
<p><dl>
 Arguments 
<dt>discreteParentCombination <dd>defines a place, where SoftMaxDistribFun object will be stored 
<dt>isUniform <dd>parameter, which defines weather distribution is unioform or not. 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_GetDistribution">GetDistribution</a></h4>
<p class="Blurb">Returns pointer to CSoftMaxDistribFun object.</p>
 
<pre>const CSoftMaxDistribFun* GetDistribution(const int* discrParentIndex)const;</pre> 
 
<p><dl>
 Arguments 
<dt>discrParentIndex <dd>combination of discrete parents states.  
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_AllocMatrix">AllocMatrix</a></h4>
<p class="Blurb">Creates  weight matrix and attaches it to distribution for definite discrete parents state combination.</p>
 
<pre>void AllocMatrix(const float *data, EMatrixType mType,int numberOfWeightMatrix, 
	const int *parentIndices);</pre>
  
<p><dl>
 Arguments 
<dt>data <dd>a data to fill the matrix 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>numberOfWeightMatrix <dd>this parameter is not  used here. 
<dt>parentIndices <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_AttachMatrix">AttachMatrix</a></h4>
<p class="Blurb">Attaches weight matrix to distribution for definite discrete parents state combination.</p>
 
<pre>void AttachMatrix(CMatrix* pMatrix, EMatrixType mType, int numberOfWeightMatrix, 
	const int *parentIndices);</pre>
 
<p><dl>
 Arguments 
<dt>pMatrix <dd>pointer to matrix 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>numberOfWeightMatrix <dd>his parameter is not  used here. 
<dt>parentIndices <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_AllocOffsetVector">AllocOffsetVector</a></h4>
<p class="Blurb">Creates offset vector and attaches it to distribution for definite discrete parents state combination.</p>
 
<pre>void AllocOffsetVector(const float *data, const int *parentIndices);</pre>
 
<p><dl>
 Arguments 
<dt>data <dd>data to fill a vector 
<dt>parentIndices <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_AttachOffsetVector">AttachOffsetVector</a></h4>
<p class="Blurb">Attaches offset vector to distribution for definite discrete parents state combination.</p>
 
<pre>void AttachOffsetVector(const floatVector *pVector, const int *parentIndices);</pre>
  
<p><dl>
 Arguments 
<dt>pVector <dd>pointer to vector 
<dt>parentIndices <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_IsEqual">IsEqual</a></h4>
<p class="Blurb">Compares two CCondSoftMaxDistribFun objects.</p>

<pre>int IsEqual(const CDistribFun *dataToCompare, float epsilon, int withCoeff, 
	float* maxDifference) const;</pre>
  
<p><dl>
 Arguments 
<dt>dataToCompare <dd>an input CCondSoftMaxDistribFun object 
<dt>epsilon <dd>accuracy of comparing 
<dt>withCoeff <dd>this parameter is not used here 
<dt>maxDifference <dd>an output value of maximum difference 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_GetMatrix">GetMatrix</a></h4>
<p class="Blurb">Gets weight matrix.</p>
 
<pre>CMatrix* GetMatrix(EMatrixType mType, int numWeightMat, const int *parentIndices) const;</pre>
  
<p><dl>
 Arguments 
<dt>mType <dd>as there is only one type of matrix for SoftMax distribution, here you are to define Weight matrix. 
<dt>numWeightMat <dd>this peremeter is not used here. 
<dt>parentIndices <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_GetOffsetVector">GetOffsetVector</a></h4>
<p class="Blurb">Gets offset vector</p>
<pre>floatVector* GetOffsetVector(const int *parentIndices) const;</pre>

<hr><h4><a name="declCondSoftMaxDistribFun_GetStatisticalMatrix">GetStatisticalMatrix</a></h4>
<h4><a name="declCondSoftMaxDistribFun_GetStatisticalOffsetVector">GetStatisticalOffsetVector</a></h4>
<p class="Blurb">Get statistical distribution parameters. </p>
 
<pre>CMatrix *GetStatisticalMatrix(EStatisticalMatrix mType, int *parentIndices) const;
floatVector* GetStatisticalOffsetVector(int *parentIndices) const;
</pre>  
 
<p><dl>
 Arguments 
<dt>parentIndices <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_SetStatistics">SetStatistics</a></h4>
<p class="Blurb">Fills statistical distribution parameters by definite values. </p>
 
<pre>void SetStatistics(const CMatrix *pMat, EStatisticalMatrix matrix, const int* parentsComb);</pre>
 
<p><dl>
 Arguments 
<dt>pMat <dd>pointer to matrix of values. 
<dt>matrix <dd>this parameter is not used here 
<dt>parentsComb <dd>discrete parents combination 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_SetMaximizingMethod">SetMaximizingMethod</a></h4>
<p class="Blurb">Sets method which will be used for maximazing Likelihood in all internal CSoftMaxDistribFun objects.</p>
 
<pre>void SetMaximizingMethod(CondMaximizeMethod met);</pre> 
 
<p><dl>
 Arguments 
<dt>met <dd>Defines likelihood maximizind method, which you want to use. 
</dl></p> 

<hr><h4><a name="declCondSoftMaxDistribFun_MaximumLikelihood">MaximumLikelihood</a></h4>
<p class="Blurb">Calls MaximumLikelihood method for every CSoftMaxDistribFun object.</p>
 
<pre>void MaximumLikelihood(float ** Observation, int NumberOfObservations, float Accuracy, 
	float step);
</pre>  
 
<p><dl>
 Arguments 
<dt>Observation <dd>Matrix of observations on SoftMax node and it's continous parents 
<dt>NumberOfObservations <dd>Number of Observations. 
<dt>Accuracy <dd>Maximizing method parameter, defines the stop condition. 
<dt>step <dd>Maximizing method parameter, it is better to set the value between 0 and 1. 
</dl></p> 


<hr><h2><a name="decl_pnlFactors">Factors</a></h2>


<p>
Class <EM CLASS="CodeReg">CFactor</EM> and its child subclasses <EM CLASS="CodeReg">CPotential</EM>, <EM CLASS="CodeReg">CCPD</EM>, <EM CLASS="CodeReg">CTabularPotential</EM>, <EM CLASS="CodeReg">CGaussianPotencial</EM>, <EM CLASS="CodeReg">CTabularCPD</EM>, and <EM CLASS="CodeReg">CGaussianCPD</EM> store graphical model factors related to one or several nodes, that is, a factor domain. The <EM CLASS="CodeReg">CPotential</EM>, <EM CLASS="CodeReg">CCPD</EM>, and <EM CLASS="CodeReg">CTabularFactor</EM> subclasses are abstract.
<p>


<IMG SRC="fig/PNLMarch.book-118.gif">


<hr><h3><a name="decl_pnlClassCFactor">Class CFactor</a></h3>


<IMG SRC="fig/PNLMarch.book-119.gif">


<hr><h4><a name="declCFactor_AllocMatrix">AllocMatrix</a></h4>
<p class="Blurb">Creates matrix and allocates it to factor.</p><pre>

void CFactor::AllocMatrix( float *<EM CLASS="CodeItalic">data</EM>, EMatrixType <EM CLASS="CodeItalic">mType</EM>, int <EM CLASS="CodeItalic">MatrixNum</EM> = -1, const int *<EM CLASS="CodeItalic">discrParentValuesIndices </EM>= NULL );
</pre><p><dl>
 Arguments
<dt>data<dd>  Array that corresponds to a specific part of distribution.
<dt>mType <dd>Type of the matrix that is allocated for the factor.
<dt>MatrixNum<dd>  Number of a matrix, if several matrices of given type are associated with the factor. Optional argument that may be omitted, if only one matrix is involved.
<dt>discrParentValuesIndices<dd>  Array of values of discrete parents.
</dl></p><p>
This function enters data into a matrix and associates the matrix with the factor.
</p>


<hr><h4><a name="declCFactor_AttachMatrix">AttachMatrix</a></h4>
<p class="Blurb">Attaches matrix to factor.</p><pre>

void CFactor::AttachMatrix( CMultiDMatrix *<EM CLASS="CodeItalic">matrix</EM>, EMatrixType <EM CLASS="CodeItalic">mType</EM>, int <EM CLASS="CodeItalic">MatrixNum</EM> = -1, const int *<EM CLASS="CodeItalic">discrParentValuesIndices</EM> = NULL );
</pre><p><dl>
 Arguments
<dt>matrix<dd>  Pointer to <EM CLASS="CodeReg">
CMultiDMatrix</EM>
 object.
<dt>mType <dd>Matrix type.
<dt>MatrixNum<dd>  Number of a matrix, if several matrices of given type are associated with the factor. Optional argument that may be omitted, if only one matrix is involved.
<dt>discrParentValuesIndices<dd>  Array of values of discrete parents.
</dl></p><p>
This function enters data into a matrix and associates the matrix with the factor.
</p>


<hr><h4><a name="declCFactor_GetFactorType">GetFactorType</a></h4>
<p class="Blurb">Returns factor type.</p><pre>

inline EFactorType CFactor::GetFactorType() const;
</pre><p>
Factor type may be either <EM CLASS="CodeItalic">ptFactor</EM> or <EM CLASS="CodeItalic">ptCPD</EM>.
</p>


<hr><h4><a name="declCFactor_GetDistributionType">GetDistributionType</a></h4>
<p class="Blurb">Returns distribution type.</p><pre>

inline EDistributionType CFactor::GetDistributionType() const;
</pre><p>
Factor type may be either <EM CLASS="CodeItalic">dtTabular</EM>, <EM CLASS="CodeItalic">dtGaussian </EM>or <EM CLASS="CodeItalic">dtCondGaussian</EM>.
</p>


<hr><h4><a name="declCFactor_GetDomain">GetDomain</a></h4>
<p class="Blurb">Returns pointer to factor domain and domain size.</p><pre>

void CFactor::GetDomain( int *<EM CLASS="CodeItalic">DomainSize</EM>, const int **<EM CLASS="CodeItalic">domain</EM>) const;
void CFactor::GetDomain( intVector* <EM CLASS="CodeItalic">domain </EM>) const;
</pre><p><dl>
 Arguments
<dt>DomainSize  <dd>Returned parameter, pointer to the integer that specifies domain size.
<dt>domain<dd>  Returned parameter. Array of numbers that specify serial numbers of the graphical model nodes associated with the factor domain.
</dl></p>


<hr><h4><a name="declCFactor_GetDomainSize">GetDomainSize</a></h4>
<p class="Blurb">Returns size of factor domain.</p><pre>

inline int CFactor::GetDomainSize() const;
</pre><p>
This function returns number of the nodes associated with the factor.
</p>


<hr><h4><a name="declCFactor_GetMatrix">GetMatrix</a></h4>
<p class="Blurb">Returns pointer to matrix attached to factor.</p><pre>

CMatrix&lt;float&gt;* CFactor::GetMatrix( EMatrixType <EM CLASS="CodeItalic">mType</EM>, int <EM CLASS="CodeItalic">matrixNum</EM> = -1, const int *<EM CLASS="CodeItalic">discrParentValuesIndices</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>mType <dd>Type of the matrix called.
<dt>matrixNum<dd>  Number of a matrix called among several matrices of a given type. Optional argument that may be omitted, if only one matrix is involved.
<dt>discrParentValuesIndices<dd>  Array of values of discrete parents.
</dl></p><p>
This function returns the pointer to the matrix by matrix type if the matrix of this type has been attached to the factor. Matrix may be of the following types: <EM CLASS="CodeItalic">matTable</EM>, <EM CLASS="CodeItalic">matMean</EM>, <EM CLASS="CodeItalic">matCov</EM>, <EM CLASS="CodeItalic">matWeights</EM>, <EM CLASS="CodeItalic">math</EM>, and <EM CLASS="CodeItalic">matK</EM>.
</p>


<hr><h4><a name="decl_pnloperator =">operator =</a></h4>
<p class="Blurb">Assigns data from input factor to the object.</p><pre>

CFactor&amp; CFactor::operator =( const CFactor&amp; <EM CLASS="CodeItalic">rInputFactor</EM> );
</pre><p><dl>
 Arguments
<dt>rInputFactor<dd>  Reference to the <EM CLASS="CodeReg">CFactor</EM> object.
</dl></p><p>
This function assigns data from input factor to the object for which it is called, only if both of them are of the same size and type.
</p>


<hr><h4><a name="declCFactor_IsValid">IsValid</a></h4>
<p class="Blurb">Checks factor validity.</p><pre>

virtial bool CFactor::IsValid( std::string* <EM CLASS="CodeItalic">discription</EM> = NULL ) const;
</pre><p><dl>
 Arguments
<dt>discription <dd>Error message.
</dl></p><p>
This function checks martix validity.The function returns `true' if matrices are allocated, returns `false' otherwise.
</p>


<hr><h4><a name="declCFactor_IsFactorsDistribFunEqual">IsFactorsDistribFunEqual</a></h4>
<p class="Blurb">Compares distributions.</p><pre>

int CFactor::IsFactorsDistribFunEqual( const CFactor *<EM CLASS="CodeItalic">pFactor</EM>, float <EM CLASS="CodeItalic">eps</EM>, int <EM CLASS="CodeItalic">withCoeff</EM> = 1 ) const;
</pre><p><dl>
 Arguments
<dt>pFactor <dd>Pointer to the factor to compare.
<dt>eps<dd>  Float value of accuracy to compare.
<dt>withCoeff<dd>  Flag of type of comparison: if it is equal to 0, normalizing constants for Gaussian and Conditional Gaussian distribution should be compared.
</dl></p><p>
This function returns 1, if distributions on factors are of the same type and size, with the same floating point matrices representing distributions.
</p>


<hr><h4><a name="declCFactor_TieDistribFun">TieDistribFun</a></h4>
<p class="Blurb">Sets input factor distribution for object.</p><pre>

void CFactor::TieDistribFun( CFactor *<EM CLASS="CodeItalic">pFactor</EM> );
</pre><p><dl>
 Arguments
<dt>pFactor <dd>Pointer to the CFactor object.
</dl></p><p>
This function sets the distribution for an object only if both factors are of the same form, and throws an exception otherwise.
</p>


<hr><h4><a name="declCFactor_IsDistributionSpecific">IsDistributionSpecific</a></h4>
<p class="Blurb">Checks whether distribution is specific.</p><pre>

int CFactor::IsDistributionSpecific() const;
</pre><p>
This function checks whether the distribution is specific or not and returns:
</p>


<hr><h4><a name="declCFactor_GenerateSample">GenerateSample</a></h4>
<p class="Blurb">Draws random sample from factor using information from current evidence.</p><pre>

void CFactor::GenerateSample(CEvidence* <EM CLASS="CodeItalic">evidences</EM>,int <EM CLASS="CodeItalic">maximize</EM> = 0)const = 0;
</pre><p><dl>
 Arguments
<dt>evidences <dd>Input-Output parameter.Pointer to the current evidence.
<dt>maximize  <dd>Flag of maximization.
</dl></p><p>
Generates a sample from the factor.
</p>


<hr><h4><a name="declCFactor_CopyWithNewDomain">CopyWithNewDomain</a></h4>
<p class="Blurb">Copies the input object and creates new factor with new domain and model domain.</p><pre>

static CFactor* CFactor::CopyWithNewDomain( const CFactor *<EM CLASS="CodeItalic">factor</EM>, intVector &amp;<EM CLASS="CodeItalic">domain</EM>, CModelDomain *<EM CLASS="CodeItalic">pModelDomain</EM>, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
</pre><p><dl>
 Arguments
<dt>factor  <dd>Pointer to the <EM CLASS="CodeReg">
CFactor</EM>
 object.
<dt>domain  <dd>Node numbers in the domain.
<dt>pModelDomain  <dd>Pointer to the new model domain.
<dt>obsIndices  <dd>Indices of the observed nodes.
</dl></p><p>
Copies the factor and changes the domain for which it was created.
</p>


<hr><h4><a name="declCFactor_Clone">Clone</a></h4>
<p class="Blurb">Creates replica of object.</p><pre>

virtual CFactor* CFactor::Clone() const = 0;
</pre>


<hr><h4><a name="declCFactor_CloneWithSharedMatrices">CloneWithSharedMatrices</a></h4>
<p class="Blurb">Creates replica of factor.</p><pre>

virtual CFactor* CFactor::CloneWithSharedMatrices() const = 0;
</pre><p>
This function creates a replica of the factor so that the newly created factor shares its matrices with the source factor.
</p>


<hr><h4><a name="declCFactor_CreateAllNecessaryMatrices">CreateAllNecessaryMatrices</a></h4>
<p class="Blurb">Creates matrices necessary to make factor valid.</p><pre>

virtual void CFactor::CreateAllNecessaryMatrices(int <EM CLASS="CodeItalic">typeOfMatrices</EM> = 1);
</pre><p><dl>
 Arguments
<dt>typeOfMatrices  <dd>Flag of the type of matrix generation.<BR>
If it equals to 1 all matrices are random.
</dl></p><p>
This function creates all matrices which are necessary to make a factor valid. <EM CLASS="CodeItalic"> </EM>
Covariance matrix for the Gaussian distribution is the matrix unit.
</p>


<hr><h4><a name="declCFactor_GetNumInHeap">GetNumInHeap</a></h4>
<p class="Blurb">Returns factor number in factor heap.</p><pre>

int CFactor::GetNumInHeap() const;
</pre><p>
This function is applied for <EM CLASS="CodeReg">ModelDomain</EM>.
</p>
<hr><h4><a name="declCFactor_ChangeOwnerToGraphicalModel">ChangeOwnerToGraphicalModel</a></h4>
<p class="Blurb">Releases model domain from factor.</p><pre>

void CFactor::ChangeOwnerToGraphicalModel() const;
</pre>


<hr><h4><a name="declCFactor_IsOwnedByModelDomain">IsOwnedByModelDomain</a></h4>
<p class="Blurb">Checks if factor is owner of model domain.</p><pre>

bool CFactor::IsOwnedByModelDomain() const;
</pre>


<hr><h4><a name="declCFactor_GetModelDomain">GetModelDomain</a></h4>
<p class="Blurb">Returns pointer to model domain.</p><pre>

inline CModelDomain* CFactor::GetModelDomain() const;
</pre>


<hr><h4><a name="decl_pnlGetArgType">GetArgType</a></h4>
<p class="Blurb">Returns pointers to node types of domain nodes.</p><pre>

const pConstNodeTypeVector CFactor::*GetArgType() const;
</pre>


<hr><h4><a name="declCFactor_ConvertToSparse">ConvertToSparse</a></h4>
<p class="Blurb">Converts factor distribution function with dense matrices into distribution function with sparce matrices.</p><pre>

void CFactor::ConvertToSparse();
</pre><p>
This function converts a factor distribution function with dense matrices into a distribution with sparse matrices.
</p>


<hr><h4><a name="declCFactor_ConvertToDense">ConvertToDense</a></h4>
<p class="Blurb">Converts factor distribution with sparce matrices into distribution with dense matrices.</p><pre>

void CFactor::ConvertToDense();
</pre><p>
This function converts a factor distribution with sparse matrices into a distribution with dense matrices.
</p>


<hr><h4><a name="declCFactor_IsSparse">IsSparse</a></h4>
<p class="Blurb">Checks if distribution matrices are sparse.</p><pre>

virtual int CFactor::IsSparse() const = 0;
</pre><p>
This function checks if the matrices of the factor distribution are sparse.
</p>


<hr><h4><a name="declCFactor_IsDense">IsDense</a></h4>
<p class="Blurb">Checks if distribution matrices are dense.</p><pre>

virtual int CFactor::IsDense() const = 0;
</pre><p>
This function checks if the matrices of the distribution are dense.
</p>


<hr><h4><a name="declCFactor_GetObsPositions">GetObsPositions</a></h4>
<p class="Blurb">Returns observed positions of domain. </p><pre>

inline void CFactor::GetObsPositions( intVector* <EM CLASS="CodeItalic">obsPosOut</EM> ) const;
</pre><p><dl>
 Arguments
<dt>obsPosOut <dd>Observed positions of the domain.
</dl></p>


<hr><h4><a name="declCFactor_GetDistribFun">GetDistribFun</a></h4>
<p class="Blurb">Returns pointer to distribution function.</p><pre>

inline CDistribFun* CFactor::GetDistribFun() const;
</pre>

<hr><h4><a name="declCFactor_SetDistribFun">SetDistribFun</a></h4>
<p class="Blurb">Sets distribution function into factor.</p><pre>

void CFactor::SetDistribFun( const CDistribFun* <EM CLASS="CodeItalic">data </EM>);
</pre><p><dl>
 Arguments
<dt>data  <dd>Pointer to <EM CLASS="CodeReg">CDistribFun</EM> object.
</dl></p><p>
This function releases the old distribution function and creates a new factor distribution by copying the input data.
</p>


<hr><h4><a name="declCFactor_MakeUnitFunction">MakeUnitFunction</a></h4>
<p class="Blurb">Transfers distribution function into unit function distribution.</p><pre>

void CFactor::MakeUnitFunction();
</pre>


<hr><h4><a name="declCFactor_ConvertStatisticToPot">ConvertStatisticToPot</a></h4>
<p class="Blurb">Creates potential on the basis of statistical data of distribution function.</p><pre>

virtual CPotential* CFactor::ConvertStatisticToPot( int numOfSamples ) const = 0;
</pre><p><dl>
 Arguments
<dt>numOfSamples  <dd>Number of samples.
</dl></p>


<hr><h4><a name="declCFactor_ProcessingStatisticalDataEM">ProcessingStatisticalDataEM</a></h4>
<p class="Blurb">Updates statistical data.</p><pre>

virtual void CFactor::ProcessingStatisticalDataEM( const CPotential* <EM CLASS="CodeItalic">infData</EM>, const CEvidence *<EM CLASS="CodeItalic">pEvidence</EM> = NULL ) = 0;
</pre><p><dl>
 Arguments
<dt>infData <dd>Inference result.
<dt>pEvidence <dd>Pointer to an <EM CLASS="CodeItalic">
Evidence</EM>
 object.
</dl></p><p>
This function estimates factors and updates statistical data.
</p>


<hr><h4><a name="declCFactor_StatisticalDataML">StatisticalDataML</a></h4>
<p class="Blurb">Gathers statistical data.</p><pre>

virtual void CFactor::StatisticalDataML( const CEvidence* const* <EM CLASS="CodeItalic">pEvidences</EM>, int <EM CLASS="CodeItalic">evidenceNumber</EM> );
virtual void CFactor::StatisticalDataML( const pConstEvidenceVector&amp; <EM CLASS="CodeItalic">pEvidences</EM> );
</pre><p><dl>
 Arguments
<dt>pEvidences  <dd>Array of evidences.
<dt>EvidenceNumber  <dd>Number of evidences.
</dl></p><p>
This function estimates factors and updates statistical data.
</p>


<hr><h4><a name="declCFactor_SetStatistics">SetStatistics</a></h4>
<p class="Blurb">Sets statistical data.</p><pre>

virtual void CFactor::SetStatistics( const CMatrix&lt;float&gt;* <EM CLASS="CodeItalic">pMat</EM>, EStatisticalMatrix <EM CLASS="CodeItalic">matrixType</EM>, const int* <EM CLASS="CodeItalic">parentsComb</EM> = NULL ) = 0;
</pre><p><dl>
 Arguments
<dt>pMat  <dd>Input parameter. Matrix with statistical data.
<dt>matrixType  <dd>Type of matrix.
<dt>parentsComb <dd>Combination of discrete parents<EM CLASS="CodeItalic">.</EM>
</dl></p><p>
This function sets statistical data for learning.
</p>


<hr><h4><a name="declCFactor_ProcessingStatisticalData">ProcessingStatisticalData</a></h4>
<p class="Blurb">Updates factor distribution function after gathering statistical data. </p><pre>

virtual float CFactor::ProcessingStatisticalData( float <EM CLASS="CodeItalic">numEvidences</EM> ) = 0;
</pre><p><dl>
 Arguments
<dt>numEvidences  <dd>Number of evidences.
</dl></p><p>
This function performs factor estimation and updates a factor distribution function with the newly acquired statistical data.
</p>


<hr><h4><a name="declCFactor_GetLogLik">GetLogLik</a></h4>
<p class="Blurb">Returns likelihood of input data.</p><pre>

virtual float CFactor::GetLogLik( const CEvidence* <EM CLASS="CodeItalic">pEv</EM>, const CPotential* <EM CLASS="CodeItalic">pShrInfRes</EM> = NULL ) const = 0;
</pre><p><dl>
 Arguments
<dt>pEv <dd>Evidence.
<dt>pShrInfRes  <dd>Inference result. This parameter is needed if the domain contains unobserved nodes.
</dl></p><p>
This function returns the logarithm of likelihood.
</p>


<hr><h4><a name="declCFactor_AreThereAnyObsPositions">AreThereAnyObsPositions</a></h4>
<p class="Blurb">Checks if factor has observed nodes.</p><pre>

inline int CFactor::AreThereAnyObsPositions() const;
</pre>


<hr><h3><a name="decl_pnlClassCCPD">Class CCPD</a></h3>


<IMG SRC="fig/PNLMarch.book-120.gif">


<hr><h4><a name="declCCPD_ConvertToPotential">ConvertToPotential</a></h4>
<p class="Blurb">Converts class object to potential and returns pointer to that potential.</p><pre>

CPotential * CCPD::ConvertToPotential();
</pre><p>
This function converts a <EM CLASS="CodeReg">CCPD</EM> object to a <EM CLASS="CodeReg">CPotential</EM> object and returns a new <EM CLASS="CodeReg">CPotential</EM> object.
</p>


<hr><h4><a name="declCCPD_ConvertWithEvidenceToPotential">ConvertWithEvidenceToPotential</a></h4>
<p class="Blurb">Converts CPD to potential using evidence.</p><pre>

CPotential* CCPD::ConvertWithEvidenceToPotential( const CEvidence* <EM CLASS="CodeItalic">pEv</EM>, int <EM CLASS="CodeItalic">flagSumOnMixtureNode</EM> = 1) const;
</pre><p><dl>
 Arguments
<dt>pEv <dd>Evidence.
<dt>flagSumOnMixtureNode  <dd>Flag of mixture node summation.
</dl></p><p>
This function converts CPD to Potential using evidence. This function can change distribution type of CPD, unlike combination of <EM CLASS="CodeReg">
<a href="#declCCPD_ConvertToPotential">ConvertToPotential</A></EM>
 and <EM CLASS="CodeReg">
<a href="#declCCPD_ShrinkObservedNodes">ShrinkObservedNodes</A></EM>.
</p>


<hr><h4><a name="declCCPD_NormalizeCPD">NormalizeCPD</a></h4>
</p><p class="Blurb">Normalizes CPD. </p><pre>

virtual void CCPD::NormalizeCPD() = 0;
</pre>


<hr><h3><a name="decl_pnlClassCTabularCPD">Class CTabularCPD</a></h3>


<IMG SRC="fig/PNLMarch.book-121.gif">


<hr><h4><a name="declCTabularCPD_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CTabularCPD* CTabularCPD::Create( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const floatVector&amp; <EM CLASS="CodeItalic">data</EM> = floatVector() );
static CTabularCPD* CTabularCPD::Create( const int* domain, int nNodes, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const float* <EM CLASS="CodeItalic">data</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in domain.
<dt>data<dd>  Array of data.
<dt>pMD <dd>Pointer to the model domain.
</dl></p>


<hr><h4><a name="declCTabularCPD_Copy">Copy</a></h4>
<p class="Blurb">Creates new Tabular CPD as copy of input object.</p><pre>

static CTabularCPD* CTabularCPD::Copy( const CTabularCPD* <EM CLASS="CodeItalic">pTabCPD</EM> );
</pre><p><dl>
 Arguments
<dt>pTabCPD<dd>  Pointer to the <EM CLASS="CodeReg">CTabularCPD</EM> object.
</dl></p>


<hr><h4><a name="declCTabularCPD_CreateUnitFunctionCPD">CreateUnitFunctionCPD</a></h4>
<p class="Blurb">Creates CPD that becomes Unit function after conversion to potential.</p><pre>

static CTabularCPD* CTabularCPD::CreateUnitFunctionCPD( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
static CTabularCPD* CTabularCPD::CreateUnitFunctionCPD( const int* <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>pMD <dd>Pointer to the modail domain.
</dl></p><p>
This function creates CPD as a unit function by converting the function to the potential.
</p>


<hr><h3><a name="decl_pnlClassCGaussianCPD">Class CGaussianCPD</a></h3>


<IMG SRC="fig/PNLMarch.book-122.gif">


<hr><h4><a name="declCGaussianCPD_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CGaussianCPD* CGaussianCPD::Create( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
static CGaussianCPD* CGaussianCPD::Create( const int* domain, int nNodes, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in domain.
<dt>pMD <dd>Pointer to the modail domain.
</dl></p>


<hr><h4><a name="declCGaussianCPD_CreateUnitFunctionCPD">CreateUnitFunctionCPD</a></h4>
<p class="Blurb">Creates CPD that becomes Unit function after conversion to potential.</p><pre>

static CGaussianCPD* CGaussianCPD::CreateUnitFunctionCPD( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
static CGaussianCPD* CGaussianCPD::CreateUnitFunctionCPD( const int* <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM> );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>pMD <dd>Pointer to the modail domain.
</dl></p><p>
This function creates CPD as a unit function by converting the function to the potential.
</p>


<hr><h4><a name="declCGaussianCPD_Copy">Copy</a></h4>
<p class="Blurb">Creates new Gaussian CPD by copying input CPD.</p><pre>

static CGaussianCPD* CGaussianCPD::Copy( const CGaussianCPD* <EM CLASS="CodeItalic">pGaussCPD</EM> );
</pre><p><dl>
 Arguments
<dt>pGaussCPD<dd>  Pointer to <EM CLASS="CodeReg">CGaussianCPD</EM> object.
</dl></p>


<hr><h4><a name="declCGaussianCPD_AllocDistribution">AllocDistribution</a></h4>
<p class="Blurb">Allocates Gaussian distribution on Gaussian child node.</p><pre>

void CGaussianCPD::AllocDistribution( const float* <EM CLASS="CodeItalic">pMean</EM>, const float* <EM CLASS="CodeItalic">pCov</EM>, float <EM CLASS="CodeItalic">normCoeff</EM>, float* const* <EM CLASS="CodeItalic">pWeights</EM>, const int* <EM CLASS="CodeItalic">parentCombination</EM> );
void CGaussianCPD::AllocDistribution( const floatVector&amp; meanIn, const floatVector&amp; covIn, float normCoeff,const floatVecVector&amp; weightsIn,const intVector&amp; parentCombination = intVector() );
</pre><p><dl>
 Arguments
<dt>pMean<dd>  Data for the mean matrix.
<dt>pCov<dd>  Data for the covariance matrix which is inputted rowwise.
<dt>normCoeff<dd>  Float value of normalization constant.
<dt>pWeights<dd>  Data for weight matrices.
<dt>parentCombination<dd>  Array of values of discrete parents.
</dl></p><p>
This function allocates a Gaussian distribution on a Gaussian child node with Gaussian parents and the given discrete parent combination.
</p>


<hr><h4><a name="declCGaussianCPD_SetCoefficient">SetCoefficient</a></h4>
<p class="Blurb">Sets normalization constant to Gaussian CPD object.</p><pre>

void CGaussianCPD::SetCoefficient( float <EM CLASS="CodeItalic">coeff</EM>, const int* <EM CLASS="CodeItalic">parentCombination</EM> = NULL );
</pre><p><dl>
 Arguments
<dt>coeff<dd>  Float value of normalization constant.
<dt>parentCombination<dd>  Pointer to the array of values of discrete parents.
</dl></p>


<hr><h4><a name="declCGaussianCPD_GetCoefficient">GetCoefficient</a></h4>
<p class="Blurb">Gets value of normalization constant.</p><pre>

float CGaussianCPD::GetCoefficient( const int* <EM CLASS="CodeItalic">parentCombination</EM> = NULL  );
</pre><p><dl>
 Arguments
<dt>parentCombination<dd>  Pointer to the array of values of discrete parents.
</dl></p>


<hr><h3><a name="decl_pnlClassCMixtureGaussianCPD">Class CMixtureGaussianCPD</a></h3>




<hr><h4><a name="declCMixtureGaussianCPD_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CMixtureGaussianCPD* CMixtureGaussianCPD::Create( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD, </EM>const floatVector&amp; <EM CLASS="CodeItalic">sumCoeff</EM> );
static CMixtureGaussianCPD* CMixtureGaussianCPD::Create( const int* domain, int nNodes, CModelDomain* <EM CLASS="CodeItalic">pMD, </EM>const float*<EM CLASS="CodeItalic"> sumCoeff</EM> );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in the domain.
<dt>pMD <dd>Pointer to the modail domain.
<dt>sumCoeff  <dd>Mixture coefficient.
</dl></p>


<hr><h4><a name="declCMixtureGaussianCPD_Copy">Copy</a></h4>
<p class="Blurb">Creates new mixture Gaussian CPD by coying input CPD.</p><pre>

static CMixtureGaussianCPD* CMixtureGaussianCPD::Copy( const CGaussianCPD* <EM CLASS="CodeItalic">pGaussCPD</EM> );
</pre><p><dl>
 Arguments
<dt>pGaussCPD<dd>  Pointer to <EM CLASS="CodeReg">CMixtureGaussianCPD</EM> object.
</dl></p>


<hr><h4><a name="declCMixtureGaussianCPD_AllocDistributionVec">AllocDistributionVec</a></h4>
<p class="Blurb">Allocates mixture Gaussian distribution.</p><pre>

void CMixtureGaussianCPD::AllocDistributionVec( const floatVector&amp; meanIn, const floatVector&amp; covIn,float normCoeff,const floatVecVector&amp; weightsIn,const intVector&amp; parentCombination );
</pre><p><dl>
 Arguments
<dt>pMean<dd>  Data for the mean matrix.
<dt>pCov<dd>  Data for the covariance matrix which is inputted rowwise.
<dt>normCoeff<dd>  Float value of normalization constant.
<dt>pWeights<dd>  Data for weight matrices.
<dt>parentCombination<dd>  Array of values of discrete parents.
</dl></p><p>
This function allocates a mixture Gaussian distribution for the given discrete parent combination.
</p>


<hr><h4><a name="declCMixtureGaussianCPD_SetCoefficient">SetCoefficient</a></h4>
<p class="Blurb">Sets normalization constant to mixture Gaussian CPD.</p><pre>

void CMixtureGaussianCPD::SetCoefficient( float <EM CLASS="CodeItalic">coeff</EM>, const int* <EM CLASS="CodeItalic">parentCombination</EM> );
</pre><p><dl>
 Arguments
<dt>coeff<dd>  Float value of the normalization constant.
<dt>parentCombination<dd>  Pointer to the array of values of discrete parents.
</dl></p>


<hr><h4><a name="declCMixtureGaussianCPD_GetCoefficient">GetCoefficient</a></h4>
<p class="Blurb">Gets value of normalization constant.</p><pre>

float CMixtureGaussianCPD::GetCoefficient( const int* <EM CLASS="CodeItalic">parentCombination</EM> );
</pre><p><dl>
 Arguments
<dt>parentCombination<dd>  Pointer to the array of values of discrete parents.
</dl></p>

<hr><h4><a name="declCMixtureGaussianCPD_SetCoefficientVec">SetCoefficientVec</a></h4>
<p class="Blurb">Sets normalization constant to mixture Gaussian CPD.</p><pre>

void CMixtureGaussianCPD::SetCoefficientVec( float <EM CLASS="CodeItalic">coeff</EM>, const intVector&amp; <EM CLASS="CodeItalic">parentCombination</EM> );
</pre><p><dl>
 Arguments
<dt>coeff<dd>  Float value of the normalization constant.
<dt>parentCombination<dd>  Pointer to the array of values of discrete parents.
</dl></p>


<hr><h4><a name="declCMixtureGaussianCPD_GetCoefficientVec">GetCoefficientVec</a></h4>
<p class="Blurb">Gets value of normalization constant.</p><pre>

float CMixtureGaussianCPD::GetCoefficientVec( const intVector&amp; <EM CLASS="CodeItalic">parentCombination</EM> );
</pre><p><dl>
 Arguments
<dt>parentCombination<dd>  Pointer to the array of values of discrete parents.
</dl></p>


<hr><h4><a name="declCMixtureGaussianCPD_GetProbabilities">GetProbabilities</a></h4>
<p class="Blurb">Returns vector of probabilities of mixture node.</p><pre>

inline void CMixtureGaussianCPD::GetProbabilities( loatVector* <EM CLASS="CodeItalic">probabilities</EM> ) const;
</pre><p><dl>
 Arguments
<dt>probabilities <dd>Returned parameter.Vector of probabilities.
</dl></p><p>
This function returns the vector of probabilities of the mixture node.
</p>


<hr><h3><a name="decl_pnlClassCTreeCPD">Class CTreeCPD</a></h3>

<hr><h4><a name="declCTreeCPD_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CTreeCPD* CTreeCPD::Create( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const floatVector&amp; <EM CLASS="CodeItalic">data</EM> = floatVector() );
static CTreeCPD* CTreeCPD::Create( const int* domain, int nNodes, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const float* <EM CLASS="CodeItalic">data</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in domain.
<dt>data<dd>  Array of data.
<dt>pMD <dd>Pointer to the modail domain.
</dl></p>


<hr><h4><a name="declCTreeCPD_Copy">Copy</a></h4>
<p class="Blurb">Creates new Tree CPD as copy of input object.</p><pre>

static CTreeCPD* CTreeCPD::Copy( const CTreeCPD* <EM CLASS="CodeItalic">pCPD</EM> );
</pre><p><dl>
 Arguments
<dt>pCPD<dd>  Pointer to the <EM CLASS="CodeReg">CTreeCPD</EM> object.
</dl></p>

<hr><h4><a name="declCTreeCPD_UpdateTree">UpdateTree</a></h4>
<p class="Blurb">Updates decision Tree for current node distribution function.</p>
 
<pre>void UpdateTree(const CGraph *pGraphTree, TreeNodeFields *fields);</pre>

<p><dl>  
 Arguments 
<dt>pGraphTree <dd>Pointer to the class CGraph that will be used for creation a new decision Tree. 
<dt>fields <dd>Pointer to the array of the new decision Tree nodes properties. 
</dl></p> 

<hr><h4><a name="declCTreeCPD_ConvertWithEvidenceToPotential">ConvertWithEvidenceToPotential</a></h4>
<p class="Blurb">Creates new Tabular or Gaussian potential using current evidence on decision Tree parents.</p>
 
<pre>CPotential* ConvertWithEvidenceToPotential(const CEvidence* pEvidence, 
	int flagSumOnMixtureNode = 1) const; 
</pre>  

<p><dl>
 Arguments 
<dt>pEvidence <dd>Pointer to the current decision Tree parents evidence. 
<dt>flagSumOnMixtureNode <dd>Flag of mixture node summation. 
</dl></p> 
 
<hr><h3><a name="decl_pnlClassCSoftMaxCPD">Class CSoftMaxCPD</a></h3>
<p>Class CSoftMaxCPD containes implementations of Class CCPD virtual functions.</p>

<hr><h4><a name="declCSoftMaxCPD_Create">Create</a></h4>
<p class="Blurb">Returns class object</p>
 
<pre>static CSoftMaxCPD* Create(const int *domain, int nNodes, CModelDomain* pMD);</pre>
  
<p><dl>
 Arguments 
<dt>domain <dd>Pointer to the array of numbers of domain nodes. 
<dt>nNodes <dd>Number of nodes in domain. 
<dt>pMD <dd>pointer to model domain, which includes this factor 
</dl></p> 

<hr><h4><a name="declCSoftMaxCPD_Copy">Copy</a></h4>
<p class="Blurb">Creates new SoftMax CPD as copy of the input object</p>
 
<pre>static CSoftMaxCPD* Copy(const CSoftMaxCPD* pSMCPD);</pre>
  
<p><dl>
 Arguments 
<dt>pSMCPD <dd>Pointer to CSoftMaxCPD object. 
</dl></p> 

<hr><h4><a name="declCSoftMaxCPD_AllocDistribution">AllocDistribution</a></h4>
<p class="Blurb">Allocates SoftMax distribution on SoftMax child node.</p>
 
<pre>void AllocDistribution(const float* pWeights, const float* pOffsets, 
	const int* parentCombination = NULL);</pre>
  
<p><dl>
 Arguments 
<dt>pWeights <dd>Pointer to SoftMax weight matrix. 
<dt>pOffsets <dd>Pointer to SoftMax offset vector. 
<dt>parentCombination <dd>Pointer to discontinous parents state combination. 
</dl></p> 
<p><b>Discussion </b></p>
<p>This function allocates a SoftMax distribution on SoftMax child node with Gaussian parents and the given discrete parent combination. </p>
 
<hr><h4><a name="declCSoftMaxCPD_GetMaximizingMethod">GetMaximizingMethod</a></h4>
<p class="Blurb">Gets method, which is used for likelihood maximizing.</p>
 
<pre>EMaximizeMethod GetMaximizingMethod();</pre>
  
<p><b> Discussion </b></p>
<p>There are three possible methods for likelihood maximising. They are Gradient, ConjugateGradient and Hessian </p>

<hr><h4><a name="declCSoftMaxCPD_SetMaximizingMethod">SetMaximizingMethod</a></h4>
<p class="Blurb">Sets method, which is used for likelihood maximizing.</p>
 
<pre>void SetMaximizingMethod(EMaximizeMethod met);</pre>
  
<p><dl>
 Arguments 
<dt>met <dd>Defines Likelihood maximizing method, which you want to use. 
</dl></p> 

<hr><h4><a name="declCSoftMaxCPD_MaximumLikelihood">MaximumLikelihood</a></h4>
<p class="Blurb">Maximizes likelihood using defined method.</p>
 
<pre>void MaximumLikelihood(float ** Observation, int NumberOfObservations, float Accuracy, 
	float step = 0.1);
</pre>  
<p><dl>
 Arguments 
<dt>Observation <dd>pointer to float matrix of observations on the SoftMax node family. 
<dt>NumberOfObservations <dd>Defines quantity of observations 
<dt>Accuracy <dd>parameter of maximizing method 
<dt>Step <dd>parameter of maximizing method 
</dl></p> 



<hr><h3><a name="decl_pnlClassCPotential">Class CPotential</a></h3>



<hr><h4><a name="declCPotential_Multiply">Multiply</a></h4>
<p class="Blurb">Multiplies two factors and returns product.</p><pre>

CPotential* CPotential::Multiply( const CPotential *<EM CLASS="CodeItalic">pOtherFactor</EM> ) const;
</pre><p><dl>
 Arguments
<dt>pOtherFactor  <dd>Pointer to the multiplier factor.
</dl></p><p>
This function returns pointer to a new <EM CLASS="CodeReg">CPotential</EM> object, which is the product of two <EM CLASS="CodeReg">CPotential</EM> objects.
</p>


<hr><h4><a name="decl_pnloperator *=">operator *=</a></h4>
<p class="Blurb">Provides multiplication and puts result to potential.</p><pre>

CPotential&amp; CPotential::operator *=( const CPotential &amp;<EM CLASS="CodeItalic">rSmallPotential</EM> );
</pre><p><dl>
 Arguments
<dt>rSmallPotential<dd>  Reference to the right-hand-side multiplier of <EM CLASS="CodeReg">CPotential</EM> type.
</dl></p><p>
This function changes the object, for which it was called, by changing its data matrices.
</p>


<hr><h4><a name="decl_pnloperator /=">operator /=</a></h4>
<p class="Blurb">Provides division and puts result to potential.</p><pre>

CPotential&amp; CPotential::operator /=( const CPotential &amp;<EM CLASS="CodeItalic">rSmallPotential</EM> );
</pre><p><dl>
 Arguments
<dt>rSmallPotential<dd>  Reference to the denominator of <EM CLASS="CodeReg">CPotential</EM> type.
</dl></p><p>
This function changes the object, for which it was called, by changing its data matrices.
</p>


<hr><h4><a name="declCPotential_GetNormalized">GetNormalized</a></h4>
<p class="Blurb">Creates new normalized potential.</p><pre>

CPotential* CPotential::GetNormalized() const;
</pre><p>
This function returns pointer to a new normalized <EM CLASS="CodeReg">CPotential</EM> object with domain that is the same as domain of the object, for which this function is called.
</p>


<hr><h4><a name="declCPotential_Normalize">Normalize</a></h4>
<p class="Blurb">Normalizes potential for which it was called.</p><pre>

void CPotential::Normalize();
</pre>


<hr><h4><a name="decl_pnlMarginalize">Marginalize</a></h4>
<p class="Blurb">Marginalizes object.</p><pre>

CPotential * CPotential:: Marginalize( const int *<EM CLASS="CodeItalic">pSmallDom</EM>, int <EM CLASS="CodeItalic">domSize</EM>, int <EM CLASS="CodeItalic">maximize</EM> = 0 ) const ;
CPotential * CPotential:: Marginalize( const intVector&amp; <EM CLASS="CodeItalic">pSmallDom</EM>, int <EM CLASS="CodeItalic">maximize</EM> = 0 ) const ;
</pre><p><dl>
 Arguments
<dt>pSmallDom<dd>  Array of numbers of nodes that should constitute a domain of the returned marginalized object.
<dt>domSize <dd>Size of the returned object domain.
<dt>maximize<dd>  Flag of the marginalization type.<br>
0 stands for simple summation;<br>
1 stands for finding maximum value.
</dl></p><p>
This function returns pointer to a new <EM CLASS="CodeReg">CPotential</EM> object that is generated from the source object by either adding or by integrating of the source object referring to the nodes that are not part of the returned object domain. The returned object domain should be a subset of the source domain.
</p>


<hr><h4><a name="declCPotential_ShrinkObservedNodes">ShrinkObservedNodes</a></h4>
<p class="Blurb">Creates new factor without dimensions corresponding to observed nodes.</p><pre>

CPotential * CPotential::ShrinkObservedNodes( const CEvidence* pEv ) const;
</pre><p><dl>
 Arguments
<dt>pEv<dd>  Pointer to the given evidence.
</dl></p><p>
This function creates a new factor with the same domain as the domain of the source factor but with modified observed nodes. Joint probability distribution also changes reflecting the modified values of the observed nodes.
</p>


<hr><h4><a name="decl_pnlExpandObservedNodes">ExpandObservedNodes</a></h4>
<p class="Blurb">Expands dimensions corresponding to observed nodes.</p><pre>

CPotential * CPotential::ExpandObservedNodes ( const CEvidence* pEv. int updateInCanonical = 1<EM CLASS="CodeItalic"> </EM>) const;
</pre><p><dl>
 Arguments
<dt>pEv<dd>  Pointer to the given evidence.
<dt>updateInCanonical<dd>  Flag of distribution form.
</dl></p><p>
This function expands the probability distribution by filling empty spaces with zeros.
</p>


<hr><h4><a name="declCPotential_GetMultiplyedDelta">GetMultiplyedDelta</a></h4>
<p class="Blurb">Returns delta functions by which Gaussian distribution was multiplied.</p><pre>

int CPotential::GetMultiplyedDelta( const int** <EM CLASS="CodeItalic">positions</EM>, const float** <EM CLASS="CodeItalic">values</EM>, const int** <EM CLASS="CodeItalic">offsets</EM> ) const;
int CPotential::GetMultiplyedDelta( intVector* <EM CLASS="CodeItalic">positions</EM>, floatVector* <EM CLASS="CodeItalic">values</EM>,  intVector* <EM CLASS="CodeItalic">offsets</EM> ) const;
</pre><p><dl>
 Arguments
<dt>positions<dd>  Array of distribution positions which are multiplied by Delta distribution.
<dt>values<dd>  Array of values.
<dt>offsets <dd>Returned parameter. Offsets of values.
</dl></p><p>
This function returns delta functions by which Gaussian distribution, for which it was called, was multiplied. Multiplication by delta distributions is an internal part of the library implementation of inference. Inference engines should return result in non-specified form, that is, without multiplied Delta distribution. The function is planned to be deleted from the final release of the library.
</p>


<hr><h4><a name="declCPotential_Divide">Divide</a></h4>
<p class="Blurb">Divides factor by another and returns result.</p><pre>

CPotential * CPotential::Divide( const CPotential *<EM CLASS="CodeItalic">pOtherFactor</EM> ) const;
</pre><p><dl>
 Arguments
<dt>pOtherFactor  <dd>Pointer to the divisor factor.
</dl></p><p>
This function divides the factor for which it is called by the argument and returns the result, that is, pointer to a newly generated factor.
</p>


<hr><h4><a name="declCPotential_Dump">Dump</a></h4>
<p class="Blurb">Dumps object content.</p><pre>

void CPotential::Dump()const;
</pre><p>
This function dumps the CPotential content, that is, domain, factor type, and distribution matrix to <EM CLASS="CodeReg">
std::cout.</EM>
</p>


<hr><h4><a name="declCPotential_MarginalizeInPlace">MarginalizeInPlace</a></h4>
<p class="Blurb">Marginalizes input object.</p><pre>

void CPotential::MarginalizeInPlace( const CPotential* <EM CLASS="CodeItalic">pOldPot</EM>, const int* <EM CLASS="CodeItalic">corrPositions</EM> = NULL, int <EM CLASS="CodeItalic">maximize</EM> = 0);
</pre><p><dl>
 Arguments
<dt>pOldPot <dd>Pointer to the old potential.
<dt>corrPositions <dd>Positions for marginalisation.
<dt>maximize  <dd>Flag of marginalisation with maximization.
</dl></p><p>
This function marginalizes an input object and stores the result in the given object.
</p>


<hr><h4><a name="declCPotential_GetMPE">GetMPE</a></h4>
<p class="Blurb">Returns maximum probability explanation.</p><pre>

CEvidence* CPotential::GetMPE() const;
</pre>


<hr><h3><a name="decl_pnlClassCTabularPotential">Class CTabularPotential</a></h3>




<hr><h4><a name="declCTabularPotential_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CTabularPotential* CTabularPotential::Create( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const float* <EM CLASS="CodeItalic">data, </EM><EM CLASS="CodeReg">const intVector&amp; </EM><EM CLASS="CodeItalic">obsIndices</EM><EM CLASS="CodeReg"> = intVector() </EM> );
static CTabularPotential* CTabularPotential::Create( const int* domain, int nNodes, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, const float* <EM CLASS="CodeItalic">data</EM> = NULL, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in domain.
<dt>data<dd>  Array of data.
<dt>pMD <dd>Pointer to the modail domain.
<dt>obsIndices  <dd>Indices of observed nodes of the domain.
</dl></p>


<hr><h4><a name="declCTabularPotential_Copy">Copy</a></h4>
<p class="Blurb">Creates new tabular  potential as copy of input object.</p><pre>

static CTabularPotential* CTabularPotential::Copy(const CTabularCPD* <EM CLASS="CodeItalic">pTabCPD</EM>);
</pre><p><dl>
 Arguments
<dt>pTabCPD<dd>  Pointer to the <EM CLASS="CodeReg">CTabularCPD</EM> object.
</dl></p>


<hr><h4><a name="declCTabularPotential_CreateUnitFunctionCPD">CreateUnitFunctionCPD</a></h4>
<p class="Blurb">Creates potential in  form of  unit function.</p><pre>

static CTabularPotential* CTabularPotential::CreateUnitFunctionCPD( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD, </EM>int <EM CLASS="CodeItalic">asDense</EM> = 1, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
static CTabularPotential* CTabularPotential::CreateUnitFunctionCPD( const int* <EM CLASS="CodeItalic">domain</EM>, int <EM CLASS="CodeItalic">nNodes</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD, int asDense </EM><EM CLASS="CodeReg">= 1, const intVector&amp; </EM><EM CLASS="CodeItalic">obsIndices</EM><EM CLASS="CodeReg"> = intVector()</EM> );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Array of numbers of domain nodes.
<dt>pMD <dd>Pointer to the model domain.
<dt>asDense <dd>Flag of matrix type.
<dt>obsIndices  <dd>Numbers of observed positions.
<dt>nNodes  <dd>Number of nodes in the domain.
</dl></p><p>
This function creates a potential as a unit function.
</p>


<hr><h3><a name="decl_pnlClassCGaussianPotential">Class CGaussianPotential</a></h3>



<hr><h4><a name="declCGaussianPotential_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CGaussianPotential*  CGaussianPotential::Create( const intVector&amp; <EM CLASS="CodeItalic">domain</EM>,CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, int <EM CLASS="CodeItalic">inMoment</EM> = -1, const floatVector&amp; <EM CLASS="CodeItalic">Vec</EM> = floatVector(),const floatVector&amp;  <EM CLASS="CodeItalic">Mat </EM>= floatVector(),float <EM CLASS="CodeItalic">normCoeff</EM> = 0.0f, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
static CGaussianPotential* CGaussianPotential::Create( const int *<EM CLASS="CodeItalic">domain</EM>, int <EM CLASS="CodeItalic">nNodes</EM>, CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, int <EM CLASS="CodeItalic">inMoment</EM> = -1, float const* <EM CLASS="CodeItalic">pVec</EM> = NULL,                                 float const* <EM CLASS="CodeItalic">pMat</EM> = NULL, float <EM CLASS="CodeItalic">normCoeff</EM> = 0.0f, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector());
</pre><p><dl>
 Arguments
<dt>domain  <dd>Numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in the domain.
<dt>inMoment<dd>  Flag of the desired form of a Gaussian potential:<br>
1 - moment form,<br>
0 - canonical form.<br>
This flag defines the interpretation of the next three arguments.
<dt>inMoment<dd> = 1,
<dt>pVec<dd>  Array for Mean value matrix data.
<dt>pMat<dd>  array for Covariance matrix data.
<dt>normCoeff<dd>  Value of normalization constant in  the moment form.
<dt>inMoment<dd> = 0,
<dt>pVec<dd>  Array for H matrix data.
<dt>pMat<dd>  array for K matrix data.
<dt>normCoeff<dd>  Value of normalization constant in  the canonical form.
<dt>obsIndices  <dd>Indices of observed nodes of the domain.
<dt>pMd <dd>Pointer to the model domain.
</dl></p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates new class object as copy of input object.</p><pre>

static CGaussianPotential* C<EM CLASS="CodeReg">Gaussian</EM>Potential::Copy( const C<EM CLASS="CodeReg">Gaussian</EM>Potential *<EM CLASS="CodeItalic">pGauPot</EM> );
</pre><p><dl>
 Arguments
<dt>pGauPot<dd>  Pointer to the <EM CLASS="CodeReg">CGaussianPotential</EM> object.
</dl></p>


<hr><h4><a name="decl_pnlCreateDeltaFunction">CreateDeltaFunction</a></h4>
<p class="Blurb">Creates Delta function as <EM CLASS="CodeReg">CGaussianPotential</EM>
</p><pre>

static CGaussianPotential* CGaussianPotential::CreateDeltaFunction( const int *<EM CLASS="CodeItalic">domain</EM>, <EM CLASS="CodeItalic">int nNodes, CModelDomain* pMD, const float *mean, int isInMoment</EM> = 1, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
static CGaussianPotential* CGaussianPotential::CreateDeltaFunction( const intVector<EM CLASS="CodeItalic">&amp; domain</EM>, <EM CLASS="CodeItalic">CModelDomain* pMD, const floatVector&amp; mean, int isInMoment</EM> = 1, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
</pre><p><dl>
 Arguments
<dt>domain  <dd>Numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in the domain.
<dt>mean<dd>  Pointer to float values of the mean matrix.
<dt>isInMoment<dd>  Flag of the form of the resulting Potential:
<A NAME="pgfId-54965"></A>  1 - moment form (mean, covariance matrices, and normalization constant)
<A NAME="pgfId-54966"></A>  0 - canonical form (canonical matrices g, H, K ).
<dt>pMD <dd>Pointer to the model domain.
<dt>obsIndices  <dd>Indices of observed nodes of the domain.
</dl></p>


<hr><h4><a name="decl_pnlCreateUnitFunctionDistribution">CreateUnitFunctionDistribution</a></h4>
<p class="Blurb">Creates C<EM CLASS="CodeReg">Gaussian</EM>Potential object to represent unit function distribution.
</p><pre>

static CGaussianPotential* CGaussianPotential::CreateUnitFunctionDistribution ( const int *<EM CLASS="CodeItalic">domain</EM>, int <EM CLASS="CodeItalic">nNodes</EM>,CModelDomain*<EM CLASS="CodeItalic"> pMD</EM>,int <EM CLASS="CodeItalic">isInCanonical</EM> = 1, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector());
static CGaussianPotential* CGaussianPotential::CreateUnitFunctionDistribution ( const CNodeType*const *<EM CLASS="CodeItalic">nodeTypes</EM>, const int *<EM CLASS="CodeItalic">domain</EM>, int <EM CLASS="CodeItalic">numOfNds</EM>, int <EM CLASS="CodeItalic">isInCanonical </EM>= 1, const intVector&amp; <EM CLASS="CodeItalic">obsIndices</EM> = intVector() );
</pre><p><dl>
 Arguments
<dt>domain<dd>  Numbers of domain nodes.
<dt>nNodes<dd>  Number of nodes in the domain.
<dt>isInCanonical<dd>  Flag of the desired form of Unit function:<br>
1 - canonical form,<br>
0 - moment form.
<dt>obsIndices  <dd>Indices of the observed domain nodes.
<dt>pMd <dd>Model domain.
</dl></p><p>
Creates a class object in the form of a unit function distribution.
</p>


<hr><h4><a name="decl_pnlSetCoefficient">SetCoefficient</a></h4>
<p class="Blurb">Sets normalization constant to <EM CLASS="CodeReg">CGaussianPotential</EM> object.
</p><pre>

void CGaussianPotential::SetCoefficient( float <EM CLASS="CodeItalic">coeff</EM>, int <EM CLASS="CodeItalic">isForCanonical</EM> );
</pre><p><dl>
 Arguments
<dt>coeff<dd>  Float value of normalization constant.
<dt>isForCanonical<dd>  Flag of distribution type to set the coefficient:<br>
1 - canonical form<br>
0 - moment form.
</dl></p>


<hr><h4><a name="declCGaussianPotential_GetCoefficient">GetCoefficient</a></h4>
<p class="Blurb">Gets value of normalization constant.</p><pre>

float CGaussianPotential::GetCoefficient( int <EM CLASS="CodeItalic">isforCanonical</EM> );
</pre><p><dl>
 Arguments
<dt>isforCanonical<dd>  Flag of distribution type to get the coefficient:<br>
1 - canonical form,<br>
0 - moment form.
</dl></p>

<hr><h3><a name="decl_pnlClassCIDPotential">Class CIDPotential</a></h3>

<hr><h4><a name="declCIDPotential_Combine">Combine</a></h4>
<p class="Blurb">Combines two factors and returns product.</p>
<pre>
virtual CIDPotential* Combine(const CIDPotential *pOtherFactor, 
    CIDPotential* output = NULL) const; 
</pre>
<p><dl>  
 Arguments
<dt>pOtherFactor <dd>Pointer to the multiplier factor 
<dt>output <dd>If this argument is NULL, function creates a new CIDPotential object, else it only reloads factor. 
</dl></p>
<p><b>Discussion</b></p>
 <p>This function returns pointer to a CIDPotential object, which is the product of two CIDPotential objects. </p>


<hr>
<h4><a name="declCIDPotential_Contraction">Contraction</a></h4>
<p class="Blurb">Multiplies utility and probability parts of factor and returns the product</p>

<pre> virtual CDenseMatrix &lt float &rt * Contraction(CDenseMatrix &lt float &rt * output = NULL) const; </pre>

<p><dl>  
 Arguments 
<dt>output <dd>If this argument is NULL, function creates a new CDenseMatrix object and fills it with the result of contraction. 
</dl></p> 
<b> <p>Discussion  </p></b>
<p>This function returns pointer to a CDenseMatrix object, which is the product of contraction  between utility and probability parts. </p>
 
<hr>
<h4><a name="declCIDPotential_DivideInSelf">DivideInSelf</a></h4>
<p class="Blurb">Provides division and puts the result to potential. </p>
 
<pre>virtual void DivideInSelf(const CCPD *pOtherFactor) const;</pre>
  
<p><dl>
 Arguments 
<dt>pOtherFactor <dd>Pointer to the divider factor 
</dl></p>
<p><b>Discussion</b></p> 
<p>This function changes the object, for which it was called, by changing its data matrices.</p>


<hr><h4><a name="declCIDPotential_InsertPoliticsInSelf">InsertPoliticsInSelf</a></h4>
<p class = "Blurb">Inserts new politics to the current CIDPotential object </p>
 
<pre>virtual void InsertPoliticsInSelf(const CCPD *pOtherFactor) const;</pre>

<p><dl>  
 Arguments 
<dt>pOtherFactor <dd>Pointer to the factor, which contains new politics 
</dl></p>
<p><b>Discussion </b></p>
<p>This function inserts new politics, which are described by argument, to current object </p>


<hr><h4><a name="declCIDPotential_SetProbDistribFun">SetProbDistribFun </a></h4>
<p class="Blurb">Sets the probability part of potential</p>

<pre>void SetProbDistribFun(const CDistribFun* data);</pre> 
  
<p><dl>
 Arguments 
<dt>data <dd>Pointer to a CDistribFun object, which contains probability part of potential. 
</dl></p>
<p><b>Discussion  </b></p>
<p>This function changes the object, for which it was called, by changing its data matrices.</p>


<hr><h4><a name="declCIDPotential_SetUtilityDistribFun">SetUtilityDistribFun</a></h4>
<p class="Blurb">Sets the utility part of potential.</p>
 
<pre>void SetUtilityDistribFun(const CDistribFun* data);</pre>
  
<p><dl>
 Arguments 
<dt>data <dd>Pointer to a CDistribFun object, which contains probability part of potential. 
</dl></p>
<p><b>Discussion </b></p> 
<p>This function changes the object, for which it was called, by changing its data matrices. </p>


<hr><h3><a name="decl_pnlClassCIDTabularPotential">Class CIDTabularPotential</a></h3>


<p>Class CIDTabularPotential contains implementations of class CIDPotential virtual functions. This class is used in inference algorithm for the nets, which are based on the Limited Memory Influence Diagram.</p>
<hr><h4><a name="declCIDTabularPotential_Clone">Clone</a></h4>
<p class="Blurb">Creates a new CFactor class object as copy of the input object</p> 

<pre>virtual CFactor* Clone() const;</pre>

<hr><h4><a name="declCIDTabularPotential_Create">Create</a></h4>
<p class="Blurb">Returns class object</p>
<pre>
static CIDTabularPotential* Create(const int *domain, int nNodes, CModelDomain* pMD, 
    const float* probData = NULL, const float* utilityData = NULL); </pre>
<p><dl>  
 Arguments 
<dt>domain <dd>Pointer to the array of numbers of domain nodes. 
<dt>nNodes <dd>Number of nodes in domain 
<dt>pMD <dd>Graphical model which contains this potential 
<dt>probData <dd>Pointer to the array of float values of probabilities 
<dt>utilityData <dd>Pointer to the array of float values of utilities 
</dl></p> 
 
<hr><h3><a name="decl_pnlClassCFactorsl">Class CFactors</a></h3>
 
<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates <EM CLASS="CodeReg">CFactors</EM> class object.
</p><pre>

friend CFactors* CFactors::Create( int <EM CLASS="CodeItalic">NumOfFactors </EM>);
</pre><p><dl>
 Arguments
<dt>numOfFactors<dd>  Maximal number of factors in the factor array; equal to the number of nodes for <EM CLASS="CodeItalic">
BNet</EM> and to the number of cliques for all the Markov models.
</dl></p>


<hr><h4><a name="declCFactors_GetNumberOfFactors">GetNumberOfFactors</a></h4>
<p class="Blurb">Returns current number of factors in factor array.</p><pre>

inline int CFactors::GetNumberOfFactors() const;
</pre>


<hr><h4><a name="declCFactors_GetFactor">GetFactor</a></h4>
<p class="Blurb">Returns pointer to factor.</p><pre>

inline CFactor* CFactors::GetFactor( int <EM CLASS="CodeItalic">factorNum </EM>) const;
</pre><p><dl>
 Arguments
<dt>factorNum <dd>Factor index in the array of factors.
</dl></p><p>
This function returns pointer to the factor with the index equal to <EM CLASS="CodeItalic">factorNum</EM>.
</p>


<hr><h4><a name="decl_pnlAddFactor">AddFactor</a></h4>
<p class="Blurb">Adds new factor to graphical model.</p><pre>

inline int CFactors::AddFactor( CFactor *<EM CLASS="CodeItalic">factor </EM>);
</pre><p><dl>
 Arguments
<dt>factor<dd>  Pointer to the factor to be set in the factor array.
</dl></p><p>
This function adds a factor to the graphical model. The function returns the index of the factor in the factors array.
</p>


<hr><h4><a name="decl_pnlShrinkObsNdsForAllFactors">ShrinkObsNdsForAllFactors</a></h4>
<p class="Blurb">Shrinks all factors stored in <EM CLASS="CodeReg">CFactors</EM> class using input evidence.
</p><pre>

void CFactors::ShrinkObsNdsForAllFactors( const CEvidence *<EM CLASS="CodeItalic">pEvidence </EM>);
</pre><p><dl>
 Arguments
<dt>pEvidence<dd>  Evidence.
</dl></p><p>
This function shrinks all the factors stored in <EM CLASS="CodeReg">CFactors</EM> class using the input evidence.
</p>


<hr><h2><a name="decl_pnlMatrices">Matrices</a></h2>



<hr><h3><a name="decl_pnlClassCMatrix">Class CMatrix</a></h3>

<IMG SRC="fig/PNLMarch.book-123.gif">

<p>
Template class <EM CLASS="CodeReg">CMatrix&lt;Type&gt;</EM> is an abstract class that declares basic operations with a multidimensional matrix of any type.The operations are used with various types of probability distributions. This class has two main derived subclasses: <EM CLASS="CodeReg">CDenseMatrix</EM> and <EM CLASS="CodeReg">CSparseMatrix</EM>.
</p>
<p>
Class <EM CLASS="CodeReg">CMatrixIterator</EM> is convenient for operations with matrix elements.
</p>



<hr><h4><a name="declCMatrix_CreateEmptyMatrix">CreateEmptyMatrix</a></h4>
<p class="Blurb">Creates empty multidimensional matrix with data of default value.</p><pre>

virtual CMatrix&lt;Type&gt;* CMatrix::CreateEmptyMatrix( int <EM CLASS="CodeItalic">dim</EM>, const int *<EM CLASS="CodeItalic">range</EM>, int Clamp, Type <EM CLASS="CodeItalic">defaultVal</EM> = Type(0) )const = 0;
</pre><p><dl>
 Arguments
<dt>dim<dd>   Number of matrix dimensions.
<dt>range<dd>   Array of lengths of matrix dimensions.
<dt>Clamp<dd>   Status flag:<BR>
&#183; 1 means no change is allowed<BR>
&#183; 0 means change is allowed.
<dt>defaultVal<dd>  Default value to be set for the matrix.
</dl></p><p>
This function creates a multidimensional matrix with the default value data and returns the pointer to the matrix.
</p>


<hr><h4><a name="declCMatrix_SetDataFromOtherMatrix">SetDataFromOtherMatrix</a></h4>
<p class="Blurb">Assigns data from input matrix to object.</p><pre>

virtual void  CMatrix::SetDataFromOtherMatrix( const CMatrix&lt;Type&gt;* <EM CLASS="CodeItalic">matInput</EM> ) = 0;
</pre><p><dl>
 Arguments
<dt>matInput<dd>  Pointer to the <EM CLASS="CodeReg">
CMatrix</EM>
 object to be copied.
</dl></p><p>
This function assigns data from the input matrix to the matrix, for which it is called, only if both the matrices are of the same size.
</p>


<hr><h4><a name="declCMatrix_Clone">Clone</a></h4>
<p class="Blurb">Returns pointer to new matrix.</p><pre>

virtual CMatrix&lt;Type&gt;*  CMatrix::Clone() const = 0;
</pre>


<hr><h4><a name="declCMatrix_GetNumberDims">GetNumberDims</a></h4>
<p class="Blurb">Returns number of matrix dimensions.</p><pre>

virtual inline int  CMatrix::GetNumberDims() const = 0;
</pre>


<hr><h4><a name="declCMatrix_GetRanges">GetRanges</a></h4>
<p class="Blurb">Returns pointer to array of dimensions and number of matrix dimensions.</p><pre>

virtual inline void  CMatrix::GetRanges( int *<EM CLASS="CodeItalic">numOfDimsOut</EM>, const int **<EM CLASS="CodeItalic">rangesOut </EM>) const = 0;
</pre><p><dl>
 Arguments
<dt>numOfDimsOut<dd>   Returned parameter. Number of matrix dimensions.
<dt>rangesOut<dd>   Returned parameter. Pointer to the array of the matrix dimensions.
</dl></p><p>
This function returns the number of matrix dimensions and the pointer to the array of the dimensions.
</p>


<hr><h4><a name="declCMatrix_GetMatrixClass">GetMatrixClass</a></h4>
<p class="Blurb">Returns matrix class name.</p><pre>

virtual EMatrixClass  CMatrix::GetMatrixClass() const;
</pre><p>
This function returns the class name of the martix. A matrix may belong to one of the following classes: <EM CLASS="CodeReg">
mcBase</EM>, <EM CLASS="CodeReg">mcSparse</EM>, <EM CLASS="CodeReg">mcDense</EM>, <EM CLASS="CodeReg">mcNumericDense</EM>, <EM CLASS="CodeReg">mcNumericSparse</EM>, <EM CLASS="CodeReg">mc2DNumericDense</EM>, <EM CLASS="CodeReg">mc2DNumericSparse</EM>.
</p>


<hr><h4><a name="declCMatrix_ConvertToDense">ConvertToDense</a></h4>
<p class="Blurb">Creates new matrix by conversion of given matrix to dense matrix. </p><pre>

virtual CDenseMatrix&lt;Type&gt;*  CMatrix::ConvertToDense() const = 0;
</pre><p>
This function creates a new matrix by conversion of the given matrix to a dense matrix.The new matrix contains the same data as the matrix corresponding to the function but has another another form. When called for a dense matrix the function creates its replica.
</p>


<hr><h4><a name="declCMatrix_ConvertToSparse">ConvertToSparse</a></h4>
<p class="Blurb">Creates new matrix by conversion of given matrix to sparse matrix. </p><pre>

virtual CSparseMatrix&lt;Type&gt;*  CMatrix::ConvertToSparse() const = 0;
</pre><p>
This function creates a new matrix by conversion of the given matrix into a sparce matrix. The new matrix contains the same data as the matrix corresponding to the function but has another form. When called for a sparce matrix the function creates its replica.
</p>


<hr><h4><a name="declCMatrix_GetElementByIndices">GetElementByIndices</a></h4>
<p class="Blurb">Returns value of matrix element by multidimensional indices.</p><pre>

virtual inline Type CMatrix::GetElementByIndices( const int *<EM CLASS="CodeItalic">multidimindices </EM>) const = 0;
</pre><p><dl>
 Arguments
<dt>multidimindices<dd>  Pointer to the array of multidimensional indices of the addressed matrix element. The array length is equal to the number of matrix dimensions.
</dl></p><p>
This function returns the value of a multidimensional matrix element by multidimensional indices.
</p>


<hr><h4><a name="declCMatrix_SetElementByIndices">SetElementByIndices</a></h4>
<p class="Blurb">Sets new value for matrix element by multidimensional indices.</p><pre>

virtual inline void  CMatrix::SetElementByIndices( Type <EM CLASS="CodeItalic">value</EM>, const int *<EM CLASS="CodeItalic">multidimindices</EM>) = 0;
</pre><p><dl>
 Arguments
<dt>value<dd>  Value to be set.
<dt>multidimindices <dd>Pointer to the array of multidimensional indices of the addressed matrix element. The array length is equal to the number of matrix dimensions.
</dl></p><p>
This function sets a new value for a matrix element by multidimentional matrices.
</p>


<hr><h4><a name="declCMatrix_ReduceOp">ReduceOp</a></h4>
<p class="Blurb">Collapses dimensions of multidimensional matrix.</p><pre>

virtual CMatrix&lt;Type&gt;*  CMatrix::ReduceOp( const int *<EM CLASS="CodeItalic">pDimsOfInterest</EM>, int <EM CLASS="CodeItalic">numDimsOfInterest</EM>, int <EM CLASS="CodeItalic">action</EM> = 2, const int *<EM CLASS="CodeItalic">p0bservedValues</EM> = NULL, CMatrix&lt; Type &gt; *<EM CLASS="CodeItalic">output</EM> = NULL, EAccumType <EM CLASS="CodeItalic">accumType</EM> = PNL_ACCUM_TYPE_STORE ) const = 0;
</pre><p><dl>
 Arguments
<dt>pDimsOfInterest<dd>  Pointer to the array of dimensions to be preserved in the new matrix.
<dt>NumDimsOfKeep<dd>  Number of dimensions to be preserved.
<dt>action<dd>  Type of matrix reduction:<BR>
<EM CLASS="CodeItalic">
action</EM>
  = 0 - sum of all the dimensions except <EM CLASS="CodeItalic">
pDimsOfInterest<BR>
action </EM>
= 1<EM CLASS="CodeItalic">
 </EM>
- selection of the maximum of the dimensions<BR>
<EM CLASS="CodeItalic">
action </EM>
= 2<EM CLASS="CodeItalic">
 </EM>
- selection of the given value of a node.
<dt>pObservedValues<dd>  Pointer to an array of pointers to the values.
<dt>output<dd>  Pointer to the matrix to which the result of <EM CLASS="CodeReg">
ReduceOp</EM>
 is to be passed.
<dt>accumType<dd>  Value of EAccumType class.
</dl></p><p>
This function collapses dimensions of a multidimensional matrix.
</p>


<hr><h4><a name="decl_pnlExpandDims">ExpandDims</a></h4>
<p class="Blurb">Creates new matrix by expanding specified dimensions.</p><pre>

virtual CMatrix&lt;Type&gt;  CMatrix::*ExpandDims(const int *<EM CLASS="CodeItalic">dimsToExtend</EM>,                       const int *<EM CLASS="CodeItalic">keepPosOfDims</EM>,const int *<EM CLASS="CodeItalic">sizesOfExpandDims</EM>,int <EM CLASS="CodeItalic">numDimsToExpand</EM>) const = 0;
</pre><p><dl>
 Arguments
<dt>dimsToExtend  <dd>Pointer to an array of dimensions that should be expanded in the new matrix.
<dt>keepPosOfDims<dd>  Number of dimensions to be expanded.
<dt>sizesOfExpandDims<dd>  Pointer to an array of variables in the expanded dimensions that preserve their original values.
<dt>numDimsToExtend<dd>  Pointer to the array of new sizes of the expanded matrix.
</dl></p><p>
This function creates a new matrix by expanding specified dimensions. It expands dimensions specified in <EM CLASS="CodeItalic">
dims</EM> only when their size before the expansion is equal to 1. Dimensions are expanded to the size specified in <EM CLASS="CodeItalic">
sizesOfExpandDims</EM> by adding zeros at the matrix points in <EM CLASS="CodeItalic">dims</EM>. Variables at the matrix points specified in <EM CLASS="CodeItalic">keepPosOfDims</EM> do not change their values.This function is used by the <EM CLASS="CodeReg">ExpandObservedNodes </EM>function.
</p>


<hr><h4><a name="declCMatrix_ClearData">ClearData</a></h4>
<p class="Blurb">Sets all matrix elements to zero.</p><pre>

virtual inline void  CMatrix::ClearData() = 0;
</pre><p>
This function sets all matrix elements to zero.This function is used in learning process.
</p>


<hr><h4><a name="declCMatrix_SetUnitData">SetUnitData</a></h4>
<p class="Blurb">Sets all elements of numeric matrix to ones.</p><pre>

virtual inline void  CMatrix::SetUnitData() = 0;
</pre><p>
This function sets all elements of the numeric matrix to ones. This function is used to get a matrix that does not change another matrix during multiplication.
</p>


<hr><h4><a name="declCMatrix_SetClamp">SetClamp</a></h4>
<p class="Blurb">Forbids matrix change in learning process. </p><pre>

inline int  CMatrix::SetClamp( int Clamp );
</pre><p><dl>
 Arguments
<dt>Clamp<dd>  Status flag:<BR>
&#183; 1 means no change is allowed<BR>
&#183; 0 means change is allowed<BR>
&#183; 0 means previous flag value is retained.
</dl></p><p>
This function sets a flag which prevents matrix change. On setting a new value the function returns the value of the flag.
</p>


<hr><h4><a name="declCMatrix_GetClampValue">GetClampValue</a></h4>
<p class="Blurb">Returns clamp value.</p><pre>

inline int  CMatrix::GetClampValue() const;
</pre><p>
This function returns 1 if no change of the matrix is allowed in the learning process, and returns 0 if change is allowed.
</p>


<hr><h4><a name="declCMatrix_MultiplyInSelf">MultiplyInSelf</a></h4>
<p class="Blurb">Performs multiplication and puts result in matrix. </p><pre>

virtual void  CMatrix::MultiplyInSelf( const CMatrix&lt;Type&gt;* <EM CLASS="CodeItalic">matToMult</EM>, int <EM CLASS="CodeItalic">numDimsToMult</EM>, const int* <EM CLASS="CodeItalic">indicesToMultInSelf</EM>, int <EM CLASS="CodeItalic">isUnifrom</EM> = 0, const Type <EM CLASS="CodeItalic">uniVal</EM> = Type(0) );
</pre><p><dl>
 Arguments
<dt>matToMult<dd>  Pointer to the matrix to be multiplied.
<dt>numDimsToMult<dd>  Number of positions for multiplication. Should be the same as the number of dimensions in <EM CLASS="CodeReg">
matToMult</EM>.
<dt>indicesToMultInSelf<dd>  Numbers of dimensions of the small matrix in the big matrix.
<dt>isUniform<dd>  Flag about matrix data. Returns 1 when the matrix does not contain any data and its values are equal to <EM CLASS="CodeItalic">
uniVal, </EM>returns 0 otherwise.
<dt>uniVal  <dd>Input parameter.Value.
</dl></p><p>
This function performs multiplication for numeric matrices only.<BR>
The multiplication is performed element by element under the conditions that the <EM CLASS="CodeReg">
matToMult </EM>matrix dimensions form a subset of dimensions of the matrix for which the function was called and do not differ from the function dimensions in size. <BR>
To perform multiplication in an empty matrix use <EM CLASS="CodeItalic">isUniform</EM> flag.
</p>


<hr><h4><a name="declCMatrix_DivideInSelf">DivideInSelf</a></h4>
<p class="Blurb">Performs division and puts the result in the matrix.</p><pre>

virtual void  CMatrix::DivideInSelf( const CMatrix&lt;Type&gt;* <EM CLASS="CodeItalic">matToDiv</EM>, int <EM CLASS="CodeItalic">numDimsToDiv</EM>, const int* <EM CLASS="CodeItalic">indicesToDivInSelf</EM> );
</pre><p><dl>
 Arguments
<dt>matToDiv<dd>  Pointer to the matrix for division.
<dt>numDimsToDiv<dd>  Number of positions for division. Should be the same as the number of dimensions in <EM CLASS="CodeItalic">matToMult</EM>.
<dt>indicesToDivInSelf<dd>  Positions of dimensions of the small matrix in the big matrix.
</dl></p><p>
This function performs division for numeric matrices only. The division is performed element by element under the condition that the dimensions of the <EM CLASS="CodeItalic">matToDiv</EM> matrix form a subset of dimensions of the matrix for which the function is called and do not differ from the function dimensions in size.
</p>


<hr><h4><a name="declCMatrix_GetIndicesOfMaxValue">GetIndicesOfMaxValue</a></h4>
<p class="Blurb">Returns vector of indices of max value.</p><pre>

virtual void  CMatrix::GetIndicesOfMaxValue( intVector* <EM CLASS="CodeItalic">indicesOut</EM> ) const;
</pre><p><dl>
 Arguments
<dt>indicesOut<dd>  Returned vector of indices of max value.
</dl></p><p>
This function returns the vector of indices of the max value for numeric matrices only.
</p>


<hr><h4><a name="declCMatrix_NormalizeAll">NormalizeAll</a></h4>
<p class="Blurb">Creates new matrix by normalizing matrix elements.</p><pre>

virtual CMatrix&lt;Type&gt;*  CMatrix::NormalizeAll() const;
</pre><p>
This function returns the pointer to a new matrix with the sum of all elements equal to 1.
</p>


<hr><h4><a name="declCMatrix_Normalize">Normalize</a></h4>
<p class="Blurb">Normalizes matrix elements.</p><pre>

virtual void  CMatrix::Normalize();
</pre><p>
This function changes values of matrix elements dividing them by their sum.
</p>


<hr><h4><a name="declCMatrix_SumAll">SumAll</a></h4>
<p class="Blurb">Returns sum of all matrix elements.</p><pre>

virtual Type  CMatrix::SumAll(int byAbsValue) const;
</pre><p><dl>
 Arguments
<dt>ByAbsValue<dd>   Summation flag:<BR>
1 stands for the summation in absolute values;<BR>
0 stands for simple summation.
</dl></p>


<hr><h4><a name="declCMatrix_InitIterator">InitIterator</a></h4>
<p class="Blurb">Initializes matrix iterator.</p><pre>

virtual CMatrixIterator&lt;Type&gt;*  CMatrix::InitIterator() const = 0;
</pre>


<hr><h4><a name="declCMatrix_Next">Next</a></h4>
<p class="Blurb">Moves iterator to next value.</p><pre>

virtual void  CMatrix::Next( CMatrixIterator&lt;Type&gt;* <EM CLASS="CodeItalic">current </EM>) const = 0;
</pre><p><dl>
 Arguments
<dt>current<dd>  Pointer to the matrix iterator.
</dl></p>


<hr><h4><a name="declCMatrix_Value">Value</a></h4>
<p class="Blurb">Returns pointer to value pointed out by iterator.</p><pre>

virtual const Type*  CMatrix::Value( CMatrixIterator&lt;Type&gt;* <EM CLASS="CodeItalic">current </EM>) const = 0;
</pre><p><dl>
 Arguments
<dt>current<dd>  Pointer to the matrix iterator.
</dl></p>


<hr><h4><a name="declCMatrix_IsValueHere">IsValueHere</a></h4>
<p class="Blurb">Returns information on existence of next value in matrix.</p><pre>

virtual int  CMatrix::IsValueHere( CMatrixIterator&lt;Type&gt;* <EM CLASS="CodeItalic">current</EM> ) const = 0;
</pre><p><dl>
 Arguments
<dt>current<dd>  Pointer to the matrix iterator.
</dl></p><p>
This function returns information on the existence of a next value in the matrix.
</p>


<hr><h4><a name="declCMatrix_Index">Index</a></h4>
<p class="Blurb">Returns indices of value of multidimensional matrix pointed out by iterator.</p><pre>

virtual void CMatrix::Index( CMatrixIterator&lt;Type&gt;* <EM CLASS="CodeItalic">current</EM>,intVector* <EM CLASS="CodeItalic">index</EM> ) const = 0;
</pre><p><dl>
 Arguments
<dt>current<dd>  Pointer to the matrix iterator.
<dt>index <dd>Output vector containing indices of the value pointed out by the iterator.
</dl></p><p>
This function returns indices of the value of the multidimensional matrix which is pouinted out by the iterator.
</p>

<hr><h3><a name="decl_pnlClassCDenseMatrix">Class CDenseMatrix</a></h3>

<p>
This class implements virtual functions declared in <EM CLASS="CodeItalic">CMatrix</EM> class and adds some
functionality relevant to its dense entity.
</p>

<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates multidimensional dense matrix. </p><pre>

static CDenseMatrix&lt;Type&gt; *CDenseMatrix&lt;Type&gt;::Create( int <EM CLASS="CodeItalic">dim</EM>, const int *<EM CLASS="CodeItalic">range</EM>, const Type *<EM CLASS="CodeItalic">data</EM>,int <EM CLASS="CodeItalic">Clamp</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>dim <dd> Number of matrix dimensions.
<dt>range<dd>  Array of lengths of matrix dimensions.
<dt>data<dd>  Data array for the matrix. Array length is the product of matrix dimension lengths.
<dt>Clamp<dd>  Status flag:<BR>
&#183; 1 means no change is allowed<BR>
&#183; 0 means change is allowed.
</dl></p><p>
This function creates a multidimensional dense matrix and returns the pointer to it.
</p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates input matrix replica.</p><pre>

static CDenseMatrix&lt;Type&gt; *CDenseMatrix&lt;Type&gt;::Copy( CDenseMatrix&lt;Type&gt;*const  <EM CLASS="CodeItalic">inputMat</EM> );
</pre><p><dl>
 Arguments
<dt>pInputMat<dd>   Pointer to <EM CLASS="CodeReg">CDenseMatrix&lt;Type&gt;</EM> object to be copied.
</dl></p>


<hr><h4><a name="decl_pnlGetRawData">GetRawData</a></h4>
<p class="Blurb">Returns matrix data and data length.</p><pre>

void *CDenseMatrix&lt;Type&gt;::GetRawData( int *<EM CLASS="CodeItalic">dataLength</EM>, const Type **<EM CLASS="CodeItalic">data </EM>) const;
</pre><p><dl>
 Arguments
<dt>dataLength<dd>   Returned parameter. Data length.
<dt>data<dd>   Returned parameter. Pointer to the data array.
</dl></p><p>
This function returns the data of the matrix and the data length.
</p>


<hr><h4><a name="decl_pnlGetRawDataLength">GetRawDataLength</a></h4>
<p class="Blurb">Returns size of raw data array.</p><pre>

inline int *CDenseMatrix&lt;Type&gt;::GetRawDataLength() const;
</pre>


<hr><h4><a name="decl_pnlSetData">SetData</a></h4>
<p class="Blurb">Sets new data for matrix.</p><pre>

void *CDenseMatrix&lt;Type&gt;::SetData( const Type* <EM CLASS="CodeItalic">NewData </EM>);
</pre><p><dl>
 Arguments
<dt>NewData <dd> Pointer to the new data array.
</dl></p><p>
This function sets new data for the matrix. Size of new data array should be equal to the raw data length, which is the product of all matrix dimensions.
</p>


<hr><h4><a name="decl_pnlGetVector">GetVector</a></h4>
<p class="Blurb">Returns pointer to vector with matrix data.</p><pre>

const pnlVector&lt;Type&gt;* GetVector() const;
</pre>


<hr><h4><a name="decl_pnlConvertMultiDimIndex">ConvertMultiDimIndex</a></h4>
<p class="Blurb">Returns offset in data array to element of dense matrix by multidimensional indices.</p><pre>

inline int *CDenseMatrix&lt;Type&gt;::ConvertMultiDimIndex( const int* <EM CLASS="CodeItalic">multidimindexes</EM> ) const;
</pre><p><dl>
 Arguments
<dt>multidimindices<dd>  Pointer to the array of multidimensional indices of the addressed matrix element. The array length is equal to the number of matrix dimensions.
</dl></p>


<hr><h4><a name="decl_pnlGetElementByOffset">GetElementByOffset</a></h4>
<p class="Blurb">Returns value of multidimensional matrix element by offset in data array.</p><pre>

inline Type *CDenseMatrix&lt;Type&gt;::GetElementByOffset(int <EM CLASS="CodeItalic">linearindex</EM>) const;
</pre><p><dl>
 Arguments
<dt>linearindex<dd>  Offset in data array to element of dense matrix.
</dl></p>


<hr><h4><a name="decl_pnlSetElementByOffset">SetElementByOffset</a></h4>
<p class="Blurb">Sets new value for matrix element by offset in data array.</p><pre>

inline void CDenseMatrix&lt;Type&gt;::SetElementByOffset( Type <EM CLASS="CodeItalic">value</EM>, int <EM CLASS="CodeItalic">offset </EM>);
</pre><p><dl>
 Arguments
<dt>value<dd>   Value to be set.
<dt>offset<dd>  Offset in data array to the element of the dense matrix
</dl></p>


<hr><h3><a name="decl_pnlClassCSparseMatrix">Class CSparseMatrix</a></h3>

<p>
The class implements virtual functions declared in <EM CLASS="CodeItalic">CMatrix</EM> class and adds some
functionality relevant to its sparse entity. This class is based on <EM CLASS="CodeItalic">CvSparseMat</EM>
implemented in OpenCv library and uses the core of this library. It also keeps the
default value of a sparse matrix. By default this value is equal to 0.

</p>

<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates multidimensional sparse matrix. </p><pre>

static CSparseMatrix&lt;Type&gt;* CSparseMatrix&lt;Type&gt;::Create( int dim, const int *range, const Type defaultValue, int Clamp = 0 );
</pre><p><dl>
 Arguments
<dt>dim<dd>   Number of the matrix dimensions.
<dt>range<dd>  Array of lengths of the matrix dimensions.
<dt>defaultValue<dd>  Default value of the sparse matrix. The default value is assumed by all the values that are not specified by <EM CLASS="CodeReg">
SetElementByIndices</EM>
() function.
<dt>Clamp<dd>  Status flag:<BR>
&#183; 1 means no change is allowed<BR>
&#183; 0 means change is allowed.
</dl></p><p>
This function creates a sparse multidimensional matrix and returns the pointer to it.
</p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates replica of input matrix.</p><pre>

static CSparseMatrix&lt;Type&gt;* CSparseMatrix&lt;Type&gt;::Copy( CSparseMatrix&lt;Type&gt;* const <EM CLASS="CodeItalic">pInputMat</EM> );
</pre><p><dl>
 Arguments
<dt>pInputMat<dd>   Pointer to the <EM CLASS="CodeReg">CSparseMatrix&lt;Type&gt;</EM> object to be copied.
</dl></p>


<hr><h4><a name="decl_pnlGetDefaultValue">GetDefaultValue</a></h4>
<p class="Blurb">Returns default value of matrix.</p><pre>

inline const Type CSparseMatrix&lt;Type&gt;::GetDefaultValue() const;
</pre>


<hr><h4><a name="decl_pnlIsExistingElement">IsExistingElement</a></h4>
<p class="Blurb">Returns information on element existence at sparse matrix.</p><pre>

inline bool CSparseMatrix&lt;Type&gt;::IsExistingElement(const int *<EM CLASS="CodeItalic">multidimindices</EM>) const;
</pre><p><dl>
 Arguments
<dt>multidimindices<dd>  Pointer to the array of multidimensional indices of the addressed matrix element. The array length is equal to the number of matrix dimensions.
</dl></p><p>
The function returns `true' if the element is kept in a sparse matrix, returns `false' otherwise.
</p>


<hr><h3><a name="decl_pnlClassCNumericDenceMatrix">Class CNumericDenseMatrix</a></h3>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates numeric multidimensional dense matrix. </p><pre>

static CNumericDenseMatrix&lt;Type&gt;* CNumericDenseMatrix&lt;Type&gt;::Create( int <EM CLASS="CodeItalic">dim</EM>, const int *<EM CLASS="CodeItalic">range</EM>, const Type *<EM CLASS="CodeItalic">data</EM>, int <EM CLASS="CodeItalic">Clamp</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>dim<dd>   Number of matrix dimensions.
<dt>range<dd>  Array of lengths of matrix dimensions.
<dt>data<dd>  Data array for the matrix. Array length is the product of matrix dimension lengths.
<dt>Clamp<dd>  Status flag:<BR>
&#183; 1 means no change is allowed<BR>
&#183; 0 means change is allowed.
</dl></p><p>
This function creates a multidimensional matrix of numeric data which is instantiated for float and double only and returns the pointer to it.
</p>


<hr><h3><a name="decl_pnlClassCNumericSparseMatrix">Class CNumericSparseMatrix</a></h3>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates multidimensional sparse matrix. </p><pre>

static CNumericSparseMatrix&lt;Type&gt;* CNumericSparseMatrix&lt;Type&gt;::Create( int <EM CLASS="CodeItalic">dim</EM>, const int *<EM CLASS="CodeItalic">range</EM>, int <EM CLASS="CodeItalic">Clamp</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>dim<dd>   Number of matrix dimensions.
<dt>range<dd>  Array of lengths of matrix dimensions.
<dt>Clamp<dd>  Status flag:<BR>
&#183; 1 means no change is allowed<BR>
&#183; 0 means change is allowed.
</dl></p><p>
This function creates a sparse multidimensional matrix of numeric data which is instantiated for <EM CLASS="CodeReg">float</EM> and <EM CLASS="CodeReg">double</EM> and returns the pointer to it. The default value used by sparse matrices is set to 0.
</p>


<hr><h3><a name="decl_pnlClassC2DNumericDenseMatrix">Class C2DNumericDenseMatrix</a></h3>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates plain numeric dense matrix.</p><pre>

static C2DNumericDenseMatrix&lt;Type&gt; *C2DNumericDenseMatrix&lt;Type&gt;::Create( const int* <EM CLASS="CodeItalic">lineSizes</EM>, const Type *<EM CLASS="CodeItalic">data</EM>, int <EM CLASS="CodeItalic">Clamp</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>lineSizes<dd>  Array of two integers, the first one is the number of rows of 2D matrix and the second one is the number of columns in the matrix.
<dt>data<dd>  Array of float matrix data in rows.
<dt>Clamp<dd>  Flag of clamping:<BR>
1 means that no change is permitted<BR>
0 means that change is permitted.
</dl></p><p>
This function creates a plain two-dimensional numeric dense matrix and returns the pointer to it.
</p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates plain matrix by copying input matrix.</p><pre>

static C2DNumericDenseMatrix&lt;Type&gt;* C2DnumericDenseMatrix&lt;Type&gt;::Copy( const iC2DNumericDenseMatrix* <EM CLASS="CodeItalic">pInpMat</EM> );
</pre><p><dl>
 Arguments
<dt>pInpMat<dd>  Pointer to the input <EM CLASS="CodeReg">C2DNumericDenseMatrix</EM> matrix.
</dl></p><p>
This function creates a plain matrix by copying the input martix.
</p>


<hr><h4><a name="decl_pnlCreateIdentityMatrix">CreateIdentityMatrix</a></h4>
<p class="Blurb">Creates matrix unit.</p><pre>

static C2DNumericDenseMatrix&lt;Type&gt;* C2DnumericDenseMatrix&lt;Type&gt;::CreateIdentityMatrix( int <EM CLASS="CodeItalic">lineSize</EM> );
</pre><p><dl>
 Arguments
<dt>lineSize<dd>  Number of rows and columns of the matrix.
</dl></p><p>
This function creates a matrix unit. All elements of this matrix are equal to 0 except the elements of the leading diagonal which are equal to unity.
</p>


<hr><h4><a name="decl_pnlIsSymmetric">IsSymmetric</a></h4>
<p class="Blurb">Checks square matrix for symmetry.</p><pre>

int C2DnumericDenseMatrix&lt;Type&gt;::IsSymmetric( Type <EM CLASS="CodeItalic">epsilon</EM> ) const;
</pre><p><dl>
 Arguments
<dt>epsilon<dd>  Precision of matrix cells comparison.
</dl></p><p>
This function checks whether the square matrix is symmetrical. This function is called for square matrices only.
</p>


<hr><h4><a name="decl_pnlTrace">Trace</a></h4>
<p class="Blurb">Returns trace of matrix.</p><pre>

Type C2DnumericDenseMatrix&lt;Type&gt;::Trace() const;
</pre>


<hr><h4><a name="decl_pnlIsIllConditioned">IsIllConditioned</a></h4>
<p class="Blurb">Checks if matrix is ill-conditioned.<DIV>
int C2DnumericDenseMatrix&lt;Type&gt;::IsIllConditioned( Type <EM CLASS="CodeItalic">conditionRatio</EM> ) const;
</pre><p><dl>
 Arguments
<dt>conditionRatio<dd>  Limit on ratio between the largest and the smallest singular values.
</dl></p><p>
This function checks the condition of the matrix comparing the ratio between the largest and the smallest singular values. If the ratio is bigger than the input ratio the member function returns 1, returns 0 otherwise.
</p>


<hr><h4><a name="decl_pnlDeterminant">Determinant</a></h4>
<p class="Blurb">Returns matrix determinant.</p><pre>

Type C2DnumericDenseMatrix&lt;Type&gt;::Determinant() const;
</pre><p>
This function returns the determinant of a plain square matrix.
</p>


<hr><h4><a name="decl_pnlInverse">Inverse</a></h4>
<p class="Blurb">Returns pointer to inverse matrix.</p><pre>

C2DNumericDenseMatrix&lt;Type&gt;* C2DnumericDenseMatrix&lt;Type&gt;::nverse() const;
</pre><p>
This function returns the pointer to the matrix inverse to the given flat square matrix.The function throws exception if the matrix is ill-conditioned.
</p>


<hr><h4><a name="decl_pnlTranspose">Transpose</a></h4>
<p class="Blurb">Transposes matrix.</p><pre>

C2DNumericDenseMatrix&lt;Type&gt;* C2DnumericDenseMatrix&lt;Type&gt;::Transpose()const;
</pre><p>
This function returns pointer to the transposed matrix.
</p>


<hr><h4><a name="decl_pnlGetLinearBlocks">GetLinearBlocks</a></h4>
<p class="Blurb">Breaks linear matrix into blocks.</p><pre>

void C2DnumericDenseMatrix&lt;Type&gt;::GetLinearBlocks( const int *<EM CLASS="CodeItalic">X</EM>, int <EM CLASS="CodeItalic">xSize</EM>,const int *<EM CLASS="CodeItalic">blockSizes</EM>, int <EM CLASS="CodeItalic">numBlocks</EM>, C2DNumericDenseMatrix&lt;Type&gt; **<EM CLASS="CodeItalic">matXOut</EM>, C2DNumericDenseMatrix&lt;Type&gt; **<EM CLASS="CodeItalic">matYOut</EM> ) const;
</pre><p><dl>
 Arguments
<dt>X<dd>  Pointer to the array of numbers of blocks that should enter matrix X.
<dt>xSize<dd>  Number of blocks that should enter matrix X.
<dt>blockSizes<dd>  Array of block sizes.
<dt>numBlocks<dd>  Number of blocks.
<dt>matXOut<dd>  Returned parameter. Pointer to the matrix of blocks that correspond to their numbers in matrix <EM CLASS="CodeItalic">X</EM>.
<dt>matYOut<dd>  Returned parameter. Pointer to the matrix of blocks that do not belong to matrix <EM CLASS="CodeItalic">
X</EM>.
</dl></p><p>
This function breaks the matrix with dimension sizes<EM CLASS="CodeItalic"> 1</EM> and <EM CLASS="CodeItalic">N</EM> into the matrix with sizes <EM CLASS="CodeItalic">1</EM> and <EM CLASS="CodeItalic">K</EM>, <EM CLASS="CodeItalic">1</EM> and <EM CLASS="CodeItalic">M</EM>, where <EM CLASS="CodeItalic">K+M = N.</EM>
The matrix is divided into two parts which are related to two matrices. The resulting matrices are formed by assembling all the parts one-by-one.
</p>


<hr><h4><a name="decl_pnlGetBlocks">GetBlocks</a></h4>
<p class="Blurb">Breaks matrix into blocks.</p><pre>

void C2DnumericDenseMatrix&lt;Type&gt;::GetBlocks( const int *<EM CLASS="CodeItalic">X</EM>, int <EM CLASS="CodeItalic">xSize</EM>,const int *<EM CLASS="CodeItalic">blockSizes</EM>, int <EM CLASS="CodeItalic">numBlocks</EM>, C2DNumericDenseMatrix&lt;Type&gt; **<EM CLASS="CodeItalic">matXOut</EM>, C2DNumericDenseMatrix&lt;Type&gt; **<EM CLASS="CodeItalic">matYOut</EM>, C2DNumericDenseMatrix&lt;Type&gt; **<EM CLASS="CodeItalic">matXYOut</EM>, C2DNumericDenseMatrix&lt;Type&gt; **<EM CLASS="CodeItalic">matYXOut</EM> )const;
</pre><p><dl>
 Arguments
<dt>X<dd>  Pointer to the array of numbers of blocks that should enter matrix X.
<dt>xSize<dd>  Number of blocks that should enter matrix X.
<dt>blockSizes<dd>  Array of block sizes.
<dt>numBlocks<dd>  Number of blocks.
<dt>matXOut<dd>  Returned parameter. Pointer to the matrix of blocks that correspond to their numbers in matrix X.
<dt>matYOut<dd>  Returned parameter. Pointer to the matrix of blocks that do not belong to matrix X.
<dt>matXYOut<dd>  Returned parameter. Pointer to the matrix of blocks XY.
<dt>matYXOut<dd>  Returned parameter. Pointer to the matrix of blocks YX.
</dl></p><p>
This function breaks a flat square matrix into blocks, creates new matrices of the resulting blocks and returns the newly created matrices as arguments <EM CLASS="CodeItalic">matX</EM>, <EM CLASS="CodeItalic">matY</EM>, <EM CLASS="CodeItalic">matXY</EM>, and <EM CLASS="CodeItalic">matYX</EM>. Breaking of a matrix into a bigger number of blocks is carried out similarly. Returned matrices are created by placing blocks in accordance with their initial locations.
</p>


<hr><h4><a name="decl_pnlpnlMultiply">pnlMultiply</a></h4>
<p class="Blurb">Creates new matrix out of two source matrices.</p><pre>

friend PNL_API C2DNumericDenseMatrix&lt;Type&gt;* C2DnumericDenseMatrix&lt;Type&gt;::pnlMultiply( const C2DNumericDenseMatrix&lt;Type&gt;* <EM CLASS="CodeItalic">pxMatrix1</EM>,const C2DNumericDenseMatrix&lt;Type&gt;* <EM CLASS="CodeItalic">pxMatrix2</EM>, int <EM CLASS="CodeItalic">maximize</EM> );
</pre><p><dl>
 Arguments
pxMatrix1</EM>
  Pointer to the first matrix.
pxMatrix2</EM>
  Pointer to the second matrix.
<dt>maximize<dd>  Flag index:<BR>
1 stands for the maximum value<BR>
0 stands for a pair-wise product of the values.
</dl></p><p>
This function returns the pointer to a new matrix which is created out of two source matrices multiplied row-by-column. The source matrices should have at least one dimension of the same length.
</p>


<hr><h2><a name="decl_pnlReference_Counter">Reference Counter</a></h2>



<hr><h3><a name="decl_pnlClassCReferenceCounter">Class CReferenceCounter</a></h3>

<p>
Class<EM CLASS="CodeItalic"> </EM><EM CLASS="CodeReg">CReferenceCounter</EM> helps to attach an object to other objects. A <EM CLASS="CodeReg">
CReferenceCounter </EM>object cannot be created separately because it contains neither a public constructor nor a friendly function to call a constructor. A <EM CLASS="CodeReg">CReferenceCounter</EM> class object is created with a <EM CLASS="CodeReg">CMatrix</EM> object or a <EM CLASS="CodeReg">CModelDomain</EM>
 object. Class <EM CLASS="CodeReg">CReferenceCounter</EM> is designed to store pointers to related objects. A <EM CLASS="CodeReg">CReferenceCounter</EM>
 object may be deleted only if it is not associated with any other object. </P><P CLASS="Body"><A NAME="pgfId-73135"></A>There are two versions of the class: debug and release. The debug version stores pointers to referenced objects and finds them while calling Release(). The release version stores only the number of references, and either increases or decreases it.
</p>





<hr><h4><a name="decl_pnlAddRef">AddRef</a></h4>
<p class="Blurb">Increases number of references.</p><pre>

inline void CReferenceCounter:: AddRef( void* <EM CLASS="CodeItalic">pObject</EM> );
</pre><p><dl>
 Arguments
<dt>pObject<dd> Pointer to the object referenced to the <EM CLASS="CodeReg">CReferenceCounter</EM> object.
</dl></p>


<hr><h4><a name="declCReferenceCounter_Release">Release</a></h4>
<p class="Blurb">Decreases number of references.</p><pre>

inline void CReferenceCounter::Release( void* <EM CLASS="CodeItalic">pObject</EM> );
</pre><p><dl>
 Arguments
<dt>pObject <dd>Pointer to the object referenced to the <EM CLASS="CodeReg">CReferenceCounter</EM> object.
</dl></p>


<hr><h4><a name="declCReferenceCounter_GetNumberOfReferences">GetNumberOfReferences</a></h4>
<p class="Blurb">Returns number of referenced objects.</p><pre>

inline int CReferenceCounter::GetNumberOfReferences() const;
</pre>


<hr><h2><a name="decl_pnlInference_Engines">Inference Engines</a></h2>


<IMG SRC="fig/PNLMarch.book-126.gif">


<hr><h3><a name="decl_pnlClassCInfEngine">Class CInfEngine</a></h3>

<p>
Class <EM CLASS="CodeReg">CInfEngine</EM> is basic for all classes that implement inference in graphical models. The class contains functions that belong to its child classes.
</p>


<hr><h4><a name="declCInfEngine_pnlDetermineDistributionType">pnlDetermineDistributionType</a></h4>
<p class="Blurb">Returns type of distribution.</p><pre>

EDistributionType CInfEngine::pnlDetermineDistributionType( int <EM CLASS="CodeItalic">numOfAllNds</EM>, int <EM CLASS="CodeItalic">numOfObsNds</EM>, int *<EM CLASS="CodeItalic">pObsNdsIndices</EM>, const CNodeType **<EM CLASS="CodeItalic">pAllNdsTypes </EM>);
</pre><p><dl>
 Arguments
<dt>numOfAllNds<dd>  Number of all nodes.
<dt>NumOfObsNds<dd>  Number of the observed nodes.
<dt>pObsNdsIndices<dd>  Pointer to the array of indices of the observed nodes.
<dt>pAllNdsTypes<dd>  Pointer to the array of pointers to all node types.
</dl></p><p>
This function returns the following node distribution types:
</p>


<hr><h4><a name="declCInfEngine_pnlDetermineDistributionType">pnlDetermineDistributionType</a></h4>
<p class="Blurb">Returns  type of distribution.</p><pre>

EDistributionType CInfEngine::pnlDetermineDistributionType(const CModelDomain* <EM CLASS="CodeItalic">pMD</EM>, int <EM CLASS="CodeItalic">nQueryNodes</EM>, const int* <EM CLASS="CodeReg">query</EM>, const CEvidence* <EM CLASS="CodeItalic">pEv</EM> );
</pre><p><dl>
 Arguments
<dt>pMD <dd>Model domain.
<dt>nQueryNodes<dd>  Number of query nodes.
<dt>query <dd>Query nodes.
<dt>pEv <dd>Evidence.
</dl></p><p>
This function returns the following node distribution types:
</p>


<hr><h4><a name="declCInfEngine_EnterEvidence">EnterEvidence</a></h4>
<p class="Blurb">Starts inference in graphical model.</p><pre>

void CInfEngine::EnterEvidence( CEvidence *<EM CLASS="CodeItalic">evidence</EM>, int <EM CLASS="CodeItalic">maximize</EM> = 0, int <EM CLASS="CodeItalic">sumOnMixtureNode</EM> = 1 ) = 0;
</pre><p><dl>
 Arguments
<dt>evidence<dd>  Pointer to a <EM CLASS="CodeReg">
CEvidence</EM>
 object that contains the observed nodes and their values.
<dt>maximize<dd>  Optional parameter used in Pearl Inference for selection of message transmission type.
<dt>sumOnMixtureNode  <dd>Flag of summation  on the mixture node.
</dl></p><p>
This function starts inference in the graphical model. Principal operations are performed either on call of this function or on call of the function <EM CLASS="CodeReg"><a href="#declCCPD_MarginalNodes">MarginalNodes</A></EM>, depending on what inference type is implemented.
</p>


<hr><h4><a name="declCInfEngine_MarginalNodes">MarginalNodes</a></h4>
<p class="Blurb">Calculates joint probability distribution.</p><pre>

void CInfEngine::MarginalNodes( const int *<EM CLASS="CodeItalic">query</EM>, int <EM CLASS="CodeItalic">querySize, </EM><EM CLASS="CodeReg">int</EM><EM CLASS="CodeItalic"> nodeExpandJPD </EM><EM CLASS="CodeReg">= 1</EM> ) = 0;
void CInfEngine::MarginalNodes( const intVector&amp; <EM CLASS="CodeItalic">query</EM>, <EM CLASS="CodeReg">int</EM><EM CLASS="CodeItalic"> nodeExpandJPD </EM><EM CLASS="CodeReg">= 1);</EM></P></pre><p><dl>
 Arguments
<dt>query<dd>  Array of numbers of the nodes addressed for the joint probability distribution.
<dt>querySize<dd>  Number of nodes addressed for joint probability distribution.
<dt>nodeExpandJPD <dd>Flag of the expand operation.
</dl></p><p>
This function calculates joint probability distribution for nodes addressed. In process of calculations <A NAME="Most Probability Explanation"></A>Most Probability Explanation (MPE) is also created as a<EM CLASS="CodeReg"><a href="#decl_pnlClassCModel_Domain">Model Domain</A></EM> object for the calculated probability distribution. To receive MPE and the factor, special functions should be used.
</p>


<hr><h4><a name="decl_pnlGetQueryJPD">GetQueryJPD</a></h4>
<p class="Blurb">Returns <EM CLASS="CodeReg">const</EM> pointer to joint probability distribution.
</p><pre>

const CFactor* CInfEngine::GetQueryJPD() const;
</pre><p>
This function returns to joint probability distribution calculated by using the function <EM CLASS="CodeReg"><a href="#declCPotential_MarginalNodes">MarginalNodes</A></EM>. The returned pointer is <EM CLASS="CodeReg">const</EM>, as the memory is released when the <EM CLASS="CodeReg">CInfEngine</EM>
 object is deleted or when <EM CLASS="CodeReg">MarginalNodes</EM> is called again.
</p>


<hr><h4><a name="declCInfEngine_GetMPE">GetMPE</a></h4>
<p class="Blurb">Returns MPE.</p><pre>

const CEvidence* CInfEngine::GetMPE() const;
</pre><p>
This function returns to most probability explanation calculated by using the function <EM CLASS="CodeReg"><a href="#declCPotential_MarginalNodes">MarginalNodes</A></EM>. The returned pointer is <EM CLASS="CodeReg">const</EM>, as the memory is released when the <EM CLASS="CodeReg">CInfEngine</EM> object is deleted or when <EM CLASS="CodeReg">MarginalNodes</EM> is called again.
</p>


<hr><h4><a name="declCInfEngine_GetModel">GetModel</a></h4>
<p class="Blurb">Returns pointer to graphical model processed by inference engine.</p><pre>

inline CStaticGraphicalModel * CInfEngine::GetModel() const;
</pre><p>
This function returns the pointer to the graphical model which is processed by the infrence engine. This function is necessary for operation of learning algorithms.
</p>


<hr><h4><a name="declCInfEngine_GetObsGauNodeType">GetObsGauNodeType</a></h4>
<p class="Blurb">Returns type of observed Gaussian node.</p><pre>

inline static const CNodeType* CInfEngine::GetObsGauNodeType();
</pre>


<hr><h4><a name="declCInfEngine_GetObsTabNodeType">GetObsTabNodeType</a></h4>
<p class="Blurb">Returns type of observed Tabular node.</p><pre>

inline static const CNodeType* CInfEngine::GetObsTabNodeType();
</pre>


<hr><h3><a name="decl_pnlClassCNaiveInfEngine">Class CNaiveInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-128.gif">


<hr><h4><a name="declCNaiveInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CNaiveInfEngine* CNaiveInfEngine::Create( CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel </EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a model, for which inference algorithm is to be carried out. Note, that it can either be an <EM CLASS="CodeReg">
MRF</EM> (<EM CLASS="CodeReg">MRF2</EM>) or a <EM CLASS="CodeReg">BNet</EM>.
</dl></p>


<hr><h3><a name="decl_pnlClassCPearlInfEngine">Class CPearlInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-129.gif">


<hr><h4><a name="declCPearlInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CPearlInfEngine* CPearlInfEngine::Create( CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel </EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a model, for which inference algorithm is to be carried out. Note, that it can either be an <EM CLASS="CodeReg">
MRF2</EM> or a <EM CLASS="CodeReg">BNet</EM>. The input <EM CLASS="CodeReg">BNet</EM> cannot have directed cycles in it.
</dl></p><p>
This function creates a Pearl Inference algorithm object from an input graphical model and returns a pointer to it. Note, that the result of inference is exact, if the graph of the input model (<EM CLASS="CodeReg">
<a href="#decl_pnlClassCBNet">Class CBNet</A></EM> or <EM CLASS="CodeReg"><a href="#decl_pnlClassMRF2">Class CMRF2</A></EM>) does not have undirected loops in it. If it does, then the result is approximate.
</p>


<hr><h4><a name="declCPearlInfEngine_IsInputModelValid">IsInputModelValid</a></h4>
<p class="Blurb">Checks validity of model for use in Pearl inference.</p><pre>

static bool CPearlInfEngine::IsInputModelValid( const CCsaticGraphicalModel *s<EM CLASS="CodeItalic">pGrModel </EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd>Pointer to the graphical model.
</dl></p>


<hr><h4><a name="declCPearlInfEngine_SetMaxNumberOfIterations">SetMaxNumberOfIterations</a></h4>
<p class="Blurb">Sets maximum number of iterations for parallel protocol.</p><pre>

inline void CPearlInfEngine::SetMaxNumberOfIterations(int <EM CLASS="CodeItalic">maxNumOfIters</EM>);
</pre><p><dl>
 Arguments
<dt>maxNumOfIters <dd>Maximum number of iterations.
</dl></p><p>
This function sets a maximum number of iterations for the parallel protocol.
</p>


<hr><h4><a name="declCPearlInfEngine_GetNumberOfProvideIterations">GetNumberOfProvideIterations</a></h4>
<p class="Blurb">Returns number of  iterations performed.</p><pre>

inline int CPearlInfEngine::GetNumberOfProvideIterations() const;
</pre>


<hr><h4><a name="declCPearlInfEngine_SetTolerance">SetTolerance</a></h4>
<p class="Blurb">Sets tolerance for convergency check.</p><pre>

inline  void CPearlInfEngine::SetTolerance( float <EM CLASS="CodeItalic">tolerance </EM>);
</pre><p><dl>
 Arguments
<dt>tolerance <dd>Input parameter. Precision.
</dl></p>


<hr><h3><a name="decl_pnlClassCSpecPearlInfEngine">Class CSpecPearlInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-130.gif">

<p>
This class is a realisation of Pearl Inference that does not allocate memory during the
inference procedure.
</p>


<hr><h4><a name="declCSpecPearlInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CSpecPearlInfEngine* CSpecPearlInfEngine::Create(CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel </EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a model, for which inference algorithm is to be carried out. Note, that it can either be an <EM CLASS="CodeReg">
MRF2</EM> or a <EM CLASS="CodeReg">BNet</EM>. The input <EM CLASS="CodeReg">BNet</EM> cannot have directed cycles in it.
</dl></p><p>
This function creates a Pearl Inference algorithm object from an input graphical model and returns a pointer to it. Note, that the result of inference is exact, if the graph of the input model (<EM CLASS="CodeReg"><a href="#decl_pnlClassCBNet">Class CBNet</A></EM> or <EM CLASS="CodeReg">
<a href="#decl_pnlClassCMRF2">Class CMRF2</A></EM>) does not have undirected loops in it. If it does, then the result is approximate.
</p>


<hr><h4><a name="declCSpecPearlInfEngine_IsInputModelValid">IsInputModelValid</a></h4>
<p class="Blurb">Checks validity of model for use in Pearl inference.</p><pre>

static bool  CSpecPearlInfEngine::IsInputModelValid( const CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel</EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd>Pointer to the graphical model.
</dl></p>


<hr><h4><a name="decl_pnlSetMaxNumberOfIterations">SetMaxNumberOfIterations</a></h4>
<p class="Blurb">Sets maximum number of iterations for parallel protocol.</p><pre>


inline void  CSpecPearlInfEngine::SetMaxNumberOfIterations(int <EM CLASS="CodeItalic">maxNumOfIters</EM>)
</pre><p><dl>
 Arguments
<dt>maxNumOfIters <dd>Maximum number of iterations.
</dl></p><p>
This function sets a maximum number of iterations for the parallel protocol.
</p>


<hr><h4><a name="declCSpecPearlInfEngine_GetNumberOfProvideIterations">GetNumberOfProvideIterations</a></h4>
<p class="Blurb">Returns number of  iterations performed.</p><pre>

inline int CSpecPearlInfEngine::GetNumberOfProvideIterations() const;
</pre>


<hr><h4><a name="declCSpecPearlInfEngine_SetTolerance">SetTolerance</a></h4>
<p class="Blurb">Sets tolerance for convergency check.</p><pre>

inline  void CSpecPearlInfEngine::SetTolerance( float <EM CLASS="CodeItalic">tolerance </EM>);
</pre><p><dl>
 Arguments
<dt>tolerance <dd>Input parameter. Precision.
</dl></p>


<hr><h3><a name="decl_pnlClassCJTreeInfEngine">Class CJTreeInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-131.gif">


<hr><h4><a name="declCJtreeInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CJtreeInfEngine* CJtreeInfEngine::Create( const CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel</EM>,<EM CLASS="CodeItalic"> </EM>int <EM CLASS="CodeItalic">numOfSubGrToConnect</EM>, const int *<EM CLASS="CodeItalic">SubGrToConnectSizes</EM>, int **<EM CLASS="CodeItalic">SubGrToConnect </EM>);
static CJtreeInfEngine* CJtreeInfEngine::Create( const CStaticGraphicalModel*<EM CLASS="CodeItalic">pGrModel</EM>, const intVecVector&amp; <EM CLASS="CodeItalic">SubGrToConnect</EM> = intVecVector() );
static CJtreeInfEngine* CJtreeInfEngine::Create( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM>, CJunctionTree *<EM CLASS="CodeItalic">pJTree</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a model, for which inference algorithm is to be carried out. Note, that it can either be an <EM CLASS="CodeReg">
MRF2</EM> or a <EM CLASS="CodeReg">BNet</EM>. The input <EM CLASS="CodeReg">BNet</EM> cannot have directed cycles in it.
<dt>numOfSubGrToConnect<dd>  Number of subgraphs, which the user wants to appear connected.
<dt>SubGrToConnect  <dd>Nodes to be connected.
<dt>SubGrToConnectSizes<dd>  Sizes of the subgraphs, which the user wants to appear connected.
<dt>pJTree  <dd>Pointer to the Junction tree.
</dl></p>


<hr><h4><a name="decl_pnlCopy">Copy</a></h4>
<p class="Blurb">Creates replica of <EM CLASS="CodeReg">CJTreeInfEngine</EM> object.
</p><pre>

static CJtreeInfEngine* CJtreeInfEngine::Copy( const CJtreeInfEngine *<EM CLASS="CodeItalic">pJTreeInfEng </EM>);
</pre><p><dl>
 Arguments
<dt>pJTreeInfEng  <dd>Pointer to the Junction tree inference engine.
</dl></p>


<hr><h4><a name="declCJtreeInfEngine_GetEvidence">GetEvidence</a></h4>
<p class="Blurb">Returns pointer to the evidence which was provided.</p><pre>

inline const CEvidence* CJtreeInfEngine::GetEvidence() const;
</pre>


<hr><h4><a name="declCJtreeInfEngine_GetJTreeRootNode">GetJTreeRootNode</a></h4>
<p class="Blurb">Returns number of root node.</p><pre>

inline int CJtreeInfEngine::GetJTreeRootNode() const;
</pre><p>
This function returns the number of the root node of the Junctin tree.
</p>


<hr><h4><a name="declCJtreeInfEngine_GetClqNumsContainingSubset">GetClqNumsContainingSubset</a></h4>
<p class="Blurb">Returns numbers of Junction tree cliques with common subset of nodes.</p><pre>

inline void CJtreeInfEngine::GetClqNumsContainingSubset( int <EM CLASS="CodeItalic">numOfNdsInSubset</EM>, const int *<EM CLASS="CodeItalic">subset</EM>, int *<EM CLASS="CodeItalic">numOfClqs</EM>, const int **<EM CLASS="CodeItalic">clqsContSubset</EM> ) const;
inline void CJtreeInfEngine::GetClqNumsContainingSubset( const intVector&amp; <EM CLASS="CodeItalic">subset</EM>, intVector* <EM CLASS="CodeItalic">clqsContSubset</EM> ) const;
</pre><p><dl>
 Arguments
<dt>numOfNdsInSubset  <dd>Size of the subset.
<dt>subset  <dd>Subset of nodes.
<dt>numOfClqs <dd>Returned parameter. Number of cliques with the common subset.
<dt>clqsContSubset<dd>  Returned parameter. Array of numbers of cliques with the common subset.
</dl></p><p>
This function returns numbers to the Junction tree cliques that have a common subset of nodes.
</p>


<hr><h4><a name="declCJtreeInfEngine_GetNodesConnectedByUser">GetNodesConnectedByUser</a></h4>
<p class="Blurb">Returns set of connected nodes.</p><pre>

inline void CJtreeInfEngine::GetNodesConnectedByUser( int <EM CLASS="CodeItalic">nodeSetNum</EM>, int *<EM CLASS="CodeItalic">numOfNds</EM>, const int **<EM CLASS="CodeItalic">nds</EM> ) const;
</pre><p><dl>
 Arguments
<dt>nodeSetNum  <dd>Number of the set of nodes.
<dt>numOfNds  <dd>Return parameter. Size of the set of nodes.
<dt>nds <dd>Return parameter. Pointer to the set of nodes.
</dl></p><p>
This function returns the set of nodes which were connected when the Junction tree was created.
</p>


<hr><h4><a name="declCJtreeInfEngine_SetJTreeRootNode">SetJTreeRootNode</a></h4>
<p class="Blurb">Sets root of Junction tree.</p><pre>

inline virtual void CJtreeInfEngine::SetJTreeRootNode( int <EM CLASS="CodeItalic">nodeNum </EM>) const;
</pre><p><dl>
 Arguments
<dt>nodeNum<dd>  Node number.
</dl></p><p>
This function turns a given node of the Junction tree into its root node.
</p>


<hr><h4><a name="declCJtreeInfEngine_GetLogLik">GetLogLik</a></h4>
<p class="Blurb">Returns logarithm of likelihood.</p><pre>

virtual float CJtreeInfEngine::GetLogLik() const;
</pre>


<hr><h4><a name="declCJtreeInfEngine_MultJTreeNodePotByDistribFun">MultJTreeNodePotByDistribFun</a></h4>
<p class="Blurb">Multiplies potential of Junctin tree node by distribution function.</p><pre>

virtual void  CJtreeInfEngine::MultJTreeNodePotByDistribFun(  int <EM CLASS="CodeItalic">clqPotNum</EM>, const int *<EM CLASS="CodeItalic">domainIn</EM>, const CDistribFun *<EM CLASS="CodeItalic">pDistrFunIn</EM> );
</pre><p><dl>
 Arguments
<dt>clqPotNum <dd>Number of  a clique of the potential.
<dt>domain  <dd>Numbers of domain nodes.
<dt>pDistrFun <dd>Pointer to the distribution function.
</dl></p><p>
This function multiplies the potential of a Junction tree node by the distribution function.
</p>


<hr><h4><a name="declCJtreeInfEngine_DivideJTreeNodePotByDistribFun">DivideJTreeNodePotByDistribFun</a></h4>
<p class="Blurb">Multiplies potential of Junctin tree node by distribution function.</p><pre>

virtual void CJtreeInfEngine::DivideJTreeNodePotByDistribFun(  int <EM CLASS="CodeItalic">clqPotNum</EM>, const int *<EM CLASS="CodeItalic">domainIn</EM>, const CDistribFun *<EM CLASS="CodeItalic">pDistrFunIn</EM> );
</pre><p><dl>
 Arguments
<dt>clqPotNum <dd>Number of  a clique of the potential.
<dt>domain  <dd>Numbers of domain nodes.
<dt>pDistrFun <dd>Pointer to the distribution function.
</dl></p><p>
This function divides the potential of a Junction tree node by the distribution function.
</p>


<hr><h4><a name="declCJtreeInfEngine_CollectEvidence">CollectEvidence</a></h4>
<p class="Blurb">Collects evidence.</p><pre>

virtual void CJtreeInfEngine::CollectEvidence();
</pre>

<hr><h4><a name="declCJtreeInfEngine_DistributeEvidence">DistributeEvidence</a></h4>
<p class="Blurb">Distributes evidence.</p><pre>

virtual void CJtreeInfEngine::DistributeEvidence();
</pre>


<hr><h4><a name="declCJtreeInfEngine_ShrinkObserved">ShrinkObserved</a></h4>
<p class="Blurb">Initializes Junction tree using given evidence.</p><pre>

virtual void CJtreeInfEngine::ShrinkObserved( const CEvidence *<EM CLASS="CodeItalic">pEvidence</EM>, int <EM CLASS="CodeItalic">maximize</EM> = 0, int <EM CLASS="CodeItalic">sumOnMixtureNode</EM> = 1, bool <EM CLASS="CodeItalic">bRebuildJTree</EM> = true );
</pre><p><dl>
 Arguments
<dt>pEvidence <dd>Pointer to evidence.
<dt>maximize  <dd>Flag of maximization.
<dt>sumOnMixtureNode  <dd>Flag of summation on the mixture node.
<dt>bRebuildJTree <dd>Flag of the Junction tree rebuilding.
</dl></p><p>
This function initializes a Junction tree  using  given evidence.
</p>


<hr><h4><a name="declCJtreeInfEngine_QueryMPE">QueryMPE</a></h4>
<p class="Blurb">Returns most probable distribution.</p><pre>

const *CPotential CJtreeInfEngine::QueryMPE() const;
</pre>


<hr><h3><a name="decl_pnlClassCLIMIDInfEngine">Class CLIMIDInfEngine</a></h3>

<hr><h4><a name="declCLIMIDInfEngine_Create">Create</a></h4>
<p class="Blurb">Returns CLIMIDInfEngine class object</p>
<pre>static CLIMIDInfEngine* Create(const CStaticGraphicalModel *pGM);  </pre>
<p><dl> 
 Arguments  
<dt>pGM <dd>Pointer to a model, for which inference algorithm is to be carried out. 
</dl></p>
<b><p>Discussion  </p></b>
<p>This function creates a LIMID Inference algorithm object from an input graphical model and returns a pointer to it.</p>


<hr><h4><a name="declCLIMIDInfEngine_Release">Release</a></h4>
<p class="Blurb">Destroys the inference engine.</p>

<pre>static void Release(CLIMIDInfEngine** pInfEng);  </pre>
<p><dl> 
 Arguments  
<dt>pInfEngine <dd>Pointer to a CLIMIDInfEngine object, which we are going to destroy. 
</dl></p> 

<hr><h4><a name="declCLIMIDInfEngine_SetIterMax">SetIterMax</a></h4>
<p class="Blurb">Sets maximum quantity of iterations</p>
 
<pre>void SetIterMax(int IterMax);  </pre>
<p><dl> 
 Arguments  
<dt>IterMax <dd>New value of maximum quantity of iterations. 
</dl></p> 

<hr><h4><a name="declCLIMIDInfEngine_DoInference">DoInference</a></h4>
<p class="Blurb">Main method, which does inference in Limited Memory Influence Diagrams. </p>

<pre>void DoInference();  </pre>


<hr><h4><a name="declCLIMIDInfEngine_GetPolitics">GetPolitics</a></h4>
<p class="Blurb">Get optimal politics after the inference. </p>

<pre>pFactorVector* GetPolitics(void) const;  </pre>

<hr><h4><a name="declCLIMIDInfEngine_GetExpectation">GetExpectation</a></h4>
<p class="Blurb">Gets expectation after the inference. </p>
 
<pre>float GetExpectation(); </pre>


<hr><h3><a name="decl_pnlClassCExInfEngine">Class CExInfEngine</a></h3>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates  class object.</p><pre>

static CExInfEngine&lt; INF_ENGINE, MODEL, FLAV, FALLBACK_ENGINE1, FALLBACK_ENGINE2 &gt; *CExInfEngine::Create( CStaticGraphicalModel const *<EM CLASS="CodeItalic">model</EM> );
</pre><p><dl>
 Arguments
<dt>model<dd>  Graphical model.
</dl></p><p>
Creates an object of the class.
</p>


<hr><h3><a name="decl_pnlClassCFGumMaxInfEngine">Class CFGSumMaxInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-133.gif">

<p>
The class implements belief propagation on a factor graph model.
</p>

<hr><h4><a name="declCFGSunMaxInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates object of class.</p><pre>

static CFGSumMaxInfEngine* CFGSumMaxInfEngine::Create( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM> );
</pre><p><dl>
 Arguments
<dt>PGrModel<dd>  Pointer to a model, for which inference is to be carried out.
</dl></p><p>
This function creates an object of the class. Inference is carried out for <EM CLASS="CodeReg">
FactorGraph</EM>
 models only.
</p>


<hr><h4><a name="declCFGSumMaxInfEngine_SetMaxNumberOfIterations">SetMaxNumberOfIterations</a></h4>
<p class="Blurb">Sets maximum number of iterations for inference.</p><pre>

void CFGSumMaxInfEngine::SetMaxNumberOfIterations( int <EM CLASS="CodeItalic">number</EM> );
</pre><p><dl>
 Arguments
<dt>number<dd>  Maximum number of iterations.
</dl></p><p>
This function sets the maximum number of iterations for the inference procedure.
</p>


<hr><h4><a name="declCCFGSumMaxInfEngine_GetNumberOfProvideIterations">GetNumberOfProvideIterations</a></h4>
<p class="Blurb">Returns number of iterations provided during inference.</p><pre>

inline int CFGSumMaxInfEngine::GetNumberOfProvideIterations() const;

</pre></dl></p>


<hr><h4><a name="declCCFGSumMaxInfEngine_SetTolerance">SetTolerance</a></h4>
<p class="Blurb">Sets value of tolerance used for check-up convergence. <DIV>
void CFGSumMaxInfEngine::SetTolerance( float tolerance);
</pre><p><dl>
 Arguments
<dt>tolerance<dd>  Tolerance value.
</dl></p><p>
This function sets the value of tolerance which is used in the process of convergence checking.
</p>



<hr><h3><a name="decl_pnlClassCSamplingInfEngine">Class CSamplingInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-134.gif">
<p>
Class <EM CLASS="CodeReg">CSamplingInfEngine</EM> is a superclass for classes <EM CLASS="CodeReg">CGibbsSamplingInfEngine</EM> and <EM CLASS="CodeReg">CGibbsWithAnnealingInfEngine</EM> that implement inference in static graphical models using stochastic simulates technique known as Markov chain Monte Carlo. This technique generates samples from the required posterior distribution. Inference constructs Markov chain with stationary distribution.
</p>



<hr><h4><a name="declCSamplingInfEngine_SetMaxTime">SetMaxTime</a></h4>
<p class="Blurb">Sets maximum number of sampling iterations.</p><pre>

void CSamplingInfEngine::SetMaxTime( int <EM CLASS="CodeItalic">time</EM> );
</pre><p><dl>
 Arguments
<dt>time  <dd>Maximum number of iterations.
</dl></p><p>
This function sets the maximum number of sampling iterations.
</p>


<hr><h4><a name="declCSamplingInfEngine_SetBurnIn">SetBurnIn</a></h4>
<p class="Blurb">Sets number of iterations before statistics collection.</p><pre>

void CSamplingInfEngine::SetBurnIn(int <EM CLASS="CodeItalic">time</EM>);
</pre><p><dl>
 Arguments
<dt>time  <dd>Number of iterations.
</dl></p><p>
This function sets the number of iterations before the statistical data is collected.
</p>


<hr><h4><a name="declCSamplingInfEngine_SetNumStreams">SetNumStreams</a></h4>
<p class="Blurb">Sets number of streams for sampling.</p><pre>

void CSamplingInfEngine::SetNumStreams( int <EM CLASS="CodeItalic">nStreams </EM>);
</pre><p><dl>
 Arguments
<dt>nStreams  <dd>Number of streams.
</dl></p><p>
This function sets the number of independent streams for sampling.
</p>


<hr><h4><a name="declCSamplingInfEngine_GetMaxTime">GetMaxTime</a></h4>
<p class="Blurb">Returns maximum number of sampling iterations.</p><pre>

int CSamplingInfEngine::GetMaxTime();
</pre><p>
This function returns the maximum number of sampling iterations.
</p>


<hr><h4><a name="declCSamplingInfEngine_GetBurnIn">GetBurnIn</a></h4>
<p class="Blurb">Returns number of iterations before statistics collection.</p><pre>

int CSamplingInfEngine::GetBurnIn();
</pre><p>
This function returns the number of iterations before the statistical data is collected.
</p>
</pre></dl></p>


<hr><h4><a name="decl_pnlGetNumStreams">GetNumStreams</a></h4>
int CSamplingInfEngine::GetNumStreams();
</pre><p>
This function returns the number of sampling streams.
</p>
</pre></dl></p>


<hr><h4><a name="declCSamplingInfEngine_Continue">Continue</a></h4>
<p class="Blurb">Continues sampling. </p><pre>

void CSamplingInfEngine::Continue( int <EM CLASS="CodeItalic">dT</EM>);
</pre><p><dl>
 Arguments
<dt>dT  <dd>Number of additional samples.
</dl></p><p>
This function continues sampling procedure and statistics update.
</p>


<hr><h3><a name="decl_pnlClassCGibbsSamplingInfEngine">Class CGibbsSamplingInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-140.gif">


<hr><h4><a name="declCGibbsSamplingInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CGibbsSamplingInfEngine* CGibbsSamplingInfEngine::Create( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrlModel</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd>Pointer to a model, for which inference algorithm is to be carried out.
</dl></p><p>
This function creates either a <EM CLASS="CodeReg">MRF</EM> (<EM CLASS="CodeReg">MRF2</EM>) object or a <EM CLASS="CodeReg">BNet</EM> object.
</p>


<hr><h4><a name="declCGibbsSamplingInfEngine_SetQueryes">SetQueryes</a></h4>
<p class="Blurb">Sets possible queries.</p><pre>

void CGibbsSamplingInfEngine::SetQueryes( intVecVector &amp;<EM CLASS="CodeItalic">queries </EM>);
</pre><p><dl>
 Arguments
<dt>Queries <dd>Vector of possible queries.
</dl></p><p>
This function sets possible queries. This function is compulsory before calling <EM CLASS="CodeReg">
EnterEvidence</EM>().
</p>


<hr><h4><a name="declCGibbsSamplingInfEngine_UseDSeparation">UseDSeparation</a></h4>
<p class="Blurb">Conditions d-separation  use in  sampling for <EM CLASS="CodeReg">BNet.</EM></p><pre>

void CGibbsSamplingInfEngine::UseDSeparation( bool <EM CLASS="CodeItalic">isUsing </EM>);
</pre><p><dl>
 Arguments
<dt>isUsing <dd>Flag of <EM CLASS="CodeItalic">d</EM>-separation.
</dl></p><p>
This function conditions use of the <EM CLASS="CodeItalic">
d</EM>-separatrion  in sampling for <EM CLASS="CodeReg">BNet</EM>.
</p>


<hr><h3><a name="decl_pnlClassCGibbsWithAnnealingInfEngine">Class CGibbsWithAnnealingInfEngine</a></h3>

<IMG SRC="fig/PNLMarch.book-141.gif">
<p>
<EM CLASS="CodeReg">CGibbsWithAnnealingInfEngine</EM> implements Gibbs Sampler with annealing schedule
<EM CLASS="CodeItalic">T(s) = c / log(1+s)</EM> where <EM CLASS="CodeItalic">T(s)</EM>
 is the temperature which depends on the sampling iteration and <EM CLASS="CodeItalic">c</EM> is a parameter.
</p>
<p>
This inference finds maximum probability explanation for nodes. For more detailed information see [Stuart Geman and Donald Geman. Stochastic Relaxation, Gibbs Distribution, and the Bayesian Restoration of Images].
</p>



<hr><h4><a name="declCGibbsWithAnnealingInfEngine_Create">Create</a></h4>
<p class="Blurb">Returns class object.</p><pre>

static CGibbsWithAnnealingInfEngine* CGibbsWithAnnealingInfEngine::Create( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGrlModel</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd> Pointer to a model, for which inference algorithm is to be carried out.
</dl></p><p>
This function creates a class object.
</p>


<hr><h4><a name="declCGibbsWithAnnealingInfEngine_SetAnnealingCoefficientC">SetAnnealingCoefficientC</a></h4>
<p class="Blurb">Changes default coefficient C of annealing schedule. </p><pre>

 void CGibbsWithAnnealingInfEngine::SetAnnealingCoefficientC( float <EM CLASS="CodeItalic">val</EM> );
</pre><p><dl>
 Arguments
<dt>val <dd>Value of the coefficient.
</dl></p><p>
This function sets a new value for the <EM CLASS="CodeItalic">C</EM> coefficient of the annealing schedule.
</p>


<hr><h4><a name="declCGibbsWithAnnealingInfEngine_SetAnnealingCoefficientS">SetAnnealingCoefficientS</a></h4>
<p class="Blurb">Changes default coefficient S of annealing schedule. </p><pre>

void CGibbsWithAnnealingInfEngine::SetAnnealingCoefficientS( float <EM CLASS="CodeItalic">val</EM> );
</pre><p><dl>
 Arguments
<dt>val <dd>Value of the coefficient.
</dl></p><p>
This function sets a new value for the<EM CLASS="CodeItalic"> S</EM> coefficient of the annealing schedule.
</p>


<hr><h4><a name="declCGibbsWithAnnealingInfEngine_GetCurrentTemp">GetCurrentTemp</a></h4>
<p class="Blurb">Returns value of current temperature.</p><pre>

float CGibbsWithAnnealingInfEngine::GetCurrentTemp() const;
</pre>


<hr><h4><a name="declCGibbsWithAnnealingInfEngine_UseAdaptation">UseAdaptation</a></h4>
<p class="Blurb">Uses adaptation during inference.</p><pre>

void CGibbsWithAnnealingInfEngine::UseAdaptation( bool <EM CLASS="CodeItalic">isUse </EM>);
</pre><p><dl>
 Arguments
<dt>isUse   <dd>Flag of use of the adaptation.
</dl></p>


<hr><h3><a name="decl_pnlClassCLWSamplingInfEngine">Class CLWSamplingInfEngine</a></h3>

<IMG SRC="fig/PNLMarch.book-146.gif">

<p>
<A NAME="pgfId-73465"></A>Class  <EM CLASS="CodeReg">CLWSamplingInfEngine</EM> implements the particle-based inference engine for static <EM CLASS="CodeReg">
BNet</EM> models.
</p>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates particle-based inference engine for <EM CLASS="CodeReg">BNet</EM></p><pre>

static CLWSamplingInfEngine* Create( const CStaticGraphicalModel *<EM CLASS="CodeItalic">pGraphicalModelIn</EM>, int <EM CLASS="CodeItalic">particleCount</EM>= 400 );
</pre><p><dl>
 Arguments
<dt>pGrModelIn<dd>  Static graphical model.
<dt>nParticleCount  <dd>Number of particles.
</dl></p>


<hr><h4><a name="decl_pnl">SetParemeter</a></h4>
<p class="Blurb">Sets parameters of <EM CLASS="CodeReg">LWSamplingInfEngine.</EM></p><pre>

void SetParemeter(  int <EM CLASS="CodeItalic">nParticleCount</EM> = 400)
</pre><p><dl>
 Arguments
<dt>nParticleCount<dd>  Number of particles.
</dl></p><p>
This function allows you to change  particle counts of the <EM CLASS="CodeReg">
CLWSamplingInfEngine</EM>.
</p>


<hr><h4><a name="decl_pnlLWSampling">LWSampling</a></h4>
<p class="Blurb">Generates particles using observed evidence.</p><pre>

void  LWSampling(const CEvidence* <EM CLASS="CodeItalic">pEvidenceIn</EM> = NULL)
</pre><p><dl>
 Arguments
<dt>pEvidenceIn<dd>  The observed evidence.
</dl></p><p>
Both <EM CLASS="CodeReg">LWSampling</EM> and <EM CLASS="CodeReg">EnterEvidence</EM> generate particles. Unlike  <EM CLASS="CodeReg">EnterEvidence, LWSampling</EM> cannot generate particle weights. To input particle weights you call <EM CLASS="CodeReg">EnterEvidenceProbability()</EM>.
</p>


<hr><h4><a name="decl_pnlEnterEvidenceProbability">EnterEvidenceProbability</a></h4>
<p class="Blurb">Inputs likelihood of observations.</p><pre>

void  EnterEvidenceProbability( floatVector *<EM CLASS="CodeItalic">pEvidenceProbIn</EM> )
</pre><p><dl>
 Arguments
<dt>pEvidenceProbIn<dd>  Vector of particle weights.
</dl></p><p>
This function calculates automatically particle weights under observance.With this function you easily calculate the likelihood <IMG SRC="fig/PNLMarch.book-147.gif" ALIGN="BASELINE">of observations.
</p>


<hr><h4><a name="decl_pnlGetCurSamples">GetCurSamples</a></h4>
<p class="Blurb">Returns states of all current particles.</p><pre>

pEvidencesVector* GetCurSamples();
</pre><p>
This function returns all node values of particles.
</p>


<hr><h4><a name="decl_pnlGetParticleWeights">GetParticleWeights</a></h4>
<p class="Blurb">Gets weights of all current particles.</p><pre>

floatVector* GetParticleWieghts()
</pre>


<hr><h4><a name="decl_pnlEstimate">Estimate</a></h4>
<p class="Blurb">Estimates real values of nodes.</p><pre>

void Estimate(CEvidence *<EM CLASS="CodeItalic">pEstimate</EM>)
</pre><p><dl>
 Arguments
<dt>pEstimate<dd>  Given the estimated nodes as input.
</dl></p><p>
This function estimates real values (states) of nodes by all generated particles. It is similar to <EM CLASS="CodeReg">
GetMPE </EM>but more convenient as it does not call <EM CLASS="CodeReg">MarginalNodes</EM>.The estimated values are stored in <EM CLASS="CodeItalic">pEstimate</EM> as output.
</p>


<hr><h4><a name="decl_pnlGetNeff">GetNeff</a></h4>
<p class="Blurb">Gets number of current effective particles.</p><pre>

float GetNeff()
</pre><p><dl>
 Arguments
<dt>float<dd>  The current number of effective particles.
</dl></p><p>
This function acquires the number of current effeclive particles. If it is small enough, you re-initialize particle weights and values. Set by default, <EM CLASS="CodeReg">LWSampling</EM> detects the number of effective  particles and re-initializes the particle weight if it is too small automatically.
</p>


<hr><h3><a name="decl_pnlClassCDynamicInfEngine">Class CDynamicInfEngine</a></h3>

<IMG SRC="fig/PNLMarch.book-148.gif">

<p>
Class <EM CLASS="CodeItalic">CDynamicInfEngine</EM> is a superclass for all classes that implement inference in
dynamic graphical models.
</p>


<hr><h4><a name="declCDynamicInfEngine_DefineProcedure">DefineProcedure</a></h4>
<p class="Blurb">Defines type of inference procedure.</p><pre>

void CDynamicInfEngine::DefineProcedure( EProcedureTypes <EM CLASS="CodeItalic">procedure</EM>, int <EM CLASS="CodeItalic">lag</EM> );
</pre><p><dl>
 Arguments
<dt>procedure<dd>  Type of the inference procedure that can be either <EM CLASS="CodeReg">itFiltering</EM>, <EM CLASS="CodeReg">itSmoothing</EM>, <EM CLASS="CodeReg">itFixLagSmoothing</EM> or <EM CLASS="CodeReg">itViterbi</EM>.
<dt>lag<dd>  Integer value, which corresponds to the value of lag for the problem of fixed-lag smoothing. Note that it must be equal to 0 for the filtering problem. For the problem of smoothing, this argument is the number of time slices.
</dl></p><p>
This member function defines the type of inference procedure as filtering, smoothing, fixed-lag smoothing or Viterby decoding.
</p>


<hr><h4><a name="declCDynamicInfEngine_EnterEvidence">EnterEvidence</a></h4>
<p class="Blurb">Enters evidence to engine.</p><pre>

void CDynamicInfEngine::EnterEvidence( const CEvidence*const* <EM CLASS="CodeItalic">evidences</EM>,  int <EM CLASS="CodeItalic">numOfEvidences </EM>);
void CDynamicInfEngine::EnterEvidence(const pConstEvidenceVector&amp; <EM CLASS="CodeItalic">evidences</EM>);
</pre><p><dl>
 Arguments
<dt>evidences<dd>  Pointer to the array of pointers to the collection of evidences for all the slices.
<dt>numOfEvidences<dd>  Size of array, that is, the number of evidences or the number of slices.
</dl></p>


<hr><h4><a name="declCDynamicInfEngine_MarginalNodes">MarginalNodes</a></h4>
<p class="Blurb">Marginalizes joint probability distribution to query nodes.</p><pre>

void CDynamicInfEngine::MarginalNodes( const int* <EM CLASS="CodeItalic">query</EM>, int <EM CLASS="CodeItalic">querySize</EM>, int <EM CLASS="CodeItalic">timeSlice</EM> = 0, int <EM CLASS="CodeItalic">notExpandJPD</EM> = 0 ) = 0;
void CDynamicInfEngine::MarginalNodes( const intVector&amp; <EM CLASS="CodeItalic">query</EM>, int <EM CLASS="CodeItalic">timeSlice</EM> = 0, int <EM CLASS="CodeItalic">notExpandJPD</EM> = 0 );
</pre><p><dl>
 Arguments
<dt>query<dd>  Array of nodes, which the user wants to appear in the query.
<dt>querySize<dd>  Number of nodes in the query.
<dt>timeSlice<dd>  Query slice number, which should be equal to 0 for the filtering and fixed-lag smoothing problems, because they are on-line procedures.
<dt>notExpandJPD  <dd>Flag of expanding.
</dl></p><p>
The call of this member function marginalizes the joint probability distribution to the set of nodes in slice given as the <EM CLASS="CodeItalic">
query</EM> input argument, at the time <EM CLASS="CodeItalic">timeSlice</EM>. For filtering argument <EM CLASS="CodeItalic">timeSlice</EM>
 must be equal to the current time and for fixed-lag smoothing it must be equal to time-lag.
</p>


<hr><h4><a name="declCDynamicInfEngine_GetQueryJPD">GetQueryJPD</a></h4>
<p class="Blurb">Returns joint probability distribution of query nodes.</p><pre>

virtual const CPotential* CDynamicInfEngine::GetQueryJPD() = 0;
</pre>


<hr><h4><a name="declCDynamicInfEngine_GetMPE">GetMPE</a></h4>
<p class="Blurb">Returns most probable explanation of query nodes.</p><pre>

virtual const CEvidence* CDynamicInfEngine::GetMPE() = 0;
</pre>


<hr><h4><a name="declCDynamicInfEngine_Filtering">Filtering</a></h4>
<p class="Blurb">Performs filtering procedure.</p><pre>

void CDynamicInfEngine::Filtering( int <EM CLASS="CodeItalic">timeSlice</EM> );
</pre><p><dl>
 Arguments
<dt>timeSlice<dd>  Current time-slice number.
</dl></p><p>
This function performs filtering procedure.
</p>


<hr><h4><a name="declCDynamicInfEngine_Smoothing">Smoothing</a></h4>
<p class="Blurb">Performs smoothing procedure.</p><pre>

void CDynamicInfEngine::Smoothing();
</pre><p>
This function performs smoothing procedure.
</p>


<hr><h4><a name="declCDynamicInfEngine_FixLagSmoothing">FixLagSmoothing</a></h4>
<p class="Blurb">Performs fixed-lag smoothing procedure.</p><pre>

void CDynamicInfEngine::FixLagSmoothing( int <EM CLASS="CodeItalic">timeSlice</EM> );
</pre><p><dl>
 Arguments
<dt>timeSlice<dd>  Current time-slice number.
</dl></p><p>
This function performs fixed-lag smoothing with a lag defined in <EM CLASS="CodeReg">
<a href="#declCDynamicInfEngine_DefineProcedure">DefineProcedure</A></EM>.
</p>


<hr><h4><a name="declCDynamicInfEngine_GetMPE">GetMPE</a></h4>
<p class="Blurb">Finds most probable explanation.</p><pre>

virtual const CEvidence* CDynamicInfEngine::GetMPE() = 0;
</pre><p>
This function performs the procedure of Viterbi decoding.
</p>


<hr><h4><a name="declCDynamicInfEngine_GetDynamicModel">GetDynamicModel</a></h4>
<p class="Blurb">Returns given dynamic model.</p><pre>

const CDynamicGraphicalModel* CDynamicInfEngine::GetDynamicModel() const;
</pre>


<hr><h4><a name="declCDynamicInfEngine_GetProcedureType">GetProcedureType</a></h4>
<p class="Blurb">Returns type of inference procedure.</p><pre>

EProcedureTypes CDynamicInfEngine::GetProcedureType() const;
</pre><p>
This function returns one of the following inference procedures: <EM CLASS="CodeReg">
ptFiltering</EM>, <EM CLASS="CodeReg">ptSmoothing</EM>, <EM CLASS="CodeReg">ptFixLagSmoothing</EM>, <EM CLASS="CodeReg">ptViterbi</EM>.
</p>


<hr><h3><a name="decl_pnlClassC2TBNInfEngine">Class C2TBNInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-149.gif">
<p>
<EM CLASS="CodeReg">C2TBNInfEngine</EM> is a superclass for all dynamic inference engine classes, which use forward-backward operations between slices. With such structure of classes an inference procedure (filtering, smoothing, and so on) can be implemented with the help of combination of virtual member functions <EM CLASS="CodeReg"><a href="#decl_pnlForwardFirst">ForwardFirst</A></EM>, <EM CLASS="CodeReg"><a href="#decl_pnlForward">Forward</A></EM>, <EM CLASS="CodeReg"><a href="#decl_pnlBackwardT">BackwardT</A></EM>, <EM CLASS="CodeReg"><a href="#decl_pnlBackward">Backward</A></EM>, which are implemented in derived classes.
</p>



<hr><h4><a name="decl_pnlForwardFirst">ForwardFirst</a></h4>
<p class="Blurb">Performs forward operation for prior slice.</p><pre>

void C2TBNInfEngine::ForwardFirst( CEvidence* <EM CLASS="CodeItalic">evidence</EM> );
</pre><p><dl>
 Arguments
<dt>evidence<dd>  Pointer to evidence for the prior slice.
</dl></p>


<hr><h4><a name="decl_pnlForward">Forward</a></h4>
<p class="Blurb">Performs forward operation.</p><pre>

void C2TBNInfEngine::Forward( CEvidence* <EM CLASS="CodeItalic">evidence</EM> );
</pre><p><dl>
 Arguments
<dt>evidence<dd>  Pointer to evidence for any but the prior slice.
</dl></p>


<hr><h4><a name="decl_pnlBackwardT">BackwardT</a></h4>
<p class="Blurb">Performs first backward operation after last forward operation.</p><pre>

void C2TBNInfEngine::BackwardT();
</pre>


<hr><h4><a name="decl_pnlBackward">Backward</a></h4>
<p class="Blurb">Performs backward operation.</p><pre>

void C2TBNInfEngine::Backward();
</pre>


<hr><h4><a name="decl_pnlBackwardFixLag">BackwardFixLag</a></h4>
<p class="Blurb">Performs sequence of backward operations.</p><pre>

void C2TBNInfEngine::BackwardFixLag();
</pre><p>
This member function performs a sequence of backward operations for the fixed-lag smoothing problem, restoring data for the intermediate steps. The number of operations is equal to the value of the lag.
</p>


<hr><h3><a name="decl_pnlClassC1_5SliceInfEngine">Class C1_5SliceInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-150.gif">
<p>
This class is basic for all inference procedures that carry out forward-backward
operations between 1.5 slices.
</p>


<hr><h3><a name="decl_pnlClassC1_5SliceJtreeInfEngine">Class C1_5SliceJtreeInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-151.gif">


<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

C1_5SliceJtreeInfEngine * C1_5SliceJtreeInfEngine::Create( const CDynamicGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to the dynamic graphical model for which inference engine is created.
</dl></p>


<hr><h3><a name="decl_pnlClassCBKInfEngine">Class CCBKInfEngine</a></h3>


<IMG SRC="fig/PNLMarch.book-152.gif">


<hr><h4><a name="declCBKInfEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CBKInfEngine* CBKInfEngine::Create( const CDynamicGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM>, bool <EM CLASS="CodeItalic">isFF</EM> = true );
static CBKInfEngine* CBKInfEngine::Create( const CDynamicGraphicalModel *<EM CLASS="CodeItalic">pGrModel</EM>, intVecVector&amp; <EM CLASS="CodeItalic">clusters</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel  <dd>Pointer to the Dynamic graphical model for which inference engine is created.
<dt>isFF  <dd>Flag of factorization. The `true' value means that the inference is fully factorized, that is, each node belongs to a separate cluster. The `false' value means that the inference is exact, so that nodes lie in one clique.
<dt>clusters  <dd>Array of nodes belonging to one cluster<EM CLASS="CodeItalic">.</EM>
</dl></p>


<hr><h4><a name="declCBKInfEngine_CheckClustersValidity">CheckClustersValidity</a></h4>
<p class="Blurb">Checks validity of clusters. </p><pre>

static bool CBKInfEngine::CheckClustersValidity( intVecVector&amp; <EM CLASS="CodeItalic">clusters</EM>, intVector&amp; <EM CLASS="CodeItalic">interfNds</EM> );
</pre><p><dl>
 Arguments
<dt>clusters  <dd>Vector of vectors of inference nodes. An inference node belongs only to one cluster.
<dt>interfNds <dd>Vector of inference nodes<EM CLASS="CodeItalic">.</EM>
</dl></p><p>
This function checks if a cluster is valid. A vector of the BK inference can be composed of vectors which contain numbers of interface model nodes. If the nodes fall into one and the same class they are sure to lie in one clique of the Junction tree. If the nodes belong to different clusters the inference is fully factorized, if they belong to the same cluster the inference is exact.
</p>


<hr><h3><a name="decl_pnlClassC2TPFInfEngine">Class C2TPFInfEngine</a></h3>

<p>
Class <EM CLASS="CodeItalic">C2TPFIngEngine</EM> implements the particle-based inference engine for dynamical
BNet models.
</p>


<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates particle-based inference for DBN model.<DIV>
static C2TPFInfEngine * Create (const CDynamicGraphicalModel *<EM CLASS="CodeItalic">pGrModelIn</EM>, int <EM CLASS="CodeItalic">nParticleCount</EM> = 400);
</pre><p><dl>
 Arguments
<dt>pGrModelIn<dd>  Dynamic graphical model of DBN.
<dt>nParticleCount<dd>  Number of particles.
</dl></p>


<hr><h4><a name="decl_pnlSetParemeter">SetParemeter</a></h4>
<p class="Blurb">Sets  parameters of  <EM CLASS="CodeReg">2TPFInfEngine</EM></p><pre>

void SetParemeter(  int <EM CLASS="CodeItalic">nParticleCount</EM> = 400, int <EM CLASS="CodeItalic">nLowThreshold</EM> = 30);
</pre><p><dl>
 Arguments
<dt>nParticleCount<dd>  Number of particles.
<dt>nLowThreshold<dd>  Minimum number of effective particles.
</dl></p><p>
This function allows you to change parameters of  <EM CLASS="CodeReg">2TPFInfEngine</EM>.
</p>


<hr><h4><a name="decl_pnlInitSlice0Particles">InitSlice0Particles</a></h4>
<p class="Blurb">Initializes particles of  first slice.</p><pre>

void InitSlice0Particles(CEvidence* <EM CLASS="CodeItalic">pSlice0Evidence</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>Evidence<dd>  Observed evidence.
</dl></p>


<hr><h4><a name="decl_pnlEnterEvidence">EnterEvidence</a></h4>
<p class="Blurb">Enters observed evidence.</p><pre>

void EnterEvidence( const CEvidence *<EM CLASS="CodeItalic">pEvidenceIn</EM> );
</pre><p><dl>
 Arguments
<dt>pEvidenceIn<dd>  Observed evidence of the current slice.
</dl></p><p>
This function provides observed evidence of the current slice for <EM CLASS="CodeReg">2TPFInfEngine</EM> , which updates the particle states and weights by <EM CLASS="CodeReg">LWSampling</EM>.
</p>


<hr><h4><a name="decl_pnlLWSampling">LWSampling</a></h4>
<p class="Blurb">Updates particle states using obesrved evidence.</p><pre>

void  LWSampling(const CEvidence* <EM CLASS="CodeItalic">pEvidenceIn</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>pEvidenceIn<dd>  Observed evidence of the current slice.
</dl></p><p>
This function updates particles in the current slice. Unlike <EM CLASS="CodeReg">EnterEvidence</EM> it cannot update particle weights by itself. To input particle weights you call <EM CLASS="CodeReg">EnterEvidenceProbability</EM>.
</p>


<hr><h4><a name="decl_pnlEnterEvidenceProbability">EnterEvidenceProbability</a></h4>
<p class="Blurb">Inputs likelihood of observations in slice</p><pre>
void  EnterEvidenceProbability( floatVector *<EM CLASS="CodeItalic">pEvidenceProbIn</EM> );
</pre><p><dl>
 Arguments
<dt>pEvidenceProbIn<dd>  The vector of particle weights
</dl></p><p>
This function calculates particle weights under observance automatically.This interface allows you to calculate likelihood of observations easily.
</p>


<hr><h4><a name="decl_pnlGetCurSamples">GetCurSamples</a></h4>
<p class="Blurb">Returns states of all current particles.</p><pre>

pEvidencesVector* GetCurSamples( );
</pre><p><dl>
 Arguments
<dt>pEvidencesVector<dd>* The returned pointer of particle states.
</dl></p><p>
This function returns node values of all particles and allows you to calculate the likelihood of observations.
</p>


<hr><h4><a name="decl_pnlGetParticleWeights">GetParticleWeights</a></h4>
<p class="Blurb">Gets weights of all current particles.</p><pre>

floatVector* GetParticleWieghts( );
</pre><p><dl>
 Arguments
<dt>floatVector<dd>* The returned pointer of particle weights.
</dl></p>


<hr><h4><a name="decl_pnlEstimate">Estimate</a></h4>
<p class="Blurb">Estimates real values of nodes in current slice.</p><pre>

void Estimate(CEvidence *<EM CLASS="CodeItalic">pEstimate</EM>);
</pre><p><dl>
 Arguments
<dt>pEstimate<dd>  Estimated nodes provided for input.
</dl></p><p>
This function estimates real values (states) of nodes by all generated particles. It is similar to <EM CLASS="CodeReg">
GetMPE() </EM>but more convenient because ot does not call <EM CLASS="CodeReg">MarginalNodes()</EM>.
</p>


<hr><h4><a name="decl_pnlGetNeff">GetNeff</a></h4>
<p class="Blurb">Gets number of current effective particles.</p><pre>

float GetNeff();
</pre><p><dl>
 Arguments
<dt>float<dd>  The current number of effective particles.
</dl></p><p>
This function returns the number of current effective particles. If the number is too small, you should re-initialize the particle states and the particle weights. Set by default,  <EM CLASS="CodeReg">LWSampling()</EM>detects the number of effective  particles and re-initializes the particle weight, if it is too small, automatically.
</p>


<hr><h2><a name="decl_pnlLearning_Engines">Learning Engines</a></h2>

<IMG SRC="fig/PNLMarch.book-156.gif">


<hr><h3><a name="decl_pnlClassCLearningEngine">Class CLearningEngine</a></h3>



<hr><h4><a name="declCLearningEngine_Learn">Learn</a></h4>
<p class="Blurb">Performs learning.</p><pre>

virtual void CLearningEngine::Learn()=0;
</pre><p>
This function trains a graphical model by using the set data. In parameter learning the function upgrades factors using given evidences. In structure learning the function creates a new graphical model.
</p>


<hr><h4><a name="declCLearningEngine_GetCriterionValue">GetCriterionValue</a></h4>
<p class="Blurb">Returns array of criterion values used in learning.</p><pre>

virtual float CLearningEngine::GetCriterionValue( int *<EM CLASS="CodeItalic">numOfValues</EM>, const float **<EM CLASS="CodeItalic">value </EM>) const;
virtual float CStaticLearningEngine::GetScore( floatVector* <EM CLASS="CodeItalic">value </EM>) const;
</pre><p><dl>
 Arguments
<dt>numOfValues<dd>  Returned parameter. Number of criterion values.
<dt>value<dd>  Returned parameter. Array of criterion values.
</dl></p><p>
This function returns numeric values of a criterion that is to be maximized during model learning.
</p>


<hr><h4><a name="declCLearningEngine_ClearStatisticData">ClearStatisticData</a></h4>
<p class="Blurb">Clears statistical data.</p><pre>

inline void CLearningEngine::ClearStatisticData();
</pre>


<hr><h3><a name="decl_pnlClassCStaticLearningEngine">Class CStaticLearningEngine</a></h3>



<hr><h4><a name="declCStaticLearningEngine_SetData">SetData</a></h4>
<p class="Blurb">Sets statistical data for learning.</p><pre>

virtual void CStaticLearningEngine::SetData( int <EM CLASS="CodeItalic">size</EM>, const CEvidence* const* <EM CLASS="CodeItalic">evidences</EM> );
virtual void CStaticLearningEngine::SetData(  const pConstEvidenceVector&amp; <EM CLASS="CodeItalic">evidences</EM> );
</pre><p><dl>
 Arguments
<dt>size<dd>  Number of evidences.
<dt>evidences<dd>  Array of pointers to <EM CLASS="CodeReg">CEvidence</EM> objects.
</dl></p><p>
This function sets statistical data for learning. When the function is called all the prior statistical data is deleted.
</p>


<hr><h4><a name="declCStaticLearningEngine_AppendData">AppendData</a></h4>
<p class="Blurb">Appends evidence information.</p><pre>

virtual void CStaticLearningEngine::AppendData( int <EM CLASS="CodeItalic">size</EM>, const CEvidence* const* <EM CLASS="CodeItalic">evidences </EM>);
virtual void CStaticLearningEngine::AppendData(  const pConstEvidenceVector&amp; <EM CLASS="CodeItalic">evidences</EM> );
</pre><p><dl>
 Arguments
<dt>size<dd>  Array size, equal to the number of rows in the new table of data.
<dt>evidences<dd>  Array of pointers to <EM CLASS="CodeReg">
CEvidence</EM> objects.
</dl></p><p>
This function appends a set of evidences to the previously obtained data.
</p>


<hr><h4><a name="declCStaticLearningEngine_SetMaxIterIPF">SetMaxIterIPF</a></h4>
<p class="Blurb">Sets maximum iteration depth for Iterative Proportional Fitting.</p><pre>

void CStaticLearningEngine::SetMaxIterIPF( int <EM CLASS="CodeItalic">maxIter</EM> = 10 );
</pre><p><dl>
 Arguments
<dt>maxIter<dd>  Maximal number of iterations in Iterative Proportional Fitting.
</dl></p><p>
This function is used in Markov networks training and sets the maximal iteration depth allowed for IPF.
</p>


<hr><h4><a name="declCStaticLearningEngine_SetTerminationToleranceIPF">SetTerminationToleranceIPF</a></h4>
<p class="Blurb">Sets exit condition for IPF.</p><pre>

void CStaticLearningEngine::SetTerminationToleranceIPF( float <EM CLASS="CodeItalic">precision</EM> = 0.001f );
</pre><p><dl>
 Arguments
<dt>precision<dd>  Precision.
</dl></p><p>
This function sets the exit condition for IPF. IPF is over if the difference between clique parameters at the current step and at the previous step does not exceed a given value (<EM CLASS="CodeItalic">precision</EM>).
</p>


<hr><h4><a name="declCstaticLearningEngine_GetStatisModal">GetStatisModal</a></h4>
</p><p class="Blurb">Returns graphical model.</p><pre>

virtual inline CStaticGraphicalModel* CStaticLearningEngine::GetStatisModal() const;
</pre>


<hr><h3><a name="decl_pnlClassCEMLearningEngine">Class CEMLearningEngine</a></h3>

<p>
Class <EM CLASS="CodeItalic">CEMLearningEngine</EM> is used in the learning of Bayesian networks with discrete
or multivariate Gaussian nodes and in the learning of Markov networks with discrete
nodes. The learning is based on <EM CLASS="CodeItalic">Expectation Maximization</EM> (EM) algorithm.
</p>

<hr><h4><a name="declCEMLearningEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CEMLearningEngine* CEMLearningEngine::Create(CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel, </EM>CInfEngine*<EM CLASS="CodeItalic"> pInfEng</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a graphical model for which the learning engine is created.
<dt>pInfEng<dd>  Pointer to the inference engine, which is used in the lerning procedure. By default  the Junction tree inference engine is used.
</dl></p>


<hr><h4><a name="declCEMLearningEngine_SetMaxIterEM">SetMaxIterEM</a></h4>
<p class="Blurb">Sets maximum iteration depth for Expectation Maximization.</p><pre>

void CEMLearningEngine::SetMaxIterEM( int <EM CLASS="CodeItalic">numOfIter</EM> = 30 );
</pre><p><dl>
 Arguments
<dt>numOfIter<dd>  Maximal iteration depth.
</dl></p><p>
This function sets the maximal number of iterations allowed in the learning process.
</p>


<hr><h4><a name="declCEMLearningEngine_SetTerminationToleranceEM">SetTerminationToleranceEM</a></h4>
<p class="Blurb">Sets termination tolerance.</p><pre>

void CEMLearningEngine::SetTerminationToleranceEM( float <EM CLASS="CodeItalic">precision</EM> = 0.001f );
</pre><p><dl>
 Arguments
<dt>precision<dd>  Precision.
</dl></p><p>
This function sets the exit condition for EM. EM is over, if the difference between logarithm of likelihood value at the current step and at the previous step does not exceed a given value.
</p>


<hr><h3><a name="decl_pnlClassCBayesLearningEngine">Class CBayesLearningEngine</a></h3>

<p>
Class <EM CLASS="CodeReg">CBayesLearningEngine</EM> is used to learn <EM CLASS="CodeReg">BNets</EM>, where parameters of a CPD are not fixed and have their own probability distributions (see User Guide). The current version of PNL supports parameters distributions only for a <EM CLASS="CodeReg">CTabular</EM> <EM CLASS="CodeReg">CPD</EM>. Both prior and posterior parameters distributions of a tabular CPD are Dirichlet. Dirichlet table distribution is stored in <EM CLASS="CodeReg">Tabular_CPD</EM> in the form of a matrix of the same size as CPT. Initial values are specified either by <EM CLASS="CodeReg">AllocMatrix</EM>
or by <EM CLASS="CodeReg">AttachMatrix</EM> functions of the corresponding factor. Dirichlet priors have the form (meaning) of pseudo counts which stand for an imaginary observed number of cases and assume any non-negative values.
</p>
 <p>
Learning updates prior parameters. Updated prior parameters may be used as priors in future learning. In the current version of PNL Bayesian parameter learning is supported only if the input data is complete, that is, if all the <EM CLASS="CodeReg">BNet</EM> nodes of training samples are observed.
</p>



<hr><h4><a name="declCBayesLearningEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CBayesLearningEngine* CBayesLearningEngine::Create( CStaticGraphicalModel* pGrModel  );
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to the graphical model for which the learning engine is created.
</dl></p><p>
This function creates a class object. It applies only to <EM CLASS="CodeReg">BNet</EM> graphical models.
</p>


<hr><h3><a name="decl_pnlClassCBICLearningEngine">Class CBICLearningEngine</a></h3>


<p>
Class <EM CLASS="CodeReg">CBICLearningEngine</EM> is used in the learning of a Bayesian network with
discrete nodes in the case when model structure is unknown and all variables are
observed. The learning is based on <EM CLASS="CodeReg">Bayesian Information Criterion (BIC).</EM> The result of
learning is a new Bayesian network.
</p>


<hr><h4><a name="declCBICLearningEngine_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CBICLearningEngine* CBICLearningEngine::Create( CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel </EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a graphical model for which learning procedure is to be carried out.
</dl></p><p>
This function creates an object of <EM CLASS="CodeReg">CBICLearningEngine</EM> class.
</p>


<hr><h4><a name="declCBICLearningEngine_GetGraphicalModel">GetGraphicalModel</a></h4>
<p class="Blurb">Returns created graphical model.</p><pre>

const CStaticGraphicalModel * CBICLearningEngine::GetGraphicalModel() const;
</pre><p>
This function returns a topologically sorted graphical model which was created as a result of structure learning.
</p>


<hr><h4><a name="declCBICLearningEngine_GetOrder">GetOrder</a></h4>
<p class="Blurb">Returns array of values corresponding to node numbers.</p><pre>

void CBICLearningEngine::GetOrder(intVector* <EM CLASS="CodeItalic">reordering</EM>) const;
</pre><p><dl>
 Arguments
<dt>reordering  <dd>Output parameter. Array of values corresponding to node numbers.
</dl></p><p>
This function returns the array of integer values. The array values correspond to node numbers in the source graphical model, which is passed as an argument when <EM CLASS="CodeReg">CBicLearningEngine</EM> is created, and the output model after the learning.
</p>


<hr><h3><a name="decl_pnlClassCMlStaticStructLearn">Class CMlStaticStructLearn</a></h3>


<IMG SRC="fig/PNLMarch.book-157.gif">
<p>
Class <EM CLASS="CodeReg">CMIStaticStructLearn</EM> is a virtual class. It defines the interface for all kinds of structure learning of a static <EM CLASS="CodeReg">BNet</EM> with complete data.
</p>


<hr><h4><a name="declCMlStaticStructLearn_CreateResultBNet">CreateResultBNet</a></h4>
<p class="Blurb">Generates <EM CLASS="CodeReg">BNet</EM> with structure and parameters.</p><pre>

void  CMlStaticStructLearn::CreateResultBNet(CDAG* <EM CLASS="CodeItalic">pDAG</EM>);
</pre><p><dl>
 Arguments
<dt>pDAG<dd>  Pointer to the learned <EM CLASS="CodeReg">DAG</EM>.
</dl></p><p>
This function generates the result of learning, that is, a <EM CLASS="CodeReg">
BNet</EM> object with its parameters and structure. The learned <EM CLASS="CodeReg">DAG</EM> sorts the given <EM CLASS="CodeReg">DAG</EM> topologically and creates a <EM CLASS="CodeReg">BNet</EM> for. The function computes all CPDs for the newly created <EM CLASS="CodeReg">BNet</EM>. The new object is stored in <EM CLASS="CodeReg">m_pResultBNet</EM>.
</p>


<hr><h4><a name="declCMlStaticStructLearn_GetResultBNet">GetResultBNet</a></h4>
<p class="Blurb">Gets handle of learned BNet.</p><pre>
const CBNet* CMlStaticStructLearn::GetResultBNet() const
</pre><p>

<hr><h4><a name="declCMlStaticStructLearn_GetScoreMethod">GetScoreMethod</a></h4>
<p class="Blurb">Returnes score method that is used in structure learning.</p><pre>

EScoreMethodTypes CMlStaticStructLearn::GetScoreMethod();
</pre><p>
This function returnes one of the several values: MaxLh, PreAs, MarLh.
<br> MaxLh - using maximized likelihood score method. 
<br> PreAs - using predictive assessment score method.
<br> MarLh - using marginal likelyhood score method.  
</p>
</pre>

<hr><h4><a name="declCMlStaticStructLearn_GetScoreFunction">GetScoreFunction</a></h4>
<p class="Blurb">Returnes score function that is used in structure learning.</p><pre>

EScoreFunTypes CMlStaticStructLearn::GetScoreFunction();
</pre><p>
This function returnes one of the several values: BIC, AIC, WithoutFine, VAR.
<br> BIC - using Bayessian Information Criterion. 
<br> AIC - using Akaike`s Information Criterion.
<br> WithoutFine - using function that does not penalty score. It is usually used with marginal likelihood score method. The other name is BDe metric
<br> VAR - Not Implemented. 
</p>
</pre>

<hr><h4><a name="declCMlStaticStructLearn_GetPriorType">GetPriorType</a></h4>
<p class="Blurb">Returnes prior`s type that is used in structure learning.</p><pre>

EPriorTypes CMlStaticStructLearn::GetPriorType();
</pre><p>
This function returnes one of the several values: Dirichlet, K2, BDeu.
<br> Dirichlet - using Dirichlet priors for networks scoring. 
<br> K2 - using K2 priors for networks scoring.
<br> BDeu - using BDeu priors for networks scoring. 
</p>
<p>
Priors uses only in marginal likelihood score method.
</p>
</pre>

<hr><h4><a name="declCMlStaticStructLearn_GetK2PriorParam">GetK2PriorParam</a></h4>
<p class="Blurb">Returnes K2 prior`s type that is used in structure learning.</p><pre>

int CMlStaticStructLearn::GetK2PriorParam();
</pre><p>
 Returnes inital K2 prior parameter. 
</p>

</pre>




<hr><h4><a name="declCMlStaticStructLearn_GetResultDAG">GetResultDAG</a></h4>
<p class="Blurb">Gets handle of learned <EM CLASS="CodeReg">DAG</EM>.</p><pre>

const CDAG*  CMlStaticStructLearn::GetResultDAG() const;
</pre>


<hr><h4><a name="declCMlStaticStructLearn_GetResultRenaming">GetResultRenaming</a></h4>
<p class="Blurb">Gets handle of node ID mapping of result BN and result DAG.</p><pre>

const int* CMlStaticStructLearn::GetResultRenaming()const;
</pre><p>
This function carries out topological sorting of the given <EM CLASS="CodeReg">
DAG</EM> on the basis of the learned <EM CLASS="CodeReg">DAG</EM> data and creates a <EM CLASS="CodeReg">BNet</EM> for the sorted <EM CLASS="CodeReg">DAG</EM>
. The function computes all CPDs for the created <EM CLASS="CodeReg">BNet</EM>. Node IDs of the sorted <EM CLASS="CodeReg">DAG</EM> and the resultant <EM CLASS="CodeReg">BNet</EM> are different. The renaming provides mapping between them.
</p>

<hr><h4><a name="declCMlStaticStructLearn_ScoreDAG">ScoreDAG</a></h4>
<p class="Blurb">Computes score of DAG.</p><pre>

float CMlStaticStructLearn::ScoreDAG(CDAG* <EM CLASS="CodeItalic">pDAG</EM>, floatVector* <EM CLASS="CodeItalic">familyScore</EM>);
</pre><p><dl>
 Arguments
<dt>pDAG<dd>  Pointer to a <EM CLASS="CodeReg">
DAG</EM> whose score is to be computed.
<dt>familyScore<dd>  Pointer to a float vector, that stores the score of a family.
</dl></p><p>
This function returns the whole score for the <EM CLASS="CodeReg">DAG</EM>. 
</p>

<hr><h4><a name="declCMlStaticStructLearn_SetScoreMethod">SetScoreMethod</a></h4>
<p class="Blurb">Sets structure learning score method.</p><pre>

void CMlStaticStructLearn::SetScoreMethod(EScoreMethodTypes <EM CLASS="CodeItalic">type</EM>);
</pre><p><dl>
 Arguments
<dt>type<dd> Score method type. This varible may takes one of several values:<br>
<br> MaxLh - using maximized likelihood score method.(default value) 
<br> PreAs - using predictive assessment score method.
<br> MarLh - using marginal likelihood score method.
</dl></p><p>
This function sets score method. Score method is defined in <EM CLASS="CodeReg">m_ScoreMethod</EM>.
</p>

<hr><h4><a name="declCMlStaticStructLearn_SetScoreFunction">SetScoreFunction</a></h4>
<p class="Blurb">Sets structure learning score function(metric).</p><pre>

void CMlStaticStructLearn::SetScoreFunction(EScoreFunTypes <EM CLASS="CodeItalic">ftype</EM>);
</pre><p><dl>
 Arguments
<dt>ftype<dd> Score function type. This varible may takes one of several values:<br>
<br> BIC - using Bayessian Information Criterion. 
<br> AIC - using Akaike`s Information Criterion.
<br> WithoutFine - using function that does not fine score. It is usually used with marginal likelyhood score method. The other name is BDe metric. 
<br> VAR - Not Implemented.
</dl></p><p>
This function sets score function. Score function is defined in <EM CLASS="CodeReg">m_ScoreType</EM>.
</p>

<hr><h4><a name="declCMlStaticStructLearn_SetPriorType">SetPriorType</a></h4>
<p class="Blurb">Sets a type of prior that will be used in marginal likelihood score method.</p><pre>

void CMlStaticStructLearn::SetPriorType(EPriorTypes <EM CLASS="CodeItalic">ptype</EM>);
</pre><p><dl>
 Arguments
<dt>ptype<dd> Prior type. This varible may takes one of several values:<br>
<br> Dirichlet - using Dirichlet priors for networks scoring.(default value) 
<br> K2 - using K2 priors for networks scoring.
<br> BDeu - using BDeu priors for networks scoring.
</dl></p><p>
This function sets prior type for marginal likelyhood score method . Prior type is defined in <EM CLASS="CodeReg">m_priorType</EM>.
</p>

<hr><h4><a name="declCMlStaticStructLearn_SetK2PriorParam">SetK2PriorParam</a></h4>
<p class="Blurb">Sets K2 prior inital value that will be used in marginal likelihood score method with K2 priors.</p><pre>

void CMlStaticStructLearn::SetK2PriorParam(int <EM CLASS="CodeItalic">alfa</EM>);
</pre><p><dl>
 Arguments
<dt>alfa<dd> Prior inital k2 prior value. (0 - is default value)
</dl></p><p>
This function sets K2 prior inital value for marginal likelyhood score method with K2 priors. 
</p>

<hr><h4><a name="declCMlStaticStructLearn_ScoreFamily">ScoreFamily</a></h4>
<p class="Blurb">Computes family score in DAG.</p><pre>

float CMlStaticStructLearn::ScoreFamily(intVector <EM CLASS="CodeItalic">vFamily</EM>);
</pre><p><dl>
 Arguments
<dt>vFamily<dd>  Integer vector. Stores a family in a <EM CLASS="CodeReg">DAG</EM>. The last element of the vector is the child node, all other nodes of the vector are parents of this child node.
</dl></p><p>
This function returns the score of a family.
</p>


<hr><h4><a name="declCMlStaticStructLearn_SetInitGraphicalModel">SetInitGraphicalModel</a></h4>
<p class="Blurb">Sets initial graphical model from which learning procedure starts.</p><pre>

void CMlStaticStructLearn::SetInitGraphicalModel(CGraphicalModel* <EM CLASS="CodeItalic">pGrModel</EM>);
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a <EM CLASS="CodeReg">CGraphicalModel</EM>.
</dl></p><p>
This function sets the initial graphical model for learning. The initial graphical model set as the input <EM CLASS="CodeItalic">
pGrModel</EM> by default is <EM CLASS="CodeReg">m_pGrModel</EM>.
</p>



<hr><h3><a name="decl_pnlClassCMlStaticStructLearnHC">Class CMlStaticStructLearnHC</a></h3>



<IMG SRC="fig/PNLMarch.book-158.gif">
<p>
This class carries out the hill-climbing structure learning for a static <EM CLASS="CodeReg">BNet</EM>, under the condition that the input data is complete.
</p>



<hr><h4><a name="decl_pnlCreate">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CMlStaticStructLearnHC* CMlStaticStructLearnHC::Create(CStaticGraphicalModel* <EM CLASS="CodeItalic">pGrModel</EM>, ELearningTypes <EM CLASS="CodeItalic">LearnType</EM>,  EOptimizeTypes <EM CLASS="CodeItalic">AlgorithmType</EM>, EScoreFunTypes <EM CLASS="CodeItalic">ScoreType</EM>, int <EM CLASS="CodeItalic">nMaxFanIn</EM>, intVector&amp; <EM CLASS="CodeItalic">vAncestor</EM>, intVector&amp; <EM CLASS="CodeItalic">vDescent</EM>, int <EM CLASS="CodeItalic">nRestarts</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a <EM CLASS="CodeReg">
CStaticGraphicalModel</EM>
 instance from which the hill-climbing procedure is to start.
<dt>LearnType<dd>  Type of learning.
<dt>AlgorithmType<dd>  Type of algorithm. In the current version of PNL the hill-climbing structure learning is performed only by <EM CLASS="CodeReg">StructLearnHC</EM>.
<dt>ScoreType<dd>  Score type.
<dt>nMaxFanIn<dd>  Maximum number of parents of a child node.
<dt>vAncestor<dd>  Ancestor vector. The vector is empty when learning is carried out for a static <EM CLASS="CodeReg">BNet</EM>.
<dt>vDescent<dd>  Descent vector. The vector is empty when learning is carried out for a static <EM CLASS="CodeReg">BNet</EM>.
<dt>nRestarts<dd>  Flag of   hill-climbing search procedure restart with random initial structures. If it equals to 1 the procedure does not restart.
</dl></p>


<hr><h4><a name="declCMlStaticStructLearnHC_SetMinProgress">SetMinProgress</a></h4>
<p class="Blurb">Sets control condition for search procedure.</p><pre>

void CMlStaticStructLearnHC::SetMinProgress(float <EM CLASS="CodeItalic">minProgress</EM>);
</pre><p><dl>
 Arguments
<dt>minProgress<dd>  Small float value.
</dl></p><p>
This function sets the control condition for the search procedure. If the improved rate of the best score in the current iteration is less than <EM CLASS="CodeItalic">minProgress</EM> the search is stopped. The default value of <EM CLASS="CodeItalic">minProgress </EM>is 0.0001.
</p>


<hr><h4><a name="declCMlStaticStructLearnHC_SetSingleMove">SetSingleMove</a></h4>
<p class="Blurb">Sets control condition for search procedure.</p><pre>

void CMlStaticStructLearnHC::SetSingleMove(bool <EM CLASS="CodeItalic">SingleMove</EM>);
</pre><p><dl>
 Arguments
<dt>SingleMove<dd>  Boolean value.
</dl></p><p>
This function sets  control conditions for the search procedure. The `true' value for  <EM CLASS="CodeItalic">SingleMove</EM> in every iteration of the hill-climbing search means that the change of one edge of the structure is permitted. The `false' value of the same parameter means that numerous changes to the current structure are permitted. If <EM CLASS="CodeItalic">SingleMove</EM> is set to `true' only one edge of the structure is changed, if it is set to `false' multiply changes to the structure are permitted. The default value is `true'.
</p>



<hr><h3><a name="decl_pnlClassCDynamicLearningEngine">Class CDynamicLearningEngine</a></h3>

<p>
Class <EM CLASS="CodeReg">CDynamicLearningEngine</EM> is a superclass for all classes that implement learning
for dynamic graphical models. The class contains functions that belong to its child
classes.
</p>

<hr><h4><a name="declCDynamicLearningEngine_SetData">SetData</a></h4>
<p class="Blurb">Sets statistical data for learning.</p><pre>

virtual void CDynamicLearningEngine::SetData( int <EM CLASS="CodeItalic">numOfTimeSeries</EM>, int *<EM CLASS="CodeItalic">numOfSlices</EM>, const CEvidence* const* <EM CLASS="CodeItalic">evidences</EM> );
virtual void CDynamicLearningEngine::SetData( const pEvidencesVecVector&amp; <EM CLASS="CodeItalic">evidences</EM> );
</pre><p><dl>
 Arguments
<dt>numOfTimeSeries<dd>  Input argument. Array size, which is equal to the number of rows in the table of data.
<dt>numOfSlices<dd>  Input argument. Pointer to the array of numbers of slices for each time series.
<dt>evidences<dd>  Input argument. Sets of evidences for DBN slices.
</dl></p><p>
This function sets statistical data for learning. Data is represented as an array in which the number of rows is equal to the number of series and the number of elements in a row is equal to the number of time slices for each series.
</p>


<hr><h4><a name="declCDynamicLearningEngine_GetDynamicModel">GetDynamicModel</a></h4>
<p class="Blurb">Returns pointer to model of learning engine.</p><pre>

virtual inline CDynamicGraphicalModel* CDynamicLearningEngine::GetDynamicModel() const;
</pre>


<hr><h3><a name="decl_pnlClassCEMLearningEngineDBN">Class CEMLearningEngineDBN</a></h3>


<p>
Class <EM CLASS="CodeReg">CEMLearningEngineDBN</EM>is used in the learning of Dynamic Bayesian Networks. The learning is based on <EM CLASS="CodeReg">Expectation Maximization (EM)</EM> algorithm.
</p>



<hr><h4><a name="declCEMLearningEngineDBN_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

static CEMLearningEngineDBN::Create( CDBN* <EM CLASS="CodeItalic">pDBN</EM>, CDynamicInfEngine* <EM CLASS="CodeItalic">pInfEng</EM> = NULL);
</pre><p><dl>
 Arguments
<dt>pDBN  <dd>Graphical model to be trained.
<dt>pInfEng <dd>Pointer to the inference engine which is used in the learning procedure. Set by default, the C1_5SliceJtreeInfEngine is used.
</dl></p>


<hr><h4><a name="declCEMLearningEngineDBN_SetTerminationToleranceEM">SetTerminationToleranceEM</a></h4>
<p class="Blurb">Sets termination tolerance.</p><pre>

void CEMLearningEngineDBN::SetTerminationToleranceEM( float <EM CLASS="CodeItalic">precision </EM>= 0.001f );
</pre><p><dl>
 Arguments
<dt>precision<dd>  Float value of precision, with which the difference between logarithms of likelihoods for two neighboring steps is compared to determine the breakpoint of the learning procedure.
</dl></p><p>
This function sets the exit condition for EM. EM procedure stops, if the difference between the logarithm of likelihood value at the current step and at the previous step does not exceed the input value of precision.
</p>


<hr><h4><a name="declCEMLearningEngineDBN_SetMaxIterEM">SetMaxIterEM</a></h4>
<p class="Blurb">Sets maximum iteration depth for EM.</p><pre>

void CEMLearningEngineDBN::SetMaxIterEM(int <EM CLASS="CodeItalic">nIter</EM> = 30);
</pre><p><dl>
 Arguments
<dt>nIter<dd>  Maximal iteration depth.
</dl></p><p>
This function sets the maximal number of iterations allowed in the learning process.
</p>


<hr><h3><a name="decl_pnlClassCMlDynamicStructLearn">Class CMlDynamicStructLearn</a></h3>


<IMG SRC="fig/PNLMarch.book-159.gif">
<p>
This class allows to learn the structure of DBN under the condition that the input data is complete. In the current version only the hill-climbing search algorithm is available. In the process of learning the algorithm creates one or two <EM CLASS="CodeReg">MlStaticStructLearn</EM> objects.
</p>


<hr><h4><a name="declCMlDynamicStructLearn_Create">Create</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CMlDynamicStructLearn* CMlDynamicStructLearn::Create(CDBN* <EM CLASS="CodeItalic">pGrModel</EM>,ELearningTypes <EM CLASS="CodeItalic">LearnType</EM>, EOptimizeTypes <EM CLASS="CodeItalic">AlgorithmType</EM>, EScoreFunTypes <EM CLASS="CodeItalic">ScoreType</EM>, int <EM CLASS="CodeItalic">nMaxFanIn</EM>, int <EM CLASS="CodeItalic">nRestarts</EM>, int <EM CLASS="CodeItalic">nMaxIters</EM> );
</pre><p><dl>
 Arguments
<dt>pGrModel<dd>  Pointer to a <EM CLASS="CodeReg">CDynamicGraphicalModel</EM> instance from which the hill-climbing procedure is to start.
<dt>AlgorithmType<dd>  Algorithm type. In the current version the hill-climbing structure learning is performed by <EM CLASS="CodeReg">StructLearnHC</EM>.
<dt>ScoreType<dd>  Score type.
<dt>nMaxFanIn<dd>  Maximum number of parents of a child node. Includes inter and intra slice-connections.
<dt>nRestarts<dd>  Flag of the hill-climbing search procedure restart with different random initial structures. If it equals to 1 the search procedure does not restart.
<dt>nMaxIters<dd>  Maximum number of iterations for the hill-climbing search procedure.
</dl></p>


<hr><h4><a name="declCMlDynamicStructLearn_SetMinProgress">SetMinProgress</a></h4>
<p class="Blurb">Sets control condition for search procedure.</p><pre>

void CMlDynamicStructLearn::SetMinProgress(float <EM CLASS="CodeItalic">minProgress</EM>);
</pre><p><dl>
 Arguments
<dt>minProgress<dd>  Small float value.
</dl></p><p>
This function sets the control condition for the search procedure. If the improved rate of the best score in the current iteration is less than <EM CLASS="CodeItalic">minProgress</EM>, the search is stopped. The default value of <EM CLASS="CodeItalic">minProgress</EM> is 0.0001.
</p>


<hr><h4><a name="declCMlDynamicStructLearn_GetResultDAG">GetResultDAG</a></h4>
<p class="Blurb">Gets handle of trained <EM CLASS="CodeReg">DAG</EM></p><pre>

const CDAG*  CMlDynamicStructLearn::GetResultDAG() const;
</pre>


<hr><h4><a name="declCMlDynamicStructLearn_SetLearnPriorSlice">SetLearnPriorSlice</a></h4>
<p class="Blurb">Sets different structure for prior slice to be trained.</p><pre>

void CMlDynamicStructLearn::SetLearnPriorSlice(bool <EM CLASS="CodeItalic">learnPriorSlice</EM>);
</pre><p><dl>
 Arguments
<dt>learnPriorSlice <dd>Flag of prior slice structure.
</dl></p><p>
This function sets a structure for a trained prior slice which is different from structures of other slices. The `true' value means that the structure of the slice is different. The default value is `false'.
</p>


<hr><h2><a name="decl_pnlRandom Number Generation">Random Number Generation</a></h2>

<p>
Random number generation (RNG) is widely used in  <EM CLASS="CodeItalic">PNL</EM>. In the current version of PNL it has the following structure.
</br>
The principle element of RNG is the basic generator of uniform distributions (BG), which is a static variable, accessed from any part of the library. To generate samples of non-uniform distributions, corresponding functions also use BG.</br>
The current implementation of RNG is not thread safe because it uses a static variable and does not feature access control. It is designed for internal use. You can reach it through the corresponding API formed of a number of global functions. The current version of  PNL generates distributed numbers uniformly and normally.
</p>

<p>
Linking PNL to Intel Math Kernel Library.
</p>

<p>
To increase the speed of RNG you may use Intel MKL. The quality of RNG will  be different because PNL and MKL use for RNG different maths.</P>
</p>

<p>

To use MKL in PNL you should:
<li> define USE_VSL key in the compiler settings;
<li> link PNL to MKL (see MKL notes);
<li> rebuild PNL.
</p>

<hr><h4><a name="decl_pnlSeed">pnlSeed</a></h4>
<p class="Blurb">Reinitializes random number generator.</p><pre>

void pnlSeed(int <EM CLASS="CodeItalic">s</EM>);
</pre><p><dl>
 Arguments
<dt>s<dd>  Integer that reinitializes the internal state of the basic random number generator.
</dl></p><p>
This function reinitializes the random number generator. As RNG is initialised automatically on loading the library this function is called only if there are special need for it, such as, for example, the necessity to perform non-repeatable experiments in different calls of application.
</p>


<hr><h4><a name="decl_pnlpnlRand">pnlRand</a></h4>
<p class="Blurb">Generates random numbers uniformly distributed over specified numerical interval.</p><pre>

int  pnlRand(int <EM CLASS="CodeItalic">left</EM>, int <EM CLASS="CodeItalic">right</EM>);
void  pnlRand(int <EM CLASS="CodeItalic">numElem</EM>, int* <EM CLASS="CodeItalic">vec</EM>, int <EM CLASS="CodeItalic">left</EM>, int <EM CLASS="CodeItalic">right</EM>);
float pnlRand(float <EM CLASS="CodeItalic">left</EM>, float <EM CLASS="CodeItalic">right</EM>);
void pnlRand(int <EM CLASS="CodeItalic">numElem</EM>, float* <EM CLASS="CodeItalic">vec</EM>, float <EM CLASS="CodeItalic">left</EM>, float <EM CLASS="CodeItalic">right</EM>);
double pnlRand(double <EM CLASS="CodeItalic">left</EM>, double <EM CLASS="CodeItalic">right</EM>);
void pnlRand(int <EM CLASS="CodeItalic">numElem</EM>, double* <EM CLASS="CodeItalic">vec</EM>, double <EM CLASS="CodeItalic">left</EM>, double <EM CLASS="CodeItalic">right</EM>);
</pre><p><dl>
 Arguments
<dt>left<dd>  Left boundary of the interval.
<dt>right<dd>  Right boundary of the interval.
<dt>numElem<dd>  Number of random numbers to be generated.
<dt>vec<dd>  Pointer to the array of random numbers to be generated. The array should be allocated externally and should contain not less than <EM CLASS="CodeItalic">numElem</EM> elements.
</dl></p><p>
This function generates random numbers distributed uniformly over a specified numerical interval. <EM CLASS="CodeReg">
pnlRand</EM> is a set of overloaded functions for generating uniformly distributed random numbers, both integer and floating point. In case of integer generation the function generates numbers on the interval <EM CLASS="CodeItalic">[left</EM>,<EM CLASS="CodeItalic">right]</EM> with boundaries of the interval included. In case of floating point generation the function generates numbers on the interval<EM CLASS="CodeItalic"> (left</EM>,<EM CLASS="CodeItalic">right)</EM> with boundaries of the interval excluded.
</p>


<hr><h4><a name="decl_pnlpnlRandNormal">pnlRandNormal</a></h4>
<p class="Blurb">Generates normally distributed random numbers.</p><pre>

float pnlRandNormal( float <EM CLASS="CodeItalic">mean</EM>, float <EM CLASS="CodeItalic">sigma, </EM>float<EM CLASS="CodeItalic"> variance</EM> );
double pnlRandNormal( double <EM CLASS="CodeItalic">mean</EM>, double <EM CLASS="CodeItalic">sigma</EM> , double <EM CLASS="CodeItalic">variance</EM>);
void pnlRandNormal( int <EM CLASS="CodeItalic">numElem</EM>, float* <EM CLASS="CodeItalic">vec</EM>, float <EM CLASS="CodeItalic">mean</EM>, float <EM CLASS="CodeItalic">sigma, </EM>float <EM CLASS="CodeItalic">variance</EM> );
void pnlRandNormal( int <EM CLASS="CodeItalic">numElem</EM>, double* <EM CLASS="CodeItalic">vec</EM>, double <EM CLASS="CodeItalic">mean</EM>, double <EM CLASS="CodeItalic">sigma</EM> , double <EM CLASS="CodeItalic">variance</EM>);
</pre><p><dl>
 Arguments
<dt>mean<dd>  Mean of the normal distribution.
<dt>variance  <dd>Varianceof the normal distribution.
<dt>sigma<dd>  Standard deviation of the normal distribution.
<dt>numElem<dd>  Number of random numbers to be generated.
<dt>vec<dd>  Pointer to the array of random numbers to be generated. The array should be allocated externally and is to contain no less than <EM CLASS="CodeItalic">numElem</EM> elements.
</dl></p><p>
This function generates random numbers normally distributed over the interval. <EM CLASS="CodeReg">pnlRandNormal</EM> is a set of overloaded functions for generating normally distributed random floating point numbers either with single or with double precision.</p>


<hr><h4><a name="decl_pnlpnlRandNormal">pnlRandNormal</a></h4>
<p class="Blurb">Generates normally distributed multidimensional vector.</p><pre>

void pnlRandNormal(floatVector* <EM CLASS="CodeItalic">vls</EM>, floatVector &amp;<EM CLASS="CodeItalic">mean</EM>, floatVector &amp;<EM CLASS="CodeItalic">sigma</EM> );
void pnlRandNormal(doubleVector* <EM CLASS="CodeItalic">vls</EM>,doubleVector &amp;<EM CLASS="CodeItalic">mean</EM>,doubleVector &amp;<EM CLASS="CodeItalic">sigma</EM> );
</pre><p><dl>
 Arguments
<dt>mean<dd>  Mean of the multivariate normal distribution.
<dt>sigma<dd>  Covariance matrix of the normal distribution.
<dt>vls<dd>  Pointer to the output vector.
</dl></p><p>
This function generates a vector from a multivariate normal distribution.
</p>


<hr><h2><a name="decl_pnlBasic_Data_Structures">Basic Data Structures </a></h2>





<hr><h3><a name="declClassValue">Class Value </a></h3>

<p>
This class stores inhomogeneous scalar data.
</p>

<hr><h4><a name="decl_pnlSetInt">SetInt</a></h4>
<p class="Blurb">Sets integer value to object.</p><pre>

void SetInt(int <EM CLASS="CodeItalic">ivl</EM>);
</pre><p><dl>
 Arguments
<dt>ivl<dd>  Integer value to be set to the <EM CLASS="CodeReg">Value</EM> object.
</dl></p>


<hr><h4><a name="decl_pnlGetInt">GetInt</a></h4>
<p class="Blurb">Gets integer value from object.</p><pre>

int GetInt() const;
</pre>


<hr><h4><a name="decl_pnlSetFlt">SetFlt</a></h4>
<p class="Blurb">Sets float value to object.</p><pre>

void SetFlt(float <EM CLASS="CodeItalic">fvl</EM>);
</pre><p><dl>
 Arguments
<dt>fvl<dd>  Float value to be set to the <EM CLASS="CodeReg">Value</EM> object.
</dl></p>


<hr><h4><a name="decl_pnlGetFlt">GetFlt</a></h4>
<p class="Blurb">Gets float value from object.</p><pre>

int GetFlt() const;
</pre>


<hr><h4><a name="decl_ClasspnlVector">Class pnlVector</a></h4>



<pre>
template&lt;class Type, class Allocator = GeneralAllocator&lt;Type&gt; &gt;class pnlVector: public std::vector&lt;Type, Allocator&gt; class pnlVector: public std::vector<Type, Allocator>
</pre>
<p>
This class is a template intended to store the vector data for PNL. Its implementation is based on <EM CLASS="CodeReg">vector</EM> object from STL. For the sake of brevity a number of <EM CLASS="CodeReg">pnlVector</EM> specializations  was renamed in PNL.
</p>


<pre>
Class valueVector
typedef pnlVector&lt;Value&gt;                valueVector;
Class pValueVector
typedef pnlVector&lt;Value*&gt;               pValueVector;
Class valueVecVector
typedef pnlVector&lt;valueVector&gt;          valueVecVector;
Class pConstValueVector
typedef pnlVector&lt;const Value*&gt;         pConstValueVector;
Class intVector
typedef pnlVector&lt;int&gt;                  intVector;
Class intPVector
typedef pnlVector&lt;int *&gt;                intPVector;
Class pConstIntVector
typedef pnlVector&lt;const int*&gt;           pConstIntVector;
Class intVecVector
typedef pnlVector&lt; intVector&gt;           intVecVector;
Class intVecPVector
typedef pnlVector&lt; intVector* &gt;         intVecPVector;
Class floatVector
typedef pnlVector&lt;float&gt;                floatVector;
Class doubleVector
typedef pnlVector&lt;double&gt;               doubleVector;
Class floatVecVector
typedef pnlVector&lt; floatVector&gt;         floatVecVector;
Class boolVector
typedef pnlVector&lt;bool&gt;                 boolVector;
Class nodeTypeVector
typedef pnlVector&lt; CNodeType&gt;           nodeTypeVector;
Class pNodeTypeVector
typedef pnlVector&lt; CNodeType*&gt;          pNodeTypeVector;
Class pConstNodeTypeVector
typedef pnlVector&lt; const CNodeType*&gt;    pConstNodeTypeVector;
Class pEvidencesVector
typedef pnlVector&lt; CEvidence*&gt;          pEvidencesVector;
Class pConstEvidenceVector
typedef pnlVector&lt; const CEvidence*&gt;    pConstEvidenceVector;
Class pConstEvidencesVecVector
typedef pnlVector&lt;pConstEvidenceVector&gt; pConstEvidencesVecVector;
Class pEvidencesVecVector
typedef pnlVector&lt; pEvidencesVector&gt;    pEvidencesVecVector;
Class pFactorVector
typedef pnlVector&lt;CFactor*&gt;             pFactorVector;
Class pConstFactorVector
typedef pnlVector&lt;const CFactor*&gt;       pConstFactorVector;
Class potsPVector
typedef pnlVector&lt; CPotential*&gt;         potsPVector;
Class potsPVecVector
typedef pnlVector&lt; potsPVector&gt;         potsPVecVector;
Class pConstCPDVector
typedef pnlVector&lt;const CCPD *&gt;         pConstCPDVector;
Class pGaussianCPDVector
typedef pnlVector&lt;CGaussianCPD *&gt;       pGaussianCPDVector;
</pre>


<hr><h2><a name="decl_pnlError Handling">Error_Handling</a></h2>



<hr><h3><a name="declClassCException">Class CException </a></h3>

<p>
Class <EM CLASS="CodeReg">CException</EM> and its child classes are used to generate different types of exceptions.
</p>


<IMG SRC="fig/PNLMarch.book-173.gif">

<p>
Each class in this hierarchy corresponds to a specific type of exception:
</p>
<ol>
  <li><EM CLASS="CodeReg">NumericException</EM> - One of the values exceeds its range, overflow and underflow respectively.
  <li><EM CLASS="CodeReg">MemoryException</EM> - Possible memory problems:
  <ol>
    <li><EM CLASS="CodeReg">NotEnoughMemory</EM>: available memory size is not enough for allocation.
    <li><EM CLASS="CodeReg">DamagedMemory</EM>: the addressed memory location is damaged.
    <li><EM CLASS="CodeReg">BadPointer</EM>: addressing the memory location at the given pointer address is invalid, memory is reserved for private purposes.
  </ol>
  <li><EM CLASS="CodeReg">AlgorithmicException</EM> - Problems arising during algorithmic computations:</P>
  <ol>
    <li><EM CLASS="CodeReg">NotConverged</EM>: the iterative process has not converged within the maximal iteration depth.
    <li><EM CLASS="CodeReg">InvalidOperation</EM>: the function called is not applicable to the calling object.
    <li><EM CLASS="CodeReg">InconsistentState</EM>: the state of the object is not applicable for further computations. For example, a function for the object requires some of the object fields that are not specified.
    </ol>
    <li><EM CLASS="CodeReg">BadArg</EM> - Function receives invalid arguments:
    <ol>
      <li><EM CLASS="CodeReg">NULLPointer</EM>: a null pointer.
      <li><EM CLASS="CodeReg">BadConst</EM>: enumeration fields pass as an argument a number that exceeds the enumeration size.
      <li><EM CLASS="CodeReg">OutOfRange</EM>: numeric field is out of range, for example, negative counter value.
      <li><EM CLASS="CodeReg">InconsistentType</EM>: argument type is inconsistent with the function, for example, when a function of a different class is called.
      <li><EM CLASS="CodeReg">InconsistentSize</EM>: sizes of the input arguments are inconsistent with each, for example, in matrix multiplication.
      <li><EM CLASS="CodeReg">InternalError</EM>: Exceptions related to incompleteness of the library:
      <li><EM CLASS="CodeReg">NotImplemented</EM>: the called member function is not implemented.
    </ol>
</ol>
</p>
<p>
The underlying class <EM CLASS="CodeReg">CException</EM>contains the functions that return exceptions. All child classes have no functions of their own, they are introduced only to track all exceptions of a certain type.
</p>



<hr><h4><a name="declCException_GetCode">GetCode</a></h4>
<p class="Blurb">Returns exception code.</p><pre>

int CException::GetCode() const;
</pre><p>
This function returns exception codes given in the file <EM CLASS="CodeReg">pgmError.h</EM>.
</p>


<hr><h4><a name="declCException_GenMessage">GenMessage</a></h4>
<p class="Blurb">Generates exception message.</p><pre>

void CException::GenMessage();
</pre><p>
This function generates an exception message that contains the exception type, the file name, and the number of the line in the file where this exception was thrown.
</p>


<hr><h4><a name="declCEcxeption_GetMessage">GetMessage</a></h4>
<p class="Blurb">Returns pointer to exception message.</p><pre>

const char* CEcxeption::GetMessage() const;
</pre><p>
This function returns pointer to an exception message that contains the exception type, the file name, and the number of the line in the file where this exception was thrown.
</p>


<hr><h2><a name="decl_pnlLog_Subsystem">Log Subsystem</a></h2>



<hr><h3><a name="declClassLog">Class Log </a></h3>

<p>
The subtasks of Log Subsystem  fall into four categories:
<li>Decorating output;
<li>Optimizing output;
<li>Filtering control;
<li>Addition/substraction of output devices.
</p>

<p>
There are three classes to achieve these subtasks:
<li><EM CLASS="CodeReg">Log</EM> - decorates and optimizes the output;
<li><EM CLASS="CodeReg">LogMultiplexor </EM>- filters the output and configuring;
<li><EM CLASS="CodeReg">LogDriver </EM>- outputting device.
</p>

<p>
<b>Interobject Data Flow</b>
</p>

<p>
A <EM CLASS="CodeReg">Log</EM> object forms a string and passes it to <EM CLASS="CodeReg">LogMultiplexor</EM>. The latter passes the  string to  a  corresponding driver.
</p>

<IMG SRC="fig/PNLMarch.book-174.gif">
<p>

<EM CLASS="CodeItalic">Level</EM> is a bitwise combination of the following values:
<li><EM CLASS="CodeReg">eLOG_RESULT</EM>  Resulting value.
<li><EM CLASS="CodeReg">eLOG_SYSERR </EM>System error.
<li><EM CLASS="CodeReg">eLOG_PROGERR</EM>  Program error.
<li><EM CLASS="CodeReg">eLOG_WARNING</EM>  Warning message.
<li><EM CLASS="CodeReg">eLOG_NOTICE</EM>  Message  that does not contain error conditions, but indicates that the information should possibly  be handled specially.
<li><EM CLASS="CodeReg">eLOG_INFO</EM>  Information message.
<li><EM CLASS="CodeReg">eLOG_DEBUG</EM>  Message used in debugging.
<li><EM CLASS="CodeReg">eLOG_ALL</EM>  Combination of all the preceding values.
</p>

<p>
<EM CLASS="CodeItalic">Service</EM> is a bitwise combination of the following values:
<li><EM CLASS="CodeReg">eLOGSRV_LOG</EM>  Log system.
<li><EM CLASS="CodeReg">eLOGSRV_EXCEPTION_HANDLING</EM>  Exception handling.
<li><EM CLASS="CodeReg">eLOGSRV_PNL_POTENTIAL</EM>  CPotential and derived classes.
<li><EM CLASS="CodeReg">eLOGSRV_ALL </EM>Bitwise combination of all  the preceding values.
<li><EM CLASS="CodeReg">eLOGSRV_PNL</EM>  Bitwise combination of <EM CLASS="CodeReg">eLOGSRV_PNL_*.</EM>
</p>
<p>
<EM CLASS="CodeReg">enum LogDriver::EConfCmd</EM> holds command to configure filtering.
<li><EM CLASS="CodeReg">eADD</EM>  Addition.
<li><EM CLASS="CodeReg">eDELETE</EM>  Subtraction.
<li><EM CLASS="CodeReg">eSET</EM>  Clearing of the old value and setting  a new value.
</p>




<hr><h4><a name="decl_pnlLog">Log</a></h4>
<p class="Blurb">Constructs class object.</p><pre>

Log::Log( const char *<EM CLASS="CodeItalic">prefix</EM>, int <EM CLASS="CodeItalic">level</EM>, int <EM CLASS="CodeItalic">service </EM>);
</pre><p><dl>
 Arguments
<dt>prefix  <dd>Prefix for each line dumped with this object.
<dt>level <dd>Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services.
</dl></p>
<F2>

<hr><h4><a name="decl_pnlLog">Log</a></h4>
<p class="Blurb">Constructs object by signature.</p><pre>

Log::Log( const char *<EM CLASS="CodeItalic">signature</EM> );
</pre><p><dl>
 Arguments
<dt>signature <dd>Signature string.
</dl></p><p>
This function constructs an object by signiture. To use a signature, you should register it with the <EM CLASS="CodeReg">
Register()</EM> function. If the function finds no signiture, default signiture is used. You can change the default signature by registering it with an empty signature.</p>


<hr><h4><a name="declLog_Register">Register</a></h4>
<p class="Blurb">Registres Log creating options.</p><pre>

void Log::Register( const char *<EM CLASS="CodeItalic">signature</EM> ) const;
</pre><p><dl>
 Arguments
<dt>signature <dd>Signature string.
</p></dl>


<hr><h4><a name="declLog_flush">flush</a></h4>
<p class="Blurb">Flushes output.</p><pre>

void Log::flush();
</pre><p>
Output is flushed automatically either during <EM CLASS="CodeReg">`&#92;n'</EM> output or during <EM CLASS="CodeReg">Log</EM> destruction.
</p>


<hr><h4><a name="decl_pnloperator&lt;&lt;">operator&lt;&lt;</a></h4>
<p class="Blurb">Dumps primitive types. </p><pre>

inline Log&amp; Log::operator&lt;&lt;(const char*);
inline Log&amp; Log::operator&lt;&lt;(const unsigned char*);
inline Log&amp; Log::operator&lt;&lt;(char);
inline Log&amp; Log::operator&lt;&lt;(unsigned char);
inline Log&amp; Log::operator&lt;&lt;(unsigned long);
inline Log&amp; Log::operator&lt;&lt;(long);
inline Log&amp; Log::operator&lt;&lt;(unsigned short);
inline Log&amp; Log::operator&lt;&lt;(short);
inline Log&amp; Log::operator&lt;&lt;(unsigned int);
inline Log&amp; Log::operator&lt;&lt;(int);
inline Log&amp; Log::operator&lt;&lt;(double);
</pre>


<hr><h4><a name="declLog_printf">printf</a></h4>
<p class="Blurb">Dumps as <EM CLASS="CodeReg">printf</EM> function.</p><pre>

void Log::printf( const char* <EM CLASS="CodeItalic">pFmt</EM>, ...);
</pre><p>
This function is similar to the <EM CLASS="CodeReg">printf</EM> function from Standard C Library.
</p>


<hr><h4><a name="declLog_Level">Level</a></h4>
<p class="Blurb">Returns current value of <EM CLASS="CodeItalic">level</EM></p><pre>

int Log::Level() const;
</pre>


<hr><h4><a name="declLog_Service">Service</a></h4>
<p class="Blurb">Returns current value of <EM CLASS="CodeItalic">service</EM></p><pre>

int Log::Service() const;
</pre>


<hr><h4><a name="declLog_SetLevel">SetLevel</a></h4>
<p class="Blurb">Sets new value to <EM CLASS="CodeItalic">level</EM></p><pre>

void Log::SetLevel(int <EM CLASS="CodeItalic">newLevel</EM>);
</pre>
<p><dl>
 Arguments
<dt>newLevel  <dd>New value of <EM CLASS="CodeItalic">level</EM>.
</dl></p>


<hr><h4><a name="declLog_SetService">SetService</a></h4>
<p class="Blurb">Sets new value to <EM CLASS="CodeItalic">service</EM></p><pre>

void Log::SetService(int <EM CLASS="CodeItalic">newService</EM>);
</pre><p><dl>
 Arguments
<dt>newService<dd>  New value of <EM CLASS="CodeItalic">service</EM>.
</dl></p>


<hr><h3><a name="declClassLogMultiplexot">Class LogMultiplexor </a></h3>

<p>
Class <EM CLASS="CodeReg">LogMultiplexor</EM> is the main commutator. Each of classes Log and LogDriver is
linked with multiplexor. The multiplexor born to be single object. It is used for group
configuration of drivers. Generally you do not create or delete this object.
</p>


<hr><h4><a name="declLogMultiplexor_Configure">Configure</a></h4>
<p class="Blurb">Configures filtering of logged information.</p><pre>

void LogMultiplexor::Configure(EConfCmd <EM CLASS="CodeItalic">command</EM>, int <EM CLASS="CodeItalic">level</EM> = eLOG_ALL, int <EM CLASS="CodeItalic">service</EM> = eLOGSRV_ALL);
</pre><p><dl>
 Arguments
<dt>command <dd>Points at an operation (see description of <EM CLASS="CodeReg">EConfCmd</EM>).
<dt>level <dd>Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services.
</dl></p><p>
This function configures filtering of logged information and is applied to all attached drivers.
</p>


<hr><h4><a name="declLogMultiplexor_WriteConfigure">WriteConfigure</a></h4>
<p class="Blurb">Dumps out configuration of attached driver to all other attached drivers.</p><pre>

void LogMultiplexor::WriteConfigure() const;
</pre><p>
This function dumps out configuration of an attached driver to all other attached drivers. It is intended for debugging purposes only.
</p>


<hr><h4><a name="declLogMultiplexor_StdMultiplexor">StdMultiplexor</a></h4>
<p class="Blurb">Gets standard multiplexor.</p><pre>

static LogMultiplexor&amp; LogMultiplexor::StdMultiplexor();
</pre>


<hr><h4><a name="declLogMultiplexor_SetStdMultiplexor">SetStdMultiplexor</a></h4>
<p class="Blurb">Sets standard multiplexor. </p><pre>

static void LogMultiplexor::SetStdMultiplexor(LogMultiplexor *<EM CLASS="CodeItalic">pMultiplexor</EM>);
</pre><p><dl>
 Arguments
<dt>pMultiplexor  <dd>Multiplexor to become standard.
</dl></p><p>
This function sets the standard multiplexor.
</p>


<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Constructs multiplexor.</p><pre>

LogMultiplexor::LogMultiplexor();
</pre>


<hr><h4><a name="declLogMultiplexor_AttachDriver">AttachDriver</a></h4>
<p class="Blurb">Attaches driver to multiplexor.</p><pre>

int LogMultiplexor::AttachDriver(LogDriver* <EM CLASS="CodeItalic">pDriver</EM>);
</pre><p><dl>
 Arguments
<dt>pDriver <dd>Driver to be attached.
</dl></p><p>
This function returns the identificator that must be  an argument of the corresponding <EM CLASS="CodeReg">DetachDriver</EM> call.
</p>


<hr><h4><a name="declLogMultiplexor_AttachLogger">AttachLogger</a></h4>
<p class="Blurb">Attaches <EM CLASS="CodeReg">Log</EM> object to multiplexor.</p><pre>

int LogMultiplexor::AttachLogger(Log* <EM CLASS="CodeItalic">pLog</EM>);
</pre><p><dl>
 Arguments
<dt>pLog  <dd>Log to be attached.
</dl></p><p>
This function returns the identificator that must be an argument of the corresponding <EM CLASS="CodeReg">DetachLogger</EM> call.
</p>


<hr><h4><a name="declLogMultiplexor_DetachDriver">DetachDriver</a></h4>
<p class="Blurb">Detaches driver from multiplexor.</p><pre>

void LogMultiplexor::DetachDriver(LogDriver* <EM CLASS="CodeItalic">pDriver</EM>, int <EM CLASS="CodeItalic">iDriver</EM>);
</pre><p><dl>
 Arguments
<dt>pDriver<dd>  Driver to be detached.
<dt>iDriver <dd>Identificator returned by <EM CLASS="CodeReg">AttachDriver()</EM>.
</dl></p>


<hr><h4><a name="declLogMultiplexor_DetachLogger">DetachLogger</a></h4>
<p class="Blurb">Detaches <EM CLASS="CodeReg">Log </EM>object  from multiplexor.</p><pre>

void LogMultiplexor::DetachLogger(Log* <EM CLASS="CodeItalic">pLog</EM>, int <EM CLASS="CodeItalic">iLogger</EM>);
</pre><p><dl>
 Arguments
<dt>pLog  Log<dd> to be detached.
<dt>iLogger<dd>  Id returned by <EM CLASS="CodeReg">AttachLogger().</EM>
</dl></p>


<hr><h4><a name="declLogMultiplexor_iUpdate">iUpdate</a></h4>
<p class="Blurb">Gets updated identificator.</p><pre>

int LogMultiplexor::iUpdate() const;
</pre><p>
This function gets the updated identificator. The identificator changes when there is a change of the configuration. The  latter changes after it is configured or after a driver is attached to/detached from it.
</p>


<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Returns <EM CLASS="CodeReg">TRUE</EM> if output is possible with given <EM CLASS="CodeItalic">level</EM> and <EM CLASS="CodeItalic">service</EM>
</p><pre>

bool LogMultiplexor::GetBDenyOutput(int *<EM CLASS="CodeItalic">piUpdate</EM>, int <EM CLASS="CodeItalic">level</EM>, int <EM CLASS="CodeItalic">service</EM>);
</pre><p><dl>
 Arguments
<dt>piUpdate  <dd>Pointer to integer, where update id will be stored.
<dt>level<dd>  Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services.
</dl></p><p>
The function returns `true' if the output is allowed within the given <EM CLASS="CodeItalic">
level</EM> and <EM CLASS="CodeItalic">service</EM>, returns `false' otherwise.
</p>


<hr><h4><a name="declLogMultiplexor_DriverReconfigured">DriverReconfigured</a></h4>
<p class="Blurb">Notifies multiplexor that driver was reconfigured.</p><pre>

void LogMultiplexor::DriverReconfigured(LogDriver *<EM CLASS="CodeItalic">pDriver</EM>);
</pre><p><dl>
 Arguments
<dt>pDriver <dd>Driver was reconfigured.
</dl></p>


<hr><h4><a name="declLogMultiplexor_WriteString">WriteString</a></h4>
<p class="Blurb">Writes string to drivers that allow output with given <EM CLASS="CodeItalic">level</EM> and <EM CLASS="CodeItalic">service</EM></p><pre>

void LogMultiplexor::WriteString(int <EM CLASS="CodeItalic">level</EM>, int <EM CLASS="CodeItalic">service</EM>, const char* <EM CLASS="CodeItalic">pStr</EM>, int <EM CLASS="CodeItalic">strLen</EM> = -1);
</pre><p><dl>
 Arguments
<dt>level<dd>  Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services.
<dt>pStr  <dd>String.
<dt>strLen  <dd>Length of the string. The length is calculated if it equals to - 1.
</dl></p><p>
This function writes a string to the drivers that allow output with the given <EM CLASS="CodeItalic">level</EM> and <EM CLASS="CodeItalic">service</EM>. This function is called by <EM CLASS="CodeReg">Log::WriteString</EM>.
</p>


<hr><h3><a name="declClassLogDriver">Class LogDriver </a></h3>

<p>
Class <EM CLASS="CodeReg">LogDriver</EM> is a basic class. It the interface for dumping out logged strings.
</p>


<hr><h4><a name="declLogDriver_Configure">Configure</a></h4>
<p class="Blurb">Configures filtering of logged information.</p><pre>

virtual void LogDriver::Configure(EConfCmd <EM CLASS="CodeItalic">command</EM>, int <EM CLASS="CodeItalic">level</EM> = eLOG_ALL,
int <EM CLASS="CodeItalic">service</EM> = eLOGSRV_ALL);
</pre><p><dl>
 Arguments
<dt>command <dd>Type of  a set operation (see description of <EM CLASS="CodeReg">EConfCmd</EM>
<dt>level <dd>Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services<EM CLASS="CodeItalic">.</EM>
</dl></p>


<hr><h4><a name="declLogDriver_isAllowedWriting">isAllowedWriting</a></h4>
<p class="Blurb">Returns true if writing is allowed by filtering for given level and service.</p><pre>

bool LogDriver::isAllowedWriting(int level, int service) const;
</pre><p><dl>
 Arguments
<dt>level <dd>Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services<EM CLASS="CodeItalic">.</EM>
</dl></p>


<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Constructs object.</p><pre>

LogDriver::LogDriver(int <EM CLASS="CodeItalic">levelMask</EM> = 0, int <EM CLASS="CodeItalic">serviceMask</EM> = 0)
</pre><p><dl>
 Arguments
<dt>levelMask <dd>Bitwise combination of levels.
<dt>serviceMask <dd>Bitwise combination of services.
</dl></p><p>
<EM CLASS="CodeReg">LogDriver</EM> is a purely virtual class.
</p>


<hr><h4><a name="declLogDriver_WriteConfigure">WriteConfigure</a></h4>
<p class="Blurb">Dumps out configuration of driver to dumping device.</p><pre>

void LogDriver::WriteConfigure(const char *<EM CLASS="CodeItalic">prefix</EM>, const LogDriver &amp;<EM CLASS="CodeItalic">driver</EM>);
</pre><p><dl>
 Arguments
<dt>prefix  <dd>Prefix for each line.
<dt>driver<dd>  Driver whose configuration is dumped.
</dl></p>


<hr><h4><a name="declLogDriver_WriteString">WriteString</a></h4>
<p class="Blurb">Writes  string.</p><pre>

virtual void LogDriver::WriteString(const char* <EM CLASS="CodeItalic">pStr</EM>, int <EM CLASS="CodeItalic">strLen</EM> = -1);
</pre><p><dl>
 Arguments
<dt>pStr<dd>  String.
<dt>strLen<dd>  Length of the string. The length is calculated if it equals to -1.
</dl></p><p>
 This function writes a string. This function is designed for the internal use.
</p>


<hr><h3><a name="declClassLogDrvStream">Class LogDrvStream </a></h3>

<p>
This class is the implementation of the <EM CLASS="CodeReg">LogDriver</EM> class which is associated with a
stream.
</p>


<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Constructs object by stream.</p><pre>

LogDrvStream::LogDrvStream(std::ostream* <EM CLASS="CodeItalic">pStream</EM>, int <EM CLASS="CodeItalic">levelMask</EM> = 0, int <EM CLASS="CodeItalic">serviceMask</EM> = 0);
</pre><p><dl>
 Arguments
<dt>pStream <dd>Pointer to the stream.
<dt>levelMask <dd>Bitwise combination of levels.
<dt>serveceMask <dd>Bitwise combination of services.
</dl></p><p>
This function constructs a class object by a stream.The stream is not deleted after theobject is deleted.
</p>


<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Constructs object by file name.</p><pre>

LogDrvStream::LogDrvStream(const char *<EM CLASS="CodeItalic">pFilename</EM>, int <EM CLASS="CodeItalic">levelMask</EM> = 0, int <EM CLASS="CodeItalic">serviceMask</EM> = 0);
</pre><p><dl>
 Arguments
<dt>bafflement  <dd>Name of the file.
<dt>levelMask <dd>Bitwise combination of levels.
<dt>serviceMask <dd>Bitwise combination of services.
</dl></p><p>
This function creates a class object by the file name. The stream is created by the file name and is deleted after deleting the object.
</p>


<hr><h4><a name="declLogDrvStream_Redirect">Redirect</a></h4>
<p class="Blurb">Redirects dumping to file.</p><pre>

void LogDrvStream::Redirect(const char *<EM CLASS="CodeItalic">fname</EM>);
</pre><p><dl>
 Arguments
<dt>fname<dd>   Name of the file.
</dl></p><p>
This function redirects dumping to a file. The stream is created by the file name and is deleted after deleting the object.
</p>


<hr><h4><a name="declLogDrvStream_Redirect">Redirect</a></h4>
<p class="Blurb">Redirects dumping to stream.</p><pre>

void LogDrvStream::Redirect(std::ostream* <EM CLASS="CodeItalic">pStream</EM>);
</pre><p><dl>
 Arguments
<dt>pStream<dd>  Stream.
</dl></p><p>
This function redirects dumping to a stream. The stream is not deleted after the object is deleted.
</p>


<hr><h4><a name="declLogDrvStream_WriteString">WriteString</a></h4>
<p class="Blurb">Implements <EM CLASS="CodeReg">LogDriver</EM> method.</p><pre>

virtual void LogDrvStream::WriteString(const char* <EM CLASS="CodeItalic">pStr</EM>, int <EM CLASS="CodeItalic">strLen</EM> = 0);
</pre><p><dl>
 Arguments
<dt>pStr  <dd>String.
<dt>strLen  <dd>Length of the string (the length is calculated if it equals to - 1).
</dl></p><p>
This function implements the <EM CLASS="CodeReg">LogDriver</EM> method. It is intended for use in the  logging subsystem only.
</p>


<hr><h3><a name="declClassLogDrvSystem">Class LogDrvSystem </a></h3>

<p>
This class is the implementation of  the <EM CLASS="CodeReg">
LogDriver</EM>  class which is associated with a stream. It resembles the <EM CLASS="CodeReg">LogDrvStream</EM> but is configured through <EM CLASS="CodeReg">ConfigureSystem(),</EM> not through <EM CLASS="CodeReg"> Configure()</EM>.
</p>



<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Constructs object by stream.</p><pre>

LogDrvSystem::LogDrvSystem(std::ostream* <EM CLASS="CodeItalic">pStream</EM>, int <EM CLASS="CodeItalic">levelMask</EM> = 0, int <EM CLASS="CodeItalic">serviceMask</EM> = 0);
</pre><p><dl>
 Arguments
<dt>pStream <dd>Pointer to the stream.
<dt>levelMask <dd>Bitwise combination of levels.
<dt>serviceMask <dd>Bitwise combination of services.
</dl></p>


<hr><h4><a name="decl_pnlLevel">Level</a></h4>
<p class="Blurb">Constructs  object by  file name.</p><pre>

LogDrvSystem::LogDrvSystem(const char *<EM CLASS="CodeItalic">pFilename</EM>, int <EM CLASS="CodeItalic">levelMask</EM> = 0, int <EM CLASS="CodeItalic">serviceMask</EM> = 0);
</pre><p><dl>
 Arguments
<dt>pFilename <dd>Name of the file.
<dt>levelMask <dd>Bitwise combination of levels.
<dt>serviceMask <dd>Bitwise combination of services.
</dl></p>


<hr><h4><a name="declLogDrvSystem_ConfigureSystem">ConfigureSystem</a></h4>
<p class="Blurb">Configures filtering of logged information.</p><pre>

void LogDrvSystem::ConfigureSystem(EConfCmd <EM CLASS="CodeItalic">command</EM>, int <EM CLASS="CodeItalic">level</EM> = eLOG_ALL,
int <EM CLASS="CodeItalic">service</EM> = eLOGSRV_ALL);
</pre><p><dl>
 Arguments
<dt>command <dd>Type of a set operation (see description of <EM CLASS="CodeReg">EConfCmd</EM>).
<dt>level <dd>Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services<EM CLASS="CodeItalic">.</EM>
</dl></p><p>
This function configures filtering of logged information. This function is identical to <EM CLASS="CodeReg">
LogDriver::Configure</EM>.
</p>


<hr><h4><a name="declLogDrvSystem_Configure">Configure</a></h4>
<p class="Blurb">Performs no action, intended for <EM CLASS="CodeReg">LogMultiplexor::Configure</EM> only.</p><pre>

virtual void LogDrvSystem::Configure(EConfCmd <EM CLASS="CodeItalic">command</EM>, int <EM CLASS="CodeItalic">level</EM> = eLOG_ALL,
int <EM CLASS="CodeItalic">service </EM>= eLOGSRV_ALL);
</pre><p><dl>
 Arguments
<dt>command <dd>Type of a set operation.(see description of <EM CLASS="CodeReg">EConfCmd</EM>).
<dt>level <dd>Bitwise combination of levels.
<dt>service <dd>Bitwise combination of services<EM CLASS="CodeItalic">.</EM>
</dl></p>


<hr><h3><a name="decl_pnlSaving_Models_to_File/Loading_Models_from_File">Saving Models to File/Loading Models from File</a></h3>

<p>Class <EM CLASS="CodeReg">CContextPersistence</EM> serves as the interface for saving a model to a file and for loading a model from a file. You can save following types of models: <EM CLASS="CodeReg">BNet</EM>, <EM CLASS="CodeReg">DBN</EM>, <EM CLASS="CodeReg">MNet</EM>, <EM CLASS="CodeReg">MRF2</EM>, if they do not contain one or more tree distribution functions. You cannot save following types of models: <EM CLASS="CodeReg">FactorGraph</EM>, <EM CLASS="CodeReg">JunctionTree</EM>.
</p>
<p>
To save a model to a file put it into a <EM CLASS="CodeReg">CContextPersistence</EM> object by calling <EM CLASS="CodeSmall">Put</EM>  and call <EM CLASS="CodeSmall">SaveAsXML</EM> indicating the name of the file.
</p>



<b>Saving a model to a file</b>
<pre>
CContextPersistence xmlContext;
xmlContext.Put(pGraphicalModel, MyModel);
if(!xmlContext.SaveAsXML(myFavoriteObjects.xml))
{
  // something goes wrong  cant create file, disk full or 
}
</pre>
<p>
To load a model from the file call the <EM CLASS="CodeReg">LoadXML</EM> function and request the context objects by their names.</P>
</p>

<b>Loading model from file</b>
<pre>
CContextPersistence xmlContext;
if(xmlContext.LoadXML(myFavoriteObjects.xml))
{
  // cant open file or bad file content
}
CBNet *pGrModel = static_cast<CBNet*>(xmlContext.Get( MyModel));
</pre>

<hr><h3><a name="declClassCContextPersistence">Class CContextPersistence </a></h3>

<p>
Class <EM CLASS="CodeReg">CContextPersistence</EM> serves as the interface for saving a model to a file and for loading a model from a file. You can save following types of models: <EM CLASS="CodeReg">BNet</EM>, <EM CLASS="CodeReg">DBN</EM>, <EM CLASS="CodeReg">MNet</EM>, <EM CLASS="CodeReg">MRF2</EM>, if they do not contain one or more tree distribution functions. You cannot save following types of models: <EM CLASS="CodeReg">FactorGraph</EM>, <EM CLASS="CodeReg">JunctionTree</EM>.
</p>
<p>
To save a model to a file put it into a <EM CLASS="CodeReg">CContextPersistence</EM> object by calling <EM CLASS="CodeSmall">Put</EM>  and call <EM CLASS="CodeSmall">SaveAsXML</EM> indicating the name of the file.
</p>


<hr><h4><a name="decl_pnlCContextPersistence">CContextPersistence</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CContextPersistence::CContextPersistence();
</pre>


<hr><h4><a name="declCContextPersistence_SaveAsXML">SaveAsXML</a></h4>
<p class="Blurb">Saves object to XML file.</p><pre>

bool CContextPersistence::SaveAsXML(const std::string &amp;<EM CLASS="CodeItalic">filename</EM>) const;
</pre><p><dl>
 Arguments
<dt>filename<dd>  Name of the file where an object is to be saved.
</dl></p><p>
This function saves a contextual object into a <EM CLASS="CodeReg">
XML</EM>
 file. The function returns `true' if saving is successful, returns `false' otherwise.
</p>


<hr><h4><a name="declCContextPersistence_LoadXML">LoadXML</a></h4>
<p class="Blurb">Loads object from XML file.</p><pre>

bool CContextPersistence::LoadXML(const std::string &amp;<EM CLASS="CodeItalic">filename</EM>);
</pre><p><dl>
 Arguments
<dt>filename<dd>  Name of the file from which the object is to be loaded.
</dl></p><p>
This function loads a PNL object from an XML file. The function returns `true' if loading is successful, returns `false' otherwise.
</p>


<hr><h3><a name="declClassCContext">Class CContext </a></h3>


<p>
This is a basic class for all contexts. Stores the tree corresponding to object structures.
Traverses a tree of objects.
</p>

<hr><h4><a name="decl_pnlCContext">CContext</a></h4>
<p class="Blurb">Creates class object.</p><pre>

CContext::CContext();
</pre>


<hr><h4><a name="declCContext_Put">Put</a></h4>
<p class="Blurb">Puts object into context.</p><pre>

void CContext::Put(CPNLBase *<EM CLASS="CodeItalic">pObj</EM>, const char *<EM CLASS="CodeItalic">name</EM>, bool <EM CLASS="CodeItalic">bAutoDelete</EM> = false);
</pre><p><dl>
 Arguments
<dt>pObj<dd>  Pointer to the object.
<dt>name<dd>  Object name.
<dt>bAutoDelete<dd>  Flag of automatic deletion. If it is set to `true' The object is to be deleted on deletion of the context.
</dl></p><p>
This function puts the object into the context by name. The object is requested from the context by the name through the <EM CLASS="CodeReg">Get() </EM>function.
</p>


<hr><h4><a name="decl_pnlGet">Get</a></h4>
<p class="Blurb">Returns pointer to object found by name.</p><pre>

CPNLBase *CContext::Get (const char *<EM CLASS="CodeItalic">name</EM>);
</pre><p><dl>
 Arguments
<dt>name<dd>  Name of the object.
</dl></p><p>
This function requests for a contextual object by name and returns the pointer to the first object found. If there is no object in the context the function returns NULL.
</p>
</body></html>

